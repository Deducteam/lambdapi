// Polymorphic lists

require open Logic.TFF.Set Logic.TFF.Prop Logic.TFF.Main Logic.TFF.Eq
             Logic.TFF.Nat;

(a:Set) inductive ğ•ƒ:TYPE â‰”
| â–¡ : ğ•ƒ a // \Box
| â¸¬ : Ï„ a â†’ ğ•ƒ a â†’ ğ•ƒ a; // ::

notation â¸¬ infix right 4;

// set code for ğ•ƒ

constant symbol list : Set â†’ Set;

rule Ï„ (list $a) â†ª ğ•ƒ $a;

// Length of a list

symbol length [a] : ğ•ƒ a â†’ â„•;

rule length â–¡ â†ª 0
with length (_ â¸¬ $l) â†ª s (length $l);

// Concatenation of two lists

symbol â‹… [a] : ğ•ƒ a â†’ ğ•ƒ a â†’ ğ•ƒ a;

notation â‹… infix right 15; // \cdot

assert a (x y z:ğ•ƒ a) âŠ¢ x â‹… y â‹… z â‰¡ x â‹… (y â‹… z);
assert a x l m âŠ¢ x â¸¬ l â‹… m â‰¡ x â¸¬ (l â‹… m);

rule â–¡ â‹… $m â†ª $m
with ($x â¸¬ $l) â‹… $m â†ª $x â¸¬ ($l â‹… $m);

opaque symbol concat_nil [a] (l:ğ•ƒ a) : Ï€(l â‹… â–¡ = l) â‰”
begin
  assume a; induction
  { reflexivity }
  { assume x l' h; simplify; rewrite h; reflexivity }
end;

rule $m â‹… â–¡ â†ª $m;

opaque symbol length_concat [a] (l m : ğ•ƒ a) :
  Ï€(length (l â‹… m) = length l + length m) â‰”
begin
  assume a; induction
  { reflexivity }
  { assume x l' h m; simplify; rewrite h; reflexivity }
end;

rule length ($l â‹… $m) â†ª length $l + length $m;

opaque symbol concat_assoc [a] (l m n : ğ•ƒ a) : Ï€((l â‹… m) â‹… n = l â‹… (m â‹… n)) â‰”
begin
  assume a; induction
  { reflexivity }
  { assume x l' h m n; simplify; rewrite h; reflexivity }
end;

rule ($l â‹… $m) â‹… $n â†ª $l â‹… ($m â‹… $n);

// List reversal

symbol rev [a] : ğ•ƒ a â†’ ğ•ƒ a;

rule rev â–¡ â†ª â–¡
with rev ($x â¸¬ $l) â†ª rev $l â‹… ($x â¸¬ â–¡);

opaque symbol rev_concat [a] (l m : ğ•ƒ a) : Ï€(rev (l â‹… m) = rev m â‹… rev l) â‰”
begin
  assume a; induction
  { simplify; reflexivity }
  { assume x l h m; simplify; rewrite h; reflexivity }
end;

rule rev ($l â‹… $m) â†ª rev $m â‹… rev $l;

opaque symbol rev_idem [a] (l :ğ•ƒ a) : Ï€(rev (rev l) = l) â‰”
begin
  assume a; induction
  { reflexivity }
  { assume x l h; simplify; rewrite h; reflexivity }
end;

rule rev (rev $l) â†ª $l;

opaque symbol length_rev [a] (l : ğ•ƒ a) : Ï€(length (rev l) = length l) â‰”
begin
  assume a; induction
  { simplify; reflexivity }
  { assume x l h; simplify; rewrite h; reflexivity }
end;

/* We cannot declare
rule length (rev $l) â†ª length $l;
without declaring + commutative because
Unjoinable critical pair:
t â‰” length (rev ($2 â‹… $3))
t â†ª[] length ($2 â‹… $3) â†ª* length $2 + length $3
  with length (rev $2') â†ª length $2'
t â†ª[1] length (rev $3 â‹… rev $2) â†ª* length $3 + length $2
  with rev ($2 â‹… $3) â†ª rev $3 â‹… rev $2
*/
