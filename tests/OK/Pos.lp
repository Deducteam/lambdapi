/* Positive binary integers

by Quentin Garchery (May 2021). */

require open tests.OK.Nat tests.OK.Comp;

inductive â„™ : TYPE â‰”
| I : â„™ â†’ â„™
| O : â„™ â†’ â„™
| H : â„™;

// set code for â„™

constant symbol pos : Set;

rule Ï„ pos â†ª â„™;

// boolean functions for testing head constructor

symbol isI : â„™ â†’ ğ”¹;

rule isI (I _) â†ª true
with isI (O _) â†ª false
with isI H     â†ª false;

symbol isO : â„™ â†’ ğ”¹;

rule isO (I _) â†ª false
with isO (O _) â†ª true
with isO H     â†ª false;

symbol isH : â„™ â†’ ğ”¹;

rule isH (I _) â†ª false
with isH (O _) â†ª false
with isH H     â†ª true;

// Discriminate constructors

opaque symbol Iâ‰ H [x] : Ï€ (I x â‰  H) â‰”
begin
  assume x h; refine ind_eq h (Î» x, istrue(isH x)) âŠ¤áµ¢;
end;

opaque symbol Oâ‰ H [x] : Ï€ (O x â‰  H) â‰”
begin
  assume x h; refine ind_eq h (Î» x, istrue(isH x)) âŠ¤áµ¢;
end;

opaque symbol Iâ‰ O [x y] : Ï€ (I x â‰  O y) â‰”
begin
  assume x y h; refine ind_eq h (Î» x, istrue(isO x)) âŠ¤áµ¢;
end;

opaque opaque symbol caseH x : Ï€(x = H âˆ¨ x â‰  H) â‰”
begin
  induction
  { assume x h; apply âˆ¨áµ¢â‚‚; refine Iâ‰ H }
  { assume x h; apply âˆ¨áµ¢â‚‚; refine Oâ‰ H }
  { apply âˆ¨áµ¢â‚; reflexivity }
end;

// Constructors are injective

symbol projO : â„™ â†’ â„™;

rule projO (O $x) â†ª $x
with projO (I $x) â†ª I $x
with projO H â†ª H;

opaque opaque symbol O_inj p q : Ï€(O p = O q) â†’ Ï€(p = q) â‰”
begin
  assume p q h; apply feq projO h
end;

symbol projI : â„™ â†’ â„™;

rule projI (I $x) â†ª $x
with projI (O $x) â†ª O $x
with projI H â†ª H;

opaque opaque symbol I_inj p q : Ï€(I p = I q) â†’ Ï€(p = q) â‰”
begin
  assume p q h; apply feq projI h
end;

// Successor function

symbol succ : â„™ â†’ â„™;

rule succ (I $x) â†ª O (succ $x)
with succ (O $x) â†ª I $x
with succ H â†ª O H;

// Interpretation of â„™ in â„•

symbol val : â„™ â†’ â„•;

rule val H â†ª 1
with val (O $x) â†ª 2 * val $x
with val (I $x) â†ª val (O $x) +1;

assert âŠ¢ val (O (I H)) â‰¡ 6;

opaque opaque symbol valS x : Ï€(val (succ x) = val x +1) â‰”
begin
  induction
  { assume x h; simplify; rewrite h; reflexivity }
  { assume x h; reflexivity }
  { reflexivity }
end;

opaque opaque symbol val_surj [n] : Ï€(n â‰  0 â‡’ `âˆƒ x, val x = n) â‰”
begin
  induction
  { assume h; apply âŠ¥â‚‘; apply h; reflexivity }
  { assume n h i; apply âˆ¨â‚‘ (casen n)
    { assume j; apply âˆƒáµ¢ H; rewrite j; reflexivity }
    { assume j; apply âˆƒâ‚‘ (h j); assume p k; apply âˆƒáµ¢ (succ p);
      rewrite left k; apply valS p /*FIXME*/ } 
  }
end;

opaque opaque symbol valâ‰ 0 x : Ï€(val x â‰  0) â‰”
begin
  induction
  { assume x h; refine sâ‰ 0 }
  { assume x h; simplify; assume i;
    apply h (âˆ§â‚‘â‚ (âˆ§â‚‘â‚ (addn_eq0 (val x) (val x)) i))
  }
  { refine sâ‰ 0 }
end;

opaque opaque symbol 2*valâ‰ 0 x : Ï€(val x + val x â‰  0) â‰”
begin
  assume x h; apply âŠ¥â‚‘; apply valâ‰ 0 x; apply 2*=0; apply h
end;

opaque opaque symbol val_inj [x y] : Ï€(val x = val y) â†’ Ï€(x = y) â‰”
begin
  induction
  { assume x h; induction
    { simplify; assume y i j; rewrite h y _
        { apply 2*_inj; apply +1_inj; apply j }
        { reflexivity }
    }
    { simplify; assume y i j; apply âŠ¥â‚‘; apply oddâ‰ even (val x) (val y) j }
    { simplify; assume i; apply âŠ¥â‚‘; apply 2*valâ‰ 0 x; apply +1_inj; apply i }
  }
  { assume x h; induction
    { simplify; assume y i j; apply âŠ¥â‚‘;
      apply oddâ‰ even (val y) (val x) (eq_sym j) }
    { simplify; assume y i j; apply feq O; apply h; apply 2*_inj; apply j }
    { assume i; apply âŠ¥â‚‘; apply oddâ‰ even 0 (val x); symmetry; apply i }
  }
  { induction
    { simplify; assume x h i; apply âŠ¥â‚‘; apply valâ‰ 0 x; apply 2*=0; apply +1_inj;
      symmetry; apply i }
    { simplify; assume x h i; apply âŠ¥â‚‘; apply oddâ‰ even 0 (val x); apply i }
    { reflexivity }
  }
end;

// â„•-like Induction Principle

opaque symbol ind_â„™eano p : Ï€ (p H) â†’ (Î  x, Ï€ (p x) â†’ Ï€ (p (succ x))) â†’ Î  x, Ï€ (p x) â‰”
begin
  assume p pH psucc;
  have i: Ï€(`âˆ€ n, `âˆ€ x, val x = n â‡’ p x) {
    induction
    { induction
      { assume x h i; apply âŠ¥â‚‘ (sâ‰ 0 i) }
      { assume x h i; apply âŠ¥â‚‘ (valâ‰ 0 (O x) i) }
      { assume i; apply âŠ¥â‚‘ (sâ‰ 0 i) }
    }
    { assume n h x; apply âˆ¨â‚‘ (casen n)
      { assume i; rewrite i; assume j;
        have k: Ï€(x = H) { apply val_inj; apply j };
        rewrite k; apply pH
      }
      { assume i; apply âˆƒâ‚‘ (val_surj i); assume y j; rewrite left j;
        rewrite left valS; assume k; have l: Ï€(x = succ y) { apply val_inj k };
        rewrite l; apply psucc y; apply h; apply j
      }
    }
  };
  assume x; apply i (val x); reflexivity
end;

// Addition of â„™ numbers with and without a carry

symbol add : â„™ â†’ â„™ â†’ â„™;
symbol add_carry : â„™ â†’ â„™ â†’ â„™;

rule add (I $x) (I $q) â†ª O (add_carry $x $q)
with add (I $x) (O $q) â†ª I (add $x $q)
with add (O $x) (I $q) â†ª I (add $x $q)
with add (O $x) (O $q) â†ª O (add $x $q)
with add $x      H      â†ª succ $x
with add H      $y      â†ª succ $y;

rule add_carry (I $x) (I $q) â†ª I (add_carry $x $q)
with add_carry (I $x) (O $q) â†ª O (add_carry $x $q)
with add_carry (O $x) (I $q) â†ª O (add_carry $x $q)
with add_carry (O $x) (O $q) â†ª I (add $x $q)
with add_carry $x      H      â†ª add $x (O H)
with add_carry H      $y      â†ª add (O H) $y;
// for efficiency reasons last cases should not be 'succ (succ $x)'

// Check that 7 + 5 = 12
assert âŠ¢ add (I (I H)) (I (O H)) â‰¡ O (O (I H));
// Check that 110101010 + 101101100 â‰¡ 1100010110 in base 2 (426 + 364 â‰¡ 790)
assert âŠ¢ add (O (I (O (I (O (I (O (I H))))))))
             (O (O (I (I (O (I (I (O H))))))))
  â‰¡ (O (I (I (O (I (O (O (O (I H)))))))));

// Interaction of succ and add

opaque symbol succ_add x y : Ï€ (succ (add x y) = add_carry x y) â‰”
begin
  induction
  // case I
  { assume p prec;
    induction
      { reflexivity }
      { assume q h; simplify; rewrite prec; reflexivity }
      { reflexivity } }
  // case O
  { assume p prec;
    induction
      { assume q h; simplify; rewrite prec; reflexivity }
      { reflexivity }
      { reflexivity } }
  // case H
  { induction { reflexivity } { reflexivity } { reflexivity }  }
end;

opaque symbol add_succ x y : Ï€ (add (succ x) y = succ (add x y)) â‰”
begin
  induction
  // case I
  { assume p prec;
    induction
     { assume q h; simplify; rewrite prec; rewrite succ_add; reflexivity }
     { assume q h; simplify; rewrite prec; reflexivity }
     { reflexivity } }
  // case O
  { assume p prec;
    induction
      { assume q h; simplify; rewrite succ_add; reflexivity }
      { reflexivity }
      { reflexivity } }
  // case H
  { induction { reflexivity } { reflexivity } { reflexivity } }
end;

opaque symbol add_succ_right x y : Ï€ (add x (succ y) = succ (add x y)) â‰”
begin
  refine ind_â„™eano (Î» x, `âˆ€ y, add x (succ y) = succ (add x y)) _ _
  // case H
  { reflexivity }
  // case succ
  { assume x xrec y;
    rewrite add_succ; rewrite add_succ; rewrite xrec; reflexivity }
end;

// Associativity of the addition

opaque symbol add_assoc x y z : Ï€ (add (add x y) z = add x (add y z)) â‰”
begin
  refine ind_â„™eano (Î» x, `âˆ€ y, `âˆ€ z, add (add x y) z = add x (add y z)) _ _
  // case H
  { refine add_succ }
  // case succ
  { assume x xrec y z;
    rewrite add_succ; rewrite add_succ; rewrite add_succ;
    rewrite xrec; reflexivity }
end;

// Commutativity of the addition

opaque symbol add_com x y : Ï€ (add x y = add y x) â‰”
begin
  refine ind_â„™eano (Î» x, `âˆ€ y, add x y = add y x) _ _
  // case H
  { reflexivity }
  // case succ
  { assume x xrec y;
    rewrite add_succ; rewrite add_succ_right; rewrite xrec; reflexivity }
end;

// function Î» x, 2 * x - 1

symbol pos_pred_double : â„™ â†’ â„™;

rule pos_pred_double (I $x) â†ª I (O $x)
with pos_pred_double (O $x) â†ª I (pos_pred_double $x)
with pos_pred_double H      â†ª H;

opaque symbol pos_pred_double_succ x : Ï€ (pos_pred_double (succ x) = I x) â‰”
begin
  induction
  { assume x xrec; simplify; rewrite xrec; reflexivity }
  { reflexivity }
  { reflexivity }
end;

opaque symbol succ_pos_pred_double x : Ï€ (succ (pos_pred_double x) = O x) â‰”
begin
  induction
   { reflexivity }
   { assume x xrec; simplify; rewrite xrec; reflexivity }
   { reflexivity }
end;

// Comparison of â„™ numbers

symbol compare_acc : â„™ â†’ Comp â†’ â„™ â†’ Comp;

rule compare_acc (I $x) $c (I $q) â†ª compare_acc $x $c $q
with compare_acc (I $x) _  (O $q) â†ª compare_acc $x Gt $q
with compare_acc (I _)  _  H      â†ª Gt
with compare_acc (O $x) _  (I $q) â†ª compare_acc $x Lt $q
with compare_acc (O $x) $c (O $q) â†ª compare_acc $x $c $q
with compare_acc (O _)  _  H      â†ª Gt
with compare_acc H      _  (I _)  â†ª Lt
with compare_acc H      _  (O _)  â†ª Lt
with compare_acc H      $c H      â†ª $c;

symbol compare x y â‰” compare_acc x Eq y;

// Commutative property of compare

opaque symbol compare_acc_com x y c :
  Ï€ (compare_acc y c x = opp (compare_acc x (opp c) y)) â‰”
begin
  induction
  // case I
  { assume x xrec;
    induction
     { assume y h c; simplify; rewrite xrec; reflexivity }
     { assume y h c; simplify; rewrite xrec; reflexivity }
     { reflexivity } }
  // case O
  { assume x xrec;
    induction
     { assume y h c; simplify; rewrite xrec; reflexivity }
     { assume y h c; simplify; rewrite xrec; reflexivity }
     { reflexivity } }
  // case H
  { induction
     { reflexivity }
     { reflexivity }
     { assume c; simplify; rewrite opp_idem; reflexivity } }
end;

opaque symbol compare_com x y : Ï€ (compare y x = opp (compare x y)) â‰”
begin
  assume x y; refine compare_acc_com x y Eq;
end;

// Compare decides the equality

opaque symbol compare_acc_nEq x y c : Ï€ (c â‰  Eq â‡’ compare_acc x c y â‰  Eq) â‰”
begin
  induction
  // case I
  { assume x xrec;
    induction
     { assume y h c H; refine xrec y c H }
     { assume y h c H; refine xrec y Gt _; refine Gtâ‰ Eq }
     { assume c h; refine Gtâ‰ Eq } }
  // case O
  { assume x xrec;
    induction
     { assume y h c H; refine xrec y Lt _; refine Ltâ‰ Eq }
     { assume y h c H; refine xrec y c H }
     { assume c h; refine Gtâ‰ Eq } }
  // case H
  { induction
     { assume y h c H; refine Ltâ‰ Eq }
     { assume y h c H; refine Ltâ‰ Eq }
     { assume c Hc; refine Hc } }
end;

opaque symbol compare_decides x y : Ï€ (compare x y = Eq â‡’ x = y) â‰”
begin
  induction
  // case I
  { assume x xrec;
    induction
     { assume y h H; rewrite xrec y H; reflexivity }
     { assume y h H; apply âŠ¥â‚‘; refine compare_acc_nEq x y Gt _ H; refine Gtâ‰ Eq }
     { assume H; apply âŠ¥â‚‘; refine Gtâ‰ Eq H } }
  // case O
  { assume x xrec;
    induction
     { assume y h H; apply âŠ¥â‚‘; refine compare_acc_nEq x y Lt _ H; refine Ltâ‰ Eq }
     { assume y h H; rewrite xrec y H; reflexivity }
     { assume H; apply âŠ¥â‚‘; refine Gtâ‰ Eq H } }
  // case H
  { induction
    { assume y h H; apply âŠ¥â‚‘; refine Ltâ‰ Eq H }
    { assume y h H; apply âŠ¥â‚‘; refine Ltâ‰ Eq H }
    { reflexivity } }
end;

// Compare with Gt or Lt

opaque symbol compare_Lt x y :
  Ï€ (compare_acc x Lt y = case_Comp (compare x y) Lt Lt Gt) â‰”
begin
  induction
  // case I
  { assume x xrec;
    induction
     { assume y h; refine xrec y }
     { assume y h; simplify;
       refine ind_Comp (Î» c, compare_acc x Gt y = c â‡’ c = case_Comp c Lt Lt Gt) _ _ _ (compare_acc x Gt y) _
         { assume H; apply âŠ¥â‚‘; refine compare_acc_nEq x y Gt _ H }
         { refine Gtâ‰ Eq }
         { reflexivity }
         { reflexivity } }
     { reflexivity; reflexivity } }
  // case O
  { assume x xrec;
    induction
     { assume y h; simplify;
       refine ind_Comp (Î» c, compare_acc x Lt y = c â‡’ c = case_Comp c Lt Lt Gt) _ _ _ (compare_acc x Lt y) _
         { assume H; apply âŠ¥â‚‘; refine compare_acc_nEq x y Lt _ H }
         { refine Ltâ‰ Eq }
         { reflexivity }
         { reflexivity } }
     { reflexivity }
     { assume y h; refine xrec y;
       reflexivity } }
  // case H
  { induction { reflexivity } { reflexivity } { reflexivity } }
end;

opaque symbol compare_Gt x y :
  Ï€ (compare_acc x Gt y = case_Comp (compare x y) Gt Lt Gt) â‰”
begin
  induction
  // case I
  { assume x xrec;
    induction
      { assume y h; refine xrec y }
      { assume y h; simplify;
        refine ind_Comp (Î» c, compare_acc x Gt y = c â‡’ c = case_Comp c Gt Lt Gt) _ _ _ (compare_acc x Gt y) _
          { assume H; apply âŠ¥â‚‘; refine compare_acc_nEq x y Gt _ H }
          { refine Gtâ‰ Eq }
          { reflexivity }
          { reflexivity } }
      { reflexivity; reflexivity }  }
  // case O
  { assume x xrec;
    induction
      { assume y h; simplify;
        refine ind_Comp (Î» c, compare_acc x Lt y = c â‡’ c = case_Comp c Gt Lt Gt) _ _ _ (compare_acc x Lt y) _
          { assume H; apply âŠ¥â‚‘; refine compare_acc_nEq x y Lt _ H }
          { refine Ltâ‰ Eq }
          { reflexivity }
          { reflexivity } }
     { reflexivity; assume y h; refine xrec y }
     { reflexivity } }
  // case H
  { induction { reflexivity } { reflexivity } { reflexivity } }
end;

// Compatibility of compare with the addition

opaque symbol compare_H_Lt y : Ï€ (compare_acc H Lt y = Lt) â‰”
begin
  induction { reflexivity } { reflexivity } { reflexivity }
end;

opaque symbol compare_Gt_H x : Ï€ (compare_acc x Gt H = Gt) â‰”
begin
  induction { reflexivity } { reflexivity } { reflexivity }
end;

opaque symbol compare_H_succ y c : Ï€ (compare_acc H c (succ y) = Lt) â‰”
begin
  induction { reflexivity } { reflexivity } { reflexivity }
end;

opaque symbol compare_succ_H x c : Ï€ (compare_acc (succ x) c H = Gt) â‰”
begin
  induction { reflexivity } { reflexivity } { reflexivity }
end;

opaque symbol compare_succ_Lt x y :
  Ï€ (compare_acc (succ x) Lt y = compare_acc x Gt y) â‰”
begin
  induction
  // case I
  { assume x xrec;
    induction
     { assume y h; refine xrec y }
     { assume y h; refine xrec y }
     { reflexivity } }
  // case O
  { assume x xrec;
    induction { reflexivity } { reflexivity } { reflexivity } }
  // case H
  { induction
     { assume y h; refine compare_H_Lt y }
     { assume y h; refine compare_H_Lt y }
     { reflexivity } }
end;

opaque symbol compare_Gt_succ x y :
  Ï€ (compare_acc x Gt (succ y) = compare_acc x Lt y) â‰”
begin
  assume x y;
  rewrite compare_acc_com; rewrite .[u in _ = u] compare_acc_com;
  simplify; rewrite compare_succ_Lt; reflexivity;
end;

opaque symbol compare_succ_succ x y c :
  Ï€ (compare_acc (succ x) c (succ y) = compare_acc x c y) â‰”
begin
  induction
  // case I
  { assume x xrec;
    induction
     { assume y h c; refine xrec y c }
     { assume y h c; simplify; refine compare_succ_Lt x y }
     { assume c; simplify; refine compare_succ_H x c } }
  // case O
  { assume x xrec;
    induction
     { assume y h c; simplify; refine compare_Gt_succ x y }
     { assume y h c; reflexivity }
     { assume c; simplify; refine compare_Gt_H x } }
  // case H
  { induction
     { assume y h c; simplify; refine compare_H_succ y c }
     { assume y h c; simplify; refine compare_H_Lt y }
     { reflexivity } }
end;

opaque symbol compare_compat_add a x y :
  Ï€ (compare (add x a) (add y a) = compare x y) â‰”
begin
  refine ind_â„™eano (Î» a, `âˆ€ x, `âˆ€ y, compare (add x a) (add y a) = compare x y) _ _
  // case H
  { assume x y; refine compare_succ_succ x y Eq }
  // case succ
  { assume a arec x y;
    rewrite add_succ_right; rewrite add_succ_right; rewrite left arec x y;
    simplify; rewrite compare_succ_succ; reflexivity }
end;

// Multiplication

symbol mul : â„™ â†’ â„™ â†’ â„™;

rule mul (I $x) $y â†ª add $y (O (mul $x $y))
with mul (O $x) $y â†ª O (mul $x $y)
with mul H      $y â†ª $y;

// enable printing of positive numbers in decimal notation

builtin "pos_one" â‰” H;
builtin "pos_double" â‰” O;
builtin "pos_succ_double" â‰” I;

// shortcuts

symbol _1 â‰” H; assert âŠ¢ val _1 â‰¡ 1;
symbol _2 â‰” O H; assert âŠ¢ val _2 â‰¡ 2;
symbol _3 â‰” I H; assert âŠ¢ val _3 â‰¡ 3;
symbol _4 â‰” O (O H); assert âŠ¢ val _4 â‰¡ 4;
symbol _5 â‰” I (O H); assert âŠ¢ val _5 â‰¡ 5;
symbol _6 â‰” O (I H); assert âŠ¢ val _6 â‰¡ 6;
symbol _7 â‰” I (I H); assert âŠ¢ val _7 â‰¡ 7;
symbol _8 â‰” O (O (O H)); assert âŠ¢ val _8 â‰¡ 8;
symbol _9 â‰” I (O (O H)); assert âŠ¢ val _9 â‰¡ 9;
symbol _10 â‰” O (I (O H)); assert âŠ¢ val _10 â‰¡ 10;
