/* Comparison datatype

By Quentin Garchery (May 2021). */

require open tests.OK.Set tests.OK.Prop tests.OK.FOL tests.OK.Eq
  tests.OK.Bool;

inductive Comp : TYPE â‰”
| Eq : Comp
| Lt : Comp
| Gt : Comp;

// set code for Comp

constant symbol comp : Set;

rule Ï„ comp â†ª Comp;

// Boolean functions for testing head constructor

symbol isEq : Comp â†’ ğ”¹;

rule isEq Eq â†ª true
with isEq Lt â†ª false
with isEq Gt â†ª false;

symbol isLt : Comp â†’ ğ”¹;

rule isLt Eq â†ª false
with isLt Lt â†ª true
with isLt Gt â†ª false;

symbol isGt : Comp â†’ ğ”¹;

rule isGt Eq â†ª false
with isGt Lt â†ª false
with isGt Gt â†ª true;

symbol isLe : Comp â†’ ğ”¹;

rule isLt Eq â†ª true
with isLt Lt â†ª true
with isLt Gt â†ª false;

symbol isGe : Comp â†’ ğ”¹;

rule isLt Eq â†ª true
with isLt Lt â†ª false
with isLt Gt â†ª true;

// Discriminate constructors

symbol Ltâ‰ Eq : Ï€ (Lt â‰  Eq) â‰”
begin
  assume h; refine ind_eq h (Î» n, istrue(isEq n)) âŠ¤áµ¢
end;

symbol Gtâ‰ Eq : Ï€ (Gt â‰  Eq) â‰”
begin
  assume h; refine ind_eq h (Î» n, istrue(isEq n)) âŠ¤áµ¢
end;

symbol Gtâ‰ Lt : Ï€ (Gt â‰  Lt) â‰”
begin
  assume h; refine ind_eq h (Î» n, istrue(isLt n)) âŠ¤áµ¢
end;

// Opposite of a Comp

symbol opp : Comp â†’ Comp;

rule opp Eq â†ª Eq
with opp Lt â†ª Gt
with opp Gt â†ª Lt;

symbol opp_idem c : Ï€ (opp (opp c) = c) â‰”
begin
  induction { reflexivity; } { reflexivity; } { reflexivity; }
end;

// Conditional

symbol case_Comp [A] : Comp â†’ Ï„ A â†’ Ï„ A â†’ Ï„ A â†’ Ï„ A;

rule case_Comp Eq $x _ _ â†ª $x
with case_Comp Lt _ $x _ â†ª $x
with case_Comp Gt _ _ $x â†ª $x;
