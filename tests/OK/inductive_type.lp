/////////////////////////////
// Configuration
/////////////////////////////

constant symbol Prop : TYPE      // Type of propositions
set declared "Ï€"
injective symbol Ï€ : Prop â†’ TYPE // Interpretation of propositions in TYPE

set builtin "Prop"     â‰” Prop
set builtin "P"     â‰” Ï€

constant symbol Set : TYPE       // Type of set codes
set declared "Ï„"
injective symbol Ï„ : Set â†’ TYPE  // Interpretation of set codes in TYPE

/////////////////////////////
// Equality
/////////////////////////////

constant symbol eq {a} : Ï„ a â†’ Ï„ a â†’ Prop
set infix 8 "=" â‰” eq
constant symbol eq_refl {a} (x : Ï„ a) : Ï€ (x = x)
constant symbol eq_ind {a} (x y : Ï„ a) : Ï€ (x = y) â†’ Î p, Ï€ (p y) â†’ Ï€ (p x)

// Set builtins for the rewrite tactic
set builtin "T"     â‰” Ï„
set builtin "eq"    â‰” eq
set builtin "refl"  â‰” eq_refl
set builtin "eqind" â‰” eq_ind

/////////////////////////////
// Some examples of inductive types
/////////////////////////////

////////////////// Primary color

inductive RGB : TYPE â‰”
 | red  : RGB
 | green : RGB
 | blue : RGB

assert RGB : TYPE
assert red : RGB
assert green : RGB
assert blue : RGB

assert ind_RGB :
  Î p : RGB â†’ Prop,
  Ï€ (p red) â†’ Ï€ (p green) â†’ Ï€ (p blue) â†’
  Î x, Ï€ (p x)

symbol pRGB : RGB â†’ Prop
symbol pred : Ï€ (pRGB red)
symbol pgreen : Ï€ (pRGB green)
symbol pblue: Ï€ (pRGB blue)
symbol indRGB â‰” ind_RGB pRGB pred pgreen pblue
assert indRGB red â‰¡ pred
assert indRGB green â‰¡ pgreen
assert indRGB blue â‰¡ pblue

////////////////// Type color

inductive Color : TYPE â‰”
 | black : Color
 | white : Color
 | primary : RGB â†’ Color

assert Color : TYPE
assert white : Color
assert black : Color
assert primary : RGB â†’ Color

assert ind_Color :
  Î p : Color â†’ Prop,
  Ï€ (p black) â†’ Ï€ (p white) â†’ (Î x, Ï€ (p (primary x))) â†’
  Î x, Ï€ (p x)

symbol pColor : Color â†’ Prop
symbol pblack : Ï€ (pColor black)
symbol pwhite : Ï€ (pColor white)
symbol pprimary: Î x, Ï€ (pColor (primary x))
symbol indColor â‰” ind_Color pColor pblack pwhite pprimary
assert indColor black â‰¡ pblack
assert indColor white â‰¡ pwhite
symbol rgb : RGB
assert indColor (primary rgb) â‰¡ pprimary rgb

////////////////// Boolean type

//FIXME:
//set declared "ğ”¹"
//inductive ğ”¹ : TYPE â‰”
// | true  : ğ”¹
// | false : ğ”¹
// identifier ind_ğ”¹ not recognized

inductive B : TYPE â‰”
 | true  : B
 | false : B

assert B: TYPE
assert true  : B
assert false : B

assert ind_B :
  Î p : B â†’ Prop,
  Ï€ (p true) â†’ Ï€ (p false) â†’
  Î b, Ï€ (p b)

symbol pBool : B â†’ Prop
symbol pitrue  : Ï€ (pBool true)
symbol pifalse : Ï€ (pBool false)
symbol indBool â‰” ind_B pBool pitrue pifalse
assert indBool true  â‰¡ pitrue
assert indBool false â‰¡ pifalse

constant symbol bool : Set
rule B â†ª Ï„ bool

////////////////// False (not predicate one)

inductive False : TYPE â‰”

assert False : TYPE
assert ind_False : Î (p:False â†’ Prop) (f : False), Ï€ (p f)

///////////////// Natural number

inductive N : TYPE â‰”
 | z    : N
 | succ : N â†’ N

assert N : TYPE
assert z : N
assert succ : N â†’ N

assert ind_N :
  Î p:N â†’ Prop, Ï€(p z) â†’ (Î x, Ï€ (p x) â†’ Ï€ (p (succ x))) â†’ Î x, Ï€ (p x)

symbol pN : N â†’ Prop
symbol pz : Ï€ (pN z)
symbol psucc : Î x, Ï€ (pN x) â†’ Ï€ (pN (succ x))
symbol indN â‰” ind_N pN pz psucc
assert indN z â‰¡ pz
symbol n : N
assert indN (succ n) â‰¡ psucc n (indN n)

constant symbol nat : Set
rule N â†ª Ï„ nat

// About natural numbers
set builtin "0"  â‰” z
set builtin "+1" â‰” succ

symbol plus : N â†’ N â†’ N
set infix left 6 "+" â‰” plus
rule       0 + $y â†ª $y
with succ $x + $y â†ª succ ($x + $y)

symbol mult : N â†’ N â†’ N
set infix left 7 "Ã—" â‰” mult
rule       0 Ã— _  â†ª 0
with succ $x Ã— $y â†ª $y + $x Ã— $y

symbol le : N â†’ N â†’ Prop
set infix left 6 "â‰¤" â‰” le
//inductive â‰¤ : Î (n:Ï„ nat), N â†’ Prop â‰”
//  | le_n : Î n, Ï€ (n â‰¤ n)
//  | le_S : Î n m:Ï„ nat, Ï€ (n â‰¤ m) â†’ Ï€ (n â‰¤ (succ m))

/////////////////// Arithmetic and boolean expressions

inductive Expr : TYPE â‰”
 | Lit : N â†’ Expr
 | Add : Expr â†’ Expr â†’ Expr
 | If  : BExpr â†’ Expr â†’ Expr â†’ Expr
with BExpr : TYPE â‰”
 | BLit : B â†’ BExpr
 | And  : BExpr â†’ BExpr â†’ BExpr
 | Not  : BExpr â†’ BExpr
 | Equal  : Expr â†’ Expr â†’ BExpr

assert Expr : TYPE
assert Lit : N â†’ Expr
assert Add : Expr â†’ Expr â†’ Expr
assert If  : BExpr â†’ Expr â†’ Expr â†’ Expr
assert BExpr : TYPE
assert BLit : B â†’ BExpr
assert And  : BExpr â†’ BExpr â†’ BExpr
assert Not  : BExpr â†’ BExpr
assert Equal  : Expr â†’ Expr â†’ BExpr

assert ind_Expr :
  Î p0: Expr â†’ Prop, Î p1: BExpr â†’ Prop,
    (Î x: N, Ï€ (p0 (Lit x))) â†’
    (Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p0 (Add x x0))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Î x1: Expr, Ï€ (p0 x1) â†’ Ï€ (p0 (If x x0 x1))) â†’ 
    (Î x: B, Ï€ (p1 (BLit x))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Î x0: BExpr, Ï€ (p1 x0) â†’ Ï€ (p1 (And x x0))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Ï€ (p1 (Not x))) â†’
    (Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p1 (Equal x x0))) â†’
  Î x: Expr, Ï€ (p0 x)

assert ind_BExpr :
  Î p0: Expr â†’ Prop, Î p1: BExpr â†’ Prop,
    (Î x: N, Ï€ (p0 (Lit x))) â†’
    (Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p0 (Add x x0))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Î x1: Expr, Ï€ (p0 x1) â†’ Ï€ (p0 (If x x0 x1))) â†’
    (Î x: B, Ï€ (p1 (BLit x))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Î x0: BExpr, Ï€ (p1 x0) â†’ Ï€ (p1 (And x x0))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Ï€ (p1 (Not x))) â†’
    (Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p1 (Equal x x0))) â†’
  Î x: BExpr, Ï€ (p1 x)

symbol p0 : Expr â†’ Prop
symbol p1 : BExpr â†’ Prop
symbol pLit : Î x: N, Ï€ (p0 (Lit x))
symbol pAdd : Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p0 (Add x x0))
symbol pIf : Î x: BExpr, Ï€ (p1 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Î x1: Expr, Ï€ (p0 x1) â†’ Ï€ (p0 (If x x0 x1))
symbol pBLit : Î x: B, Ï€ (p1 (BLit x))
symbol pAnd : Î x: BExpr, Ï€ (p1 x) â†’ Î x0: BExpr, Ï€ (p1 x0) â†’ Ï€ (p1 (And x x0))
symbol pNot : Î x: BExpr, Ï€ (p1 x) â†’ Ï€ (p1 (Not x))
symbol pEqual : Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p1 (Equal x x0))
symbol indE â‰” ind_Expr p0 p1 pLit pAdd pIf pBLit pAnd pNot pEqual
symbol indBE â‰” ind_BExpr p0 p1 pLit pAdd pIf pBLit pAnd pNot pEqual
symbol x : B
symbol e1 : Expr
symbol e2 : Expr
symbol be1 : BExpr
symbol be2 : BExpr
assert indE (Lit n) â‰¡ pLit n
assert indE (Add e1 e2) â‰¡ pAdd e1 (indE e1) e2 (indE e2)
assert indE (If be1 e1 e2) â‰¡ pIf be1 (indBE be1) e1 (indE e1) e2 (indE e2)
assert indBE (BLit x) â‰¡ pBLit x
assert indBE (And be1 be2) â‰¡ pAnd be1 (indBE be1) be2 (indBE be2)
assert indBE (Not be1) â‰¡ pNot be1 (indBE be1)
assert indBE (Equal e1 e2) â‰¡ pEqual e1 (indE e1) e2 (indE e2)

/////////////////// Arithmetic and boolean expressions, and commands

inductive AExp : TYPE â‰”
 | aLit : N â†’ AExp
 | aAdd : AExp â†’ AExp â†’ AExp
 | aIf  : BExp â†’ AExp â†’ AExp â†’ AExp
with BExp : TYPE â‰”
 | bLit : B â†’ BExp
 | bEq : AExp â†’ AExp â†’ BExp
with CExp : TYPE â‰”
 | cSkip : CExp
 | cAss  : Set â†’ AExp â†’ CExp // FIXME: What is Set here ?
 | cSeq  : CExp â†’ CExp â†’ CExp
 | cIf   : BExp â†’ CExp â†’ CExp â†’ CExp

assert AExp : TYPE
assert aLit : N â†’ AExp
assert aAdd : AExp â†’ AExp â†’ AExp
assert aIf  : BExp â†’ AExp â†’ AExp â†’ AExp
assert BExp : TYPE
assert bLit : B â†’ BExp
assert bEq : AExp â†’ AExp â†’ BExp
assert CExp : TYPE
assert cSkip : CExp
assert cAss  : Set â†’ AExp â†’ CExp
assert cSeq  : CExp â†’ CExp â†’ CExp
assert cIf   : BExp â†’ CExp â†’ CExp â†’ CExp

assert ind_AExp :
  Î pA: AExp â†’ Prop, Î pB: BExp â†’ Prop, Î pC: CExp â†’ Prop,
   (Î x: N, Ï€ (pA (aLit x))) â†’
   (Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pA (aAdd x x0))) â†’
   (Î x: BExp, Ï€ (pB x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Î x1: AExp, Ï€ (pA x1) â†’ Ï€ (pA (aIf x x0 x1))) â†’
   (Î x: B, Ï€ (pB (bLit x))) â†’
   (Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pB (bEq x x0))) â†’
   Ï€ (pC cSkip) â†’
   (Î x: Set, Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pC (cAss x x0))) â†’
   (Î x: CExp, Ï€ (pC x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Ï€ (pC (cSeq x x0))) â†’
   (Î x: BExp, Ï€ (pB x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Î x1: CExp, Ï€ (pC x1) â†’ Ï€ (pC (cIf x x0 x1))) â†’
  Î x: AExp, Ï€ (pA x)

assert ind_BExp :
  Î pA: AExp â†’ Prop, Î pB: BExp â†’ Prop, Î pC: CExp â†’ Prop,
   (Î x: N, Ï€ (pA (aLit x))) â†’
   (Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pA (aAdd x x0))) â†’
   (Î x: BExp, Ï€ (pB x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Î x1: AExp, Ï€ (pA x1) â†’ Ï€ (pA (aIf x x0 x1))) â†’
   (Î x: B, Ï€ (pB (bLit x))) â†’
   (Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pB (bEq x x0))) â†’
   Ï€ (pC cSkip) â†’
   (Î x: Set, Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pC (cAss x x0))) â†’
   (Î x: CExp, Ï€ (pC x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Ï€ (pC (cSeq x x0))) â†’
   (Î x: BExp, Ï€ (pB x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Î x1: CExp, Ï€ (pC x1) â†’ Ï€ (pC (cIf x x0 x1))) â†’
  Î x: BExp, Ï€ (pB x)

assert ind_CExp :
  Î pA: AExp â†’ Prop, Î pB: BExp â†’ Prop, Î pC: CExp â†’ Prop,
   (Î x: N, Ï€ (pA (aLit x))) â†’
   (Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pA (aAdd x x0))) â†’
   (Î x: BExp, Ï€ (pB x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Î x1: AExp, Ï€ (pA x1) â†’ Ï€ (pA (aIf x x0 x1))) â†’
   (Î x: B, Ï€ (pB (bLit x))) â†’
   (Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pB (bEq x x0))) â†’
   Ï€ (pC cSkip) â†’
   (Î x: Set, Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pC (cAss x x0))) â†’
   (Î x: CExp, Ï€ (pC x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Ï€ (pC (cSeq x x0))) â†’
   (Î x: BExp, Ï€ (pB x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Î x1: CExp, Ï€ (pC x1) â†’ Ï€ (pC (cIf x x0 x1))) â†’
  Î x: CExp, Ï€ (pC x)

symbol pA : AExp â†’ Prop
symbol pB : BExp â†’ Prop
symbol pC : CExp â†’ Prop
symbol paLit : Î x: N, Ï€ (pA (aLit x))
symbol paAdd : Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pA (aAdd x x0))
symbol paIf : Î x: BExp, Ï€ (pB x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Î x1: AExp, Ï€ (pA x1) â†’ Ï€ (pA (aIf x x0 x1))
symbol pbLit : Î x: B, Ï€ (pB (bLit x))
symbol pbEq :Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pB (bEq x x0))
symbol pcSkip : Ï€ (pC cSkip)
symbol pcAss : Î x: Set, Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pC (cAss x x0))
symbol pcSeq : Î x: CExp, Ï€ (pC x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Ï€ (pC (cSeq x x0))
symbol pcIf : Î x: BExp, Ï€ (pB x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Î x1: CExp, Ï€ (pC x1) â†’ Ï€ (pC (cIf x x0 x1))
symbol indA â‰” ind_AExp pA pB pC paLit paAdd paIf pbLit pbEq pcSkip pcAss pcSeq pcIf
symbol indB â‰” ind_BExp pA pB pC paLit paAdd paIf pbLit pbEq pcSkip pcAss pcSeq pcIf
symbol indC â‰” ind_CExp pA pB pC paLit paAdd paIf pbLit pbEq pcSkip pcAss pcSeq pcIf
symbol a1 : AExp
symbol a2 : AExp
symbol b : BExp
symbol c1 : CExp
symbol c2 : CExp
symbol s : Set
assert indA (aLit n) â‰¡ paLit n
assert indA (aAdd a1 a2) â‰¡ paAdd a1 (indA a1) a2 (indA a2)
assert indA (aIf b a1 a2) â‰¡ paIf b (indB b) a1 (indA a1) a2 (indA a2)
assert indB (bLit x) â‰¡ pbLit x
assert indB (bEq a1 a2) â‰¡ pbEq a1 (indA a1) a2 (indA a2)
assert indC cSkip â‰¡ pcSkip
assert indC (cAss s a1) â‰¡ pcAss s a1 (indA a1)
assert indC (cSeq c1 c2) â‰¡ pcSeq c1 (indC c1) c2 (indC c2)
assert indC (cIf b c1 c2) â‰¡ pcIf b (indB b) c1 (indC c1) c2 (indC c2)

////////////////////// Even and odd

inductive even : N â†’ TYPE â‰”
  | even_O : even 0
  | even_S : Î n, odd n â†’ even (succ n)
with odd : N â†’ TYPE â‰”
  | odd_S : Î n, even n â†’ odd (succ n)

assert even : N â†’ TYPE
assert even_O : even 0
assert even_S : Î n, odd n â†’ even (succ n)
assert odd : N â†’ TYPE
assert odd_S : Î n, even n â†’ odd (succ n)

assert ind_even :
  Î p0: Î x: N, even x â†’ Prop, Î p1: Î x: N, odd x â†’ Prop,
    Ï€ (p0 0 even_O) â†’
   (Î n: Ï„ nat, Î x: odd n, Ï€ (p1 n x) â†’ Ï€ (p0 (succ n) (even_S n x))) â†’
   (Î n: Ï„ nat, Î x: even n, Ï€ (p0 n x) â†’ Ï€ (p1 (succ n) (odd_S n x))) â†’
  Î x: N, Î x0: even x, Ï€ (p0 x x0)

assert ind_odd :
  Î p0: Î x: N, even x â†’ Prop, Î p1: Î x: N, odd x â†’ Prop,
    Ï€ (p0 0 even_O) â†’
    (Î n: Ï„ nat, Î x: odd n, Ï€ (p1 n x) â†’ Ï€ (p0 (succ n) (even_S n x))) â†’
    (Î n: Ï„ nat, Î x: even n, Ï€ (p0 n x) â†’ Ï€ (p1 (succ n) (odd_S n x))) â†’
  Î x: N, Î x0: odd x, Ï€ (p1 x x0)

symbol podd : Î x: N, odd x â†’ Prop
symbol peven : Î x: N, even x â†’ Prop
symbol peven_O : Ï€ (peven z even_O)
symbol peven_S : Î n: Ï„ nat, Î x: odd n, Ï€ (podd n x) â†’ Ï€ (peven (succ n) (even_S n x))
symbol podd_S : Î n: Ï„ nat, Î x: even n, Ï€ (peven n x) â†’ Ï€ (podd (succ n) (odd_S n x))
symbol indodd â‰” ind_odd peven podd peven_O peven_S podd_S
symbol indeven â‰” ind_even peven podd peven_O peven_S podd_S
symbol evenn : even n
symbol oddn : odd n
assert indodd _ (odd_S n evenn) â‰¡ podd_S n evenn (indeven _ evenn)
assert indeven _ even_O â‰¡ peven_O
assert indeven _ (even_S n oddn) â‰¡ peven_S n oddn (indodd _ oddn)

////////////////////// List of natural numbers

inductive List : TYPE â‰”
 | nil  : List
 | cons : N â†’ List â†’ List

assert List : TYPE
assert nil  : List
assert cons : N â†’ List â†’ List

assert ind_List :
  Î (p:List â†’ Prop), Ï€(p nil) â†’ (Î x l,Ï€(p l) â†’ Ï€(p(cons x l))) â†’ Î l,Ï€(p l)

symbol pL : List â†’ Prop
symbol pnil : Ï€ (pL nil)
symbol pcons : Î x l, Ï€ (pL l) â†’ Ï€ (pL (cons x l))
symbol indL â‰” ind_List pL pnil pcons
symbol l : List
assert indL nil â‰¡ pnil
assert indL (cons n l) â‰¡ pcons n l (indL l)

constant symbol list : Set
rule List â†ª Ï„ list

///////////////// Couple of natural numbers

inductive nat_prod : TYPE â‰”
 | prod : N â†’ N â†’ nat_prod

assert nat_prod : TYPE
assert prod : N â†’ N â†’ nat_prod

assert ind_nat_prod :
Î p : nat_prod â†’ Prop,
(Î x0 x1, Ï€ (p (prod x0 x1))) â†’
Î x, Ï€ (p x)

symbol pNP : nat_prod â†’ Prop
symbol pprod : Î x0 x1, Ï€ (pNP (prod x0 x1))
symbol indNP â‰” ind_nat_prod pNP pprod
symbol n1 : N
symbol n2 : N
assert indNP (prod n1 n2) â‰¡ pprod n1 n2

///////////////// Binary tree

inductive Tree : TYPE â‰”
  | leaf : Tree
  | consTree : Tree â†’ N â†’ Tree â†’ Tree

assert Tree : TYPE
assert leaf : Tree
assert consTree : Tree â†’ N â†’ Tree â†’ Tree

assert ind_Tree : Î p,
Ï€ (p leaf) â†’
(Î t1, Ï€ (p t1) â†’ Î x t2, Ï€ (p t2) â†’ Ï€ (p (consTree t1 x t2))) â†’
Î t, Ï€ (p t)

symbol pT : Tree â†’ Prop
symbol pleaf : Ï€ (pT leaf)
symbol pconsTree : Î t1, Ï€ (pT t1) â†’ Î x t2, Ï€ (pT t2) â†’ Ï€ (pT (consTree t1 x t2))
symbol t1 : Tree
symbol t2 : Tree
symbol indT â‰” ind_Tree pT pleaf pconsTree
assert indT leaf â‰¡ pleaf
assert indT (consTree t1 n t2) â‰¡ pconsTree t1 (indT t1) n t2 (indT t2)

///////////////////// Polymorphic list

inductive L (a:Set) : TYPE â‰”
 | nilL  : L a
 | consL : Ï„ a â†’ L a â†’ L a

assert L : Set â†’ TYPE
assert nilL  : Î a, L a
assert consL : Î a, Ï„ a â†’ L a â†’ L a

assert ind_L :
  Î p, (Î a, Ï€(p a (nilL a))) â†’ (Î a x l, Ï€(p a l) â†’ Ï€(p a (consL a x l))) â†’ Î a l, Ï€(p a l)

symbol pList : Î a, L a â†’ Prop
symbol pnilL : Î a, Ï€ (pList a (nilL a))
symbol pconsL : Î a x l, Ï€ (pList a l) â†’ Ï€ (pList a (consL a x l))
symbol indList â‰” ind_L pList pnilL pconsL
symbol a : Set
symbol xa : Ï„ a
symbol la : L a
assert indList a (nilL a) â‰¡ pnilL a
assert indList a (consL a xa la) â‰¡ pconsL a xa la (indList a la)

////////////////// Type sum - test names between {|...|} too

inductive {|sum|} : Set â†’ Set â†’ TYPE â‰”
 | {|inl_sum|} : Î a b, Ï„ a â†’ {|sum|} a b
 | inr : Î a b, Ï„ b â†’ {|sum|} a b

assert {|sum|} : Set â†’ Set â†’ TYPE
assert {|inl_sum|} : Î a b, Ï„ a â†’ {|sum|} a b
assert inr : Î a b, Ï„ b â†’ {|sum|} a b

assert {|ind_sum|} : Î p,
(Î a b xa, Ï€ (p a b ({|inl_sum|} a b xa))) â†’
(Î a b xb, Ï€ (p a b (inr a b xb))) â†’
Î a b s, Ï€ (p a b s)

symbol pS : Î (a:Set) (b:Set), {|sum|} a b â†’ Prop
symbol pinl : Î a b xa, Ï€ (pS a b ({|inl_sum|} a b xa))
symbol pinr : Î a b xb, Ï€ (pS a b (inr a b xb))
symbol g : Set
symbol xg : Ï„ g
symbol d : Set
symbol xd : Ï„ d
symbol indsum â‰” {|ind_sum|} pS pinl pinr
assert indsum g d ({|inl_sum|} g d xg) â‰¡ pinl g d xg
assert indsum g d (inr g d xd) â‰¡ pinr g d xd

//////////////////// Vector

inductive V : N â†’ TYPE â‰”
 | nil_vec   : V z
 | cons_vec  : Î n, N â†’ V n â†’ V (succ n)

assert V : N â†’ TYPE
assert nil_vec   : V z
assert cons_vec  : Î n, N â†’ V n â†’ V (succ n)

assert ind_V :
 Î p, Ï€(p z nil_vec) â†’ (Î n x v, Ï€(p n v) â†’ Ï€(p (succ n) (cons_vec n x v))) â†’ Î n v, Ï€(p n v)

symbol pV : Î n, V n â†’ Prop
symbol pVnil : Ï€ (pV z nil_vec)
symbol pVcons : Î n x v, Ï€(pV n v) â†’ Ï€(pV (succ n) (cons_vec n x v))
symbol indV â‰” ind_V pV pVnil pVcons
symbol v : V n
symbol y : N
assert indV z nil_vec â‰¡ pVnil
assert indV (succ n) (cons_vec n y v) â‰¡ pVcons n y v (indV n v)

///////////////// An example of heterogenous dependent family

inductive fin : N â†’ TYPE â‰”
  | new : Î n, fin (succ n)
  | inj : Î n, fin n â†’ fin (succ n)

assert fin : N â†’ TYPE
assert new : Î n, fin (succ n)
assert inj : Î n, fin n â†’ fin (succ n)

assert ind_fin :
  Î p, (Î n, Ï€ (p (succ n) (new n))) â†’ (Î n f, Ï€ (p n f) â†’ Ï€ (p (succ n) (inj n f))) â†’ Î n f, Ï€ (p n f)

symbol pF : Î n, fin n â†’ Prop
symbol pnew : Î n, Ï€ (pF (succ n) (new n))
symbol pinj : Î n f, Ï€ (pF n f) â†’ Ï€ (pF (succ n) (inj n f))
symbol indF â‰” ind_fin pF pnew pinj
symbol f : fin n
assert indF (succ n) (new n) â‰¡ pnew n
assert indF (succ n) (inj n f) â‰¡ pinj n f (indF n f)

///////////////// Bounded List

inductive listb : Ï„ nat â†’ TYPE â‰”
 | nilb  : Î bound, listb bound
 | consb : Î bound x, Ï€ (x â‰¤ bound) â†’ listb bound â†’ listb bound

assert listb : Ï„ nat â†’ TYPE
assert nilb  : Î bound, listb bound
assert consb : Î bound x, Ï€ (x â‰¤ bound) â†’ listb bound â†’ listb bound

assert ind_listb :
Î p, (Î bound, Ï€(p bound (nilb bound))) â†’
(Î bound x (prf:Ï€ (x â‰¤ bound)) l, Ï€(p bound l) â†’ Ï€(p bound (consb bound x prf l))) â†’ 
Î bound l, Ï€(p bound l)

symbol pbound : Î bound, listb bound â†’ Prop
symbol pnilb : Î bound, Ï€(pbound bound (nilb bound))
symbol pconsb : Î bound x (prf:Ï€ (x â‰¤ bound)) l, Ï€(pbound bound l) â†’ Ï€(pbound bound (consb bound x prf l))
symbol indb â‰” ind_listb pbound pnilb pconsb
symbol prf : Ï€ (y â‰¤ n)
symbol lb : listb n
assert indb n (nilb n) â‰¡ pnilb n
assert indb n (consb n y prf lb) â‰¡ pconsb n y prf lb (indb n lb)

///////////////// Type rom

inductive rom : N â†’ TYPE â‰”
 | mty : rom z // leaf node
 | bin : Î e1 e2, rom e1 â†’ rom e2 â†’ rom (e1+e2+1)  // binary nodes
 | unl : Î e k, Ï€ (k â‰¤ 2Ã—e) â†’ rom e â†’ rom (succ e) // unary labeled nodes

assert rom : N â†’ TYPE
assert mty : rom z
assert bin : Î e1 e2, rom e1 â†’ rom e2 â†’ rom (e1+e2+1)
assert unl : Î e k, Ï€ (k â‰¤ 2Ã—e) â†’ rom e â†’ rom (succ e)

assert ind_rom : Î p: Î x: N, rom x â†’ Prop,
  Ï€ (p 0 mty) â†’
  (Î e1: Ï„ nat, Î e2: Ï„ nat, Î x: rom e1, Ï€ (p e1 x) â†’ Î x0: rom e2, Ï€ (p e2 x0) â†’ Ï€ (p ((e1 + e2) + 1) (bin e1 e2 x x0))) â†’ 
  (Î e: Ï„ nat, Î k: Ï„ nat, Î x: Ï€ (k â‰¤ (2 Ã— e)), Î x0: rom e, Ï€ (p e x0) â†’ Ï€ (p (succ e) (unl e k x x0))) â†’ 
Î x: N, Î x0: rom x, Ï€ (p x x0)

symbol pRom : Î x: N, rom x â†’ Prop
symbol pmty : Ï€ (pRom z mty)
symbol pbin : Î e1: Ï„ nat, Î e2: Ï„ nat, Î x: rom e1,
 Ï€ (pRom e1 x) â†’ Î x0: rom e2, Ï€ (pRom e2 x0) â†’ Ï€ (pRom ((e1 + e2) + 1) (bin e1 e2 x x0))
symbol punl : Î e: Ï„ nat, Î k: Ï„ nat, Î x: Ï€ (k â‰¤ (2 Ã— e)), Î x0: rom e, Ï€ (pRom e x0) â†’ Ï€ (pRom (succ e) (unl e k x x0))
symbol indr â‰” ind_rom pRom pmty pbin punl
symbol prf_le : Ï€ (n â‰¤ 2Ã—y)
symbol romy : rom y
symbol romn : rom n
assert indr _ mty â‰¡ pmty
assert indr _ (unl y n prf_le romy) â‰¡ punl y n prf_le romy (indr _ romy)
assert indr _ (bin y n romy romn) â‰¡ pbin y n romy (indr y romy) romn (indr n romn)

///////////////// Fibonacci suite

inductive fibo : N â†’ N â†’ TYPE â‰”
 | cgen' : Î  (n r1 r2 : N),
    fibo n r1 â†’ fibo (succ n) r2 â†’  fibo (succ (succ n)) (plus r1 r2)
 | cbase1 : fibo z (succ z)
 | cbase2 : fibo (succ z) (succ z)

assert fibo : N â†’ N â†’ TYPE
assert cgen' : Î  (n r1 r2 : N),
    fibo n r1 â†’ fibo (succ n) r2 â†’  fibo (succ (succ n)) (plus r1 r2)
assert cbase1 : fibo z (succ z)
assert cbase2 : fibo (succ z) (succ z)

assert ind_fibo : Î p: Î x: N, Î x0: N, fibo x x0 â†’ Prop,
(Î n r1 r2,
     Î x0: fibo n r1, Ï€ (p n r1 x0) â†’
     Î x1: fibo (succ n) r2, Ï€ (p (succ n) r2 x1) â†’
Ï€ (p (succ (succ n)) (r1 + r2) (cgen' n r1 r2 x0 x1))) â†’
Ï€ (p 0 1 cbase1) â†’
Ï€ (p 1 1 cbase2) â†’
Î x: N, Î x0: N, Î x1: fibo x x0, Ï€ (p x x0 x1)

symbol pFibo : Î x: N, Î x0: N, fibo x x0 â†’ Prop
symbol pcgen' : (Î n r1 r2, Î x0: fibo n r1, Ï€ (pFibo n r1 x0) â†’ Î x1: fibo (succ n) r2,
                  Ï€ (pFibo (succ n) r2 x1) â†’ Ï€ (pFibo (succ (succ n)) (r1 + r2) (cgen' n r1 r2 x0 x1)))
symbol pcbase1 : Ï€ (pFibo 0 1 cbase1)
symbol pcbase2 : Ï€ (pFibo 1 1 cbase2)
symbol indfibo â‰” ind_fibo pFibo pcgen' pcbase1 pcbase2
symbol r1 : N
symbol r2 : N
symbol hypF1 : fibo n r1
symbol hypF2 : fibo (succ n) r2
assert indfibo _ _ (cgen' n r1 r2 hypF1 hypF2)
     â‰¡ pcgen' n r1 r2 hypF1 (indfibo _ _ hypF1) 
                      hypF2 (indfibo _ _ hypF2)
assert indfibo _ _ cbase1 â‰¡ pcbase1
assert indfibo _ _ cbase2 â‰¡ pcbase2

/////////////////// Polymorphic vector

inductive Vec : Set â†’ N â†’ TYPE â‰”
 | Vnil   : Î a, Vec a z
 | Vcons  : Î a n (_:Ï„ a), Vec a n â†’ Vec a (succ n)

assert Vec : Set â†’ N â†’ TYPE
assert Vnil   : Î a, Vec a z
assert Vcons  : Î a n (_:Ï„ a), Vec a n â†’ Vec a (succ n)

assert ind_Vec :
  Î p, (Î a, Ï€(p a z (Vnil a))) â†’ (Î a n x v, Ï€(p a n v) â†’ Ï€(p a (succ n) (Vcons a n x v))) â†’ Î a n v, Ï€(p a n v)

symbol pVec : Î a n, Vec a n â†’ Prop
symbol pVecnil : Î a, Ï€ (pVec a z (Vnil a))
symbol pVeccons : Î a n x v, Ï€(pVec a n v) â†’ Ï€(pVec a (succ n) (Vcons a n x v))
symbol indVec â‰” ind_Vec pVec pVecnil pVeccons
symbol xV_p : Ï„ a
symbol v_p : Vec a n
assert ind_Vec pVec pVecnil _ a z (Vnil a) â‰¡ pVecnil a
assert indVec a (succ n) (Vcons a n xV_p v_p)
     â‰¡ pVeccons a n xV_p v_p (indVec a n v_p)

////////////////// Type Bush (nested inductive type)

symbol bush : Set â†’  Set

inductive Bush : Î (_:Set), TYPE â‰”
 | bnil : Î a, Bush a
 | bcons : Î a, Ï„ a â†’ Bush (bush a) â†’ Bush a

rule Bush $a â†ª Ï„ (bush $a)

assert Bush : Î (_:Set), TYPE
assert bnil : Î a, Bush a
assert bcons : Î a, Ï„ a â†’ Bush (bush a) â†’ Bush a

assert ind_Bush :
  Î p, (Î a, Ï€(p a (bnil a))) â†’ (Î a x l, Ï€(p (bush a) l) â†’ Ï€(p a (bcons a x l))) â†’ Î a l, Ï€(p a l)

symbol pBush : Î a, Bush a â†’ Prop
symbol pbnil : Î a, Ï€ (pBush a (bnil a))
symbol pbcons : Î a x l, Ï€ (pBush (bush a) l) â†’ Ï€ (pBush a (bcons a x l))
symbol indbush â‰” ind_Bush pBush pbnil pbcons
symbol tb : Bush (bush a)
assert indbush a (bnil a) â‰¡ pbnil a
assert indbush a (bcons a xa tb) â‰¡ pbcons a xa tb (indbush (bush a) tb)

/////////////////////////////
// Some begins
/////////////////////////////

opaque symbol plus_0_n : Î n, Ï€ ((0 + n) = n) â‰”
begin
  assume n
  reflexivity
end

opaque symbol plus_n_0 : Î n, Ï€ ((n + 0) = n) â‰”
begin
  assume n
  refine ind_N (Î»z, (z + 0) = z) _ _ _
  // Case n = O
  refine eq_refl 0
  // Case n = S n'
  assume n' Hn'
  simpl
  rewrite Hn'
  reflexivity
end

// About lists
symbol length : List â†’ N
rule length nil â†ª 0
 with length (cons _ $l) â†ª succ (length $l)

symbol app : List â†’ List â†’ List
rule  app      nil     $m â†ª $m
 with app (cons $x $l) $m â†ª cons $x (app $l $m)

opaque symbol length_app :
  Î (l1 l2 : List), Ï€ ((length l1 + length l2) = length (app l1 l2)) â‰”
begin
  assume l1 l2
  apply ind_List
        (Î»z, (length z+length l2) = length (app z l2)) _ _ l1
  reflexivity
  assume x l2 IHl1
  simpl rewrite IHl1 reflexivity
end
