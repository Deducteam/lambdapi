/////////////////////////////
// Configuration
/////////////////////////////

constant symbol Prop : TYPE      // Type of propositions
set declared "Ï€"
injective symbol Ï€ : Prop â†’ TYPE // Interpretation of propositions in TYPE

set builtin "Prop"     â‰” Prop
set builtin "P"     â‰” Ï€

constant symbol Set : TYPE       // Type of set codes
set declared "Ï„"
injective symbol Ï„ : Set â†’ TYPE  // Interpretation of set codes in TYPE

/////////////////////////////
// Equality
/////////////////////////////

constant symbol eq {a} : Ï„ a â†’ Ï„ a â†’ Prop
set infix 8 "=" â‰” eq
constant symbol eq_refl {a} (x : Ï„ a) : Ï€ (x = x)
constant symbol eq_ind {a} (x y : Ï„ a) : Ï€ (x = y) â†’ Î p, Ï€ (p y) â†’ Ï€ (p x)

// Set builtins for the rewrite tactic
set builtin "T"     â‰” Ï„
set builtin "eq"    â‰” eq
set builtin "refl"  â‰” eq_refl
set builtin "eqind" â‰” eq_ind

/////////////////////////////
// Some examples of inductive types
/////////////////////////////

////////////////// Primary color

set debug +g

set declared "â„"
set declared "ğ”¾"
inductive RGB : TYPE â‰”
 | â„  : RGB
 | ğ”¾ : RGB
 | Blue : RGB

assert ind_RGB : // Induction principle
  Î p : RGB â†’ Prop,
  Ï€ (p â„) â†’ Ï€ (p ğ”¾) â†’ Ï€ (p Blue) â†’
  Î x, Ï€ (p x)

symbol pRGB : RGB â†’ Prop // Tests about inductive rules
symbol piR : Ï€ (pRGB â„)
symbol piG : Ï€ (pRGB ğ”¾)
symbol piB: Ï€ (pRGB Blue)
assert ind_RGB pRGB piR _ _  â„ â‰¡ piR
assert ind_RGB pRGB _ piG _ ğ”¾ â‰¡ piG
assert ind_RGB pRGB _ _ piB Blue â‰¡ piB

assert â„    : RGB // Examples
assert ğ”¾   : RGB
assert Blue : RGB

////////////////// Type color

inductive Color : TYPE â‰”
 | black : Color
 | white : Color
 | primary : RGB â†’ Color

assert ind_Color : // Induction principle
  Î p : Color â†’ Prop,
  Ï€ (p black) â†’ Ï€ (p white) â†’ (Î x, Ï€ (p (primary x))) â†’
  Î x, Ï€ (p x)

symbol pC : Color â†’ Prop // Tests about inductive rules
symbol piblack : Ï€ (pC black)
symbol piwhite : Ï€ (pC white)
symbol rgb : RGB
symbol piprimary: Î x, Ï€ (pC (primary x))
assert ind_Color pC piblack piwhite piprimary black â‰¡ piblack
assert ind_Color pC piblack piwhite piprimary white â‰¡ piwhite
assert ind_Color pC piblack piwhite piprimary (primary rgb) â‰¡ piprimary rgb

assert white : Color // Examples
assert black : Color
assert primary â„ : Color
assert primary ğ”¾ : Color
assert primary Blue : Color

////////////////// False (not predicate one)

inductive False : TYPE â‰”

assert ind_False : // Induction principle
 Î (p:False â†’ Prop) (f : False), Ï€ (p f)

////////////////// Boolean type

constant symbol bool : Set
set declared "ğ”¹"
inductive ğ”¹ : TYPE â‰”
 | true  : ğ”¹
 | false : ğ”¹
rule ğ”¹ â†ª Ï„ bool

//assert ind_ğ”¹ : // Induction principle
//  Î p : ğ”¹ â†’ Prop,
//  Ï€ (p true) â†’ Ï€ (p false) â†’
//  Î b, Ï€ (p b)

set declared "pğ”¹"
symbol pBool : ğ”¹ â†’ Prop // Tests about inductive rules
symbol pitrue  : Ï€ (pBool true)
symbol pifalse : Ï€ (pBool false)
// assert ind_ğ”¹ pğ”¹ pitrue pifalse true  â‰¡ pitrue
// assert ind_ğ”¹ pğ”¹ pitrue pifalse false â‰¡ pifalse

assert true  : ğ”¹ // Examples
assert false : ğ”¹

///////////////// Natural number

constant symbol nat : Set
inductive Nat : TYPE â‰”
 | z    : Nat
 | succ : Nat â†’ Nat
rule Nat â†ª Ï„ nat

assert ind_Nat : // Induction principle
  Î p:Nat â†’ Prop, Ï€(p z) â†’ (Î x, Ï€ (p x) â†’ Ï€ (p (succ x))) â†’ Î x, Ï€ (p x)

symbol p : Nat â†’ Prop // Tests about inductive rules
symbol pizero : Ï€ (p z)
symbol x : Nat
symbol pisucc : Î x, Ï€ (p x) â†’ Ï€ (p (succ x))
assert ind_Nat p pizero _ z â‰¡ pizero
assert ind_Nat p pizero pisucc (succ x) â‰¡ pisucc x (ind_Nat p pizero pisucc x)

assert z : Nat // Examples
assert succ z : Nat
assert succ (succ (succ z)) : Nat

// About natural numbers
set builtin "0"  â‰” z
set builtin "+1" â‰” succ

symbol plus : Nat â†’ Nat â†’ Nat
set infix left 6 "+" â‰” plus
rule       0 + $y â†ª $y
with succ $x + $y â†ª succ ($x + $y)

symbol mult : Nat â†’ Nat â†’ Nat
set infix left 7 "Ã—" â‰” mult
rule       0 Ã— _  â†ª 0
 with succ $x Ã— $y â†ª $y + $x Ã— $y

inductive Expr : TYPE â‰”
 | Lit : Nat â†’ Expr
 | Add : Expr â†’ Expr â†’ Expr
 | If  : BExpr â†’ Expr â†’ Expr â†’ Expr
with BExpr : TYPE â‰”
 | BLit : ğ”¹ â†’ BExpr
 | And  : BExpr â†’ BExpr â†’ BExpr
 | Not  : BExpr â†’ BExpr
 | Equal  : Expr â†’ Expr â†’ BExpr

assert ind_Expr : // Induction principle for Expr
  Î p0: Expr â†’ Prop, Î p1: BExpr â†’ Prop,
    (Î x: Nat, Ï€ (p0 (Lit x))) â†’
    (Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p0 (Add x x0))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Î x1: Expr, Ï€ (p0 x1) â†’ Ï€ (p0 (If x x0 x1))) â†’ 
    (Î x: ğ”¹, Ï€ (p1 (BLit x))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Î x0: BExpr, Ï€ (p1 x0) â†’ Ï€ (p1 (And x x0))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Ï€ (p1 (Not x))) â†’
    (Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p1 (Equal x x0))) â†’
  Î x: Expr, Ï€ (p0 x)

assert ind_BExpr : // Induction principle for BExpr
  Î p0: Expr â†’ Prop, Î p1: BExpr â†’ Prop,
    (Î x: Nat, Ï€ (p0 (Lit x))) â†’
    (Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p0 (Add x x0))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Î x1: Expr, Ï€ (p0 x1) â†’ Ï€ (p0 (If x x0 x1))) â†’
    (Î x: ğ”¹, Ï€ (p1 (BLit x))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Î x0: BExpr, Ï€ (p1 x0) â†’ Ï€ (p1 (And x x0))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Ï€ (p1 (Not x))) â†’
    (Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p1 (Equal x x0))) â†’
  Î x: BExpr, Ï€ (p1 x)

symbol p0 : Expr â†’ Prop // Tests about inductive rules
symbol p1 : BExpr â†’ Prop
symbol b : ğ”¹
symbol expr1 : Expr
symbol expr2 : Expr
symbol bexpr1 : BExpr
symbol bexpr2 : BExpr
symbol piLit : Î x: Nat, Ï€ (p0 (Lit x))
symbol piAdd : Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p0 (Add x x0))
symbol piIf : Î x: BExpr, Ï€ (p1 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Î x1: Expr, Ï€ (p0 x1) â†’ Ï€ (p0 (If x x0 x1))
symbol piBLit : Î x: ğ”¹, Ï€ (p1 (BLit x))
symbol piAnd : Î x: BExpr, Ï€ (p1 x) â†’ Î x0: BExpr, Ï€ (p1 x0) â†’ Ï€ (p1 (And x x0))
symbol piNot : Î x: BExpr, Ï€ (p1 x) â†’ Ï€ (p1 (Not x))
symbol piEqual : Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p1 (Equal x x0))

assert ind_Expr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual (Lit x) â‰¡ piLit x
assert ind_Expr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual (Add expr1 expr2) 
  â‰¡ piAdd expr1 (ind_Expr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual expr1) 
          expr2 (ind_Expr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual expr2)
assert ind_Expr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual (If bexpr1 expr1 expr2)
  â‰¡ piIf bexpr1 (ind_BExpr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual bexpr1) 
         expr1 (ind_Expr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual expr1)
         expr2 (ind_Expr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual expr2)
assert ind_BExpr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual (BLit b)
  â‰¡ piBLit b
assert ind_BExpr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual (And bexpr1 bexpr2)
  â‰¡ piAnd bexpr1 (ind_BExpr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual bexpr1) 
          bexpr2 (ind_BExpr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual bexpr2)
assert ind_BExpr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual (Not bexpr1)
  â‰¡ piNot bexpr1 (ind_BExpr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual bexpr1)
assert ind_BExpr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual (Equal expr1 expr2)
  â‰¡ piEqual expr1 (ind_Expr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual expr1) 
            expr2 (ind_Expr p0 p1 piLit piAdd piIf piBLit piAnd piNot piEqual expr2)

inductive even : Nat â†’ TYPE â‰”
  | even_O : even 0
  | even_S : Î n, odd n â†’ even (succ n)
with odd : Nat â†’ TYPE â‰”
  | odd_S : Î n, even n â†’ odd (succ n)

assert ind_even : // Induction principle for even
  Î p1: Î x: Nat, odd x â†’ Prop, Î p0: Î x: Nat, even x â†’ Prop,
    Ï€ (p0 0 even_O) â†’
   (Î n: Ï„ nat, Î x: odd n, Ï€ (p1 n x) â†’ Ï€ (p0 (succ n) (even_S n x))) â†’
   (Î n: Ï„ nat, Î x: even n, Ï€ (p0 n x) â†’ Ï€ (p1 (succ n) (odd_S n x))) â†’
  Î x: Nat, Î x0: even x, Ï€ (p0 x x0)

assert ind_odd : // Induction principle for odd
  Î p1: Î x: Nat, odd x â†’ Prop, Î p0: Î x: Nat, even x â†’ Prop,
    Ï€ (p0 0 even_O) â†’
    (Î n: Ï„ nat, Î x: odd n, Ï€ (p1 n x) â†’ Ï€ (p0 (succ n) (even_S n x))) â†’
    (Î n: Ï„ nat, Î x: even n, Ï€ (p0 n x) â†’ Ï€ (p1 (succ n) (odd_S n x))) â†’
  Î x: Nat, Î x0: odd x, Ï€ (p1 x x0)

symbol p1_ : Î x: Nat, odd x â†’ Prop // Tests about inductive rules
symbol p0_ : Î x: Nat, even x â†’ Prop
symbol evenx : even x
symbol oddx : odd x
symbol pieven_O : Ï€ (p0_ z even_O)
symbol pieven_S : Î n: Ï„ nat, Î x: odd n, Ï€ (p1_ n x) â†’ Ï€ (p0_ (succ n) (even_S n x))
symbol piodd_S : Î n: Ï„ nat, Î x: even n, Ï€ (p0_ n x) â†’ Ï€ (p1_ (succ n) (odd_S n x))

assert ind_odd p1_ p0_ pieven_O pieven_S piodd_S _ (odd_S x evenx)
  â‰¡ piodd_S x evenx (ind_even p1_ p0_ pieven_O pieven_S piodd_S _ evenx)
assert ind_even p1_ p0_ pieven_O pieven_S piodd_S _ even_O â‰¡ pieven_O
assert ind_even p1_ p0_ pieven_O pieven_S piodd_S _ (even_S x oddx)
  â‰¡ pieven_S x oddx (ind_odd p1_ p0_ pieven_O pieven_S piodd_S _ oddx)

// inductive even : Nat â†’ TYPE â‰”
//   | even_O : even 0
//   | even_S : Î n, odd n â†’ even (succ n)
// with odd : Nat â†’ TYPE â‰”
//   | odd_S : Î n, even n â†’ odd (succ n)

////////////////////// List of natural numbers

constant symbol list : Set
inductive List : TYPE â‰”
 | nil  : List
 | cons : Nat â†’ List â†’ List
rule List â†ª Ï„ list

assert ind_List : // Induction principle
  Î (p:List â†’ Prop), Ï€(p nil) â†’ (Î x l,Ï€(p l) â†’ Ï€(p(cons x l))) â†’ Î l,Ï€(p l)

symbol pList : List â†’ Prop // Tests about inductive rules
symbol pinil : Ï€ (pList nil)
symbol l : List
symbol picons : Î x l, Ï€ (pList l) â†’ Ï€ (pList (cons x l))
assert ind_List pList pinil _ nil â‰¡ pinil
assert ind_List pList pinil picons (cons x l)
     â‰¡ picons x l (ind_List pList pinil picons l)

assert nil : List // Examples
assert cons (succ (succ (succ z))) nil : List
assert cons (succ (succ (succ z))) (cons (succ z) nil) : List
assert cons (succ (succ (succ z))) (cons (succ z) (cons z nil)) : List

///////////////// Couple of natural numbers

inductive nat_prod : TYPE â‰”
 | P : Nat â†’ Nat â†’ nat_prod

assert ind_nat_prod : // Induction principle
Î p : nat_prod â†’ Prop,
(Î x0 x1, Ï€ (p (P x0 x1))) â†’
Î x, Ï€ (p x)

symbol pNP : nat_prod â†’ Prop // Tests about inductive rules
symbol piP : Î x0 x1, Ï€ (pNP (P x0 x1))
symbol nat1 : Nat
symbol nat2 : Nat
assert ind_nat_prod pNP piP (P nat1 nat2) â‰¡ piP nat1 nat2

assert P z z : nat_prod // Examples
assert P (succ (succ (succ z))) z : nat_prod
assert P (succ (succ (succ z))) (succ z) : nat_prod
assert P (succ z) (succ (succ (succ z))) : nat_prod

///////////////// Binary tree

inductive Tree : TYPE â‰”
  | Leaf : Tree
  | consTree : Tree â†’ Nat â†’ Tree â†’ Tree

assert ind_Tree : Î p, // Induction principle
Ï€ (p Leaf) â†’
(Î t1, Ï€ (p t1) â†’ Î x t2, Ï€ (p t2) â†’ Ï€ (p (consTree t1 x t2))) â†’
Î t, Ï€ (p t)

symbol pT : Tree â†’ Prop // Tests about inductive rules
symbol pLeaf : Ï€ (pT Leaf)
symbol t1 : Tree
symbol t2 : Tree
symbol pconsTree : Î t1, Ï€ (pT t1) â†’ Î x t2, Ï€ (pT t2) â†’ Ï€ (pT (consTree t1 x t2))
assert ind_Tree pT pLeaf pconsTree Leaf â‰¡ pLeaf
assert ind_Tree pT pLeaf pconsTree (consTree t1 x t2)
     â‰¡ pconsTree t1 (ind_Tree pT pLeaf pconsTree t1)
                 x t2 (ind_Tree pT pLeaf pconsTree t2)

assert Leaf : Tree // Examples
assert consTree (consTree Leaf z Leaf) z (consTree Leaf (succ z) Leaf) : Tree
assert consTree (consTree (consTree Leaf z Leaf) z Leaf) z (consTree Leaf z Leaf) : Tree

///////////////////// Polymorphic list

inductive L : Set â†’ TYPE â‰”
 | nilL  : Î a, L a
 | consL : Î a, Ï„ a â†’ L a â†’ L a

assert ind_L : // Induction principle
  Î p, (Î a, Ï€(p a (nilL a))) â†’ (Î a x l, Ï€(p a l) â†’ Ï€(p a (consL a x l))) â†’ Î a l, Ï€(p a l)

symbol pL : Î a, L a â†’ Prop // Tests about inductive rules
symbol pinilL : Î a, Ï€ (pL a (nilL a))
symbol a : Set
symbol x0 : Ï„ a
symbol l0 : L a
symbol piconsL : Î a x l, Ï€ (pL a l) â†’ Ï€ (pL a (consL a x l))
assert ind_L pL pinilL _ a (nilL a) â‰¡ pinilL a
assert ind_L pL pinilL piconsL a (consL a x0 l0)
     â‰¡ piconsL a x0 l0 (ind_L pL pinilL piconsL a l0)

assert nilL a : L a // Examples
assert consL nat (succ (succ (succ z))) (nilL nat) : L nat
assert consL nat (succ (succ (succ z))) (consL nat (succ z) (nilL nat)) : L nat
assert consL nat (succ (succ (succ z))) (consL nat (succ z) (consL nat z (nilL nat))) : L nat
assert consL bool true (nilL bool) : L bool

//////////////////// Vector

inductive Vec : Nat â†’ TYPE â‰”
 | nil_vec   : Vec z
 | cons_vec  : Î n, Nat â†’ Vec n â†’ Vec (succ n)

assert ind_Vec : // Induction principle
 Î p, Ï€(p z nil_vec) â†’ (Î n x v, Ï€(p n v) â†’ Ï€(p (succ n) (cons_vec n x v))) â†’ Î n v, Ï€(p n v)

symbol pV : Î n, Vec n â†’ Prop // Tests about inductive rules
symbol pinil_vec : Ï€ (pV z nil_vec)
symbol n : Nat
symbol v : Vec n
symbol picons_vec : Î n x v, Ï€(pV n v) â†’ Ï€(pV (succ n) (cons_vec n x v))
assert ind_Vec pV pinil_vec _ z nil_vec â‰¡ pinil_vec
assert ind_Vec pV pinil_vec picons_vec (succ n) (cons_vec n x v)
     â‰¡ picons_vec n x v (ind_Vec pV pinil_vec picons_vec n v)

assert nil_vec : Vec z // Examples
assert cons_vec (succ z) x (cons_vec z x nil_vec) : Vec (succ (succ z))

/////////////////// Polymorphic vector

inductive Vec_param : Set â†’ Nat â†’ TYPE â‰”
 | nil_vec_p   : Î a, Vec_param a z
 | cons_vec_p  : Î a n (_:Ï„ a), Vec_param a n â†’ Vec_param a (succ n)

assert ind_Vec_param : // Induction principle
  Î p, (Î a, Ï€(p a z (nil_vec_p a))) â†’ (Î a n x v, Ï€(p a n v) â†’ Ï€(p a (succ n) (cons_vec_p a n x v))) â†’ Î a n v, Ï€(p a n v)

symbol pV_p : Î a n, Vec_param a n â†’ Prop // Tests about inductive rules
symbol pinil_vec_p : Î a, Ï€ (pV_p a z (nil_vec_p a))
symbol xV_p : Ï„ a
symbol v_p : Vec_param a n
symbol picons_vec_p : Î a n x v, Ï€(pV_p a n v) â†’ Ï€(pV_p a (succ n) (cons_vec_p a n x v))
assert ind_Vec_param pV_p pinil_vec_p _ a z (nil_vec_p a) â‰¡ pinil_vec_p a
assert ind_Vec_param pV_p pinil_vec_p picons_vec_p a (succ n) (cons_vec_p a n xV_p v_p)
     â‰¡ picons_vec_p a n xV_p v_p (ind_Vec_param pV_p pinil_vec_p picons_vec_p a n v_p)

assert nil_vec_p a : Vec_param a z // Examples
assert nil_vec_p nat : Vec_param nat z
assert cons_vec_p nat (succ z) (succ (succ (succ z))) (cons_vec_p nat z z (nil_vec_p nat)) : Vec_param nat (succ (succ z))
assertnot cons_vec_p nat (succ z) (succ (succ (succ z))) (cons_vec_p nat z true (nil_vec_p nat)) : Vec_param nat (succ (succ z))
assert cons_vec_p bool (succ z) false (cons_vec_p bool z true (nil_vec_p bool)) : Vec_param bool (succ (succ z))

////////////////// Type sum

inductive {|sum|} : Set â†’ Set â†’ TYPE â‰”
 | {|inl_sum|} : Î A B, Ï„ A â†’ {|sum|} A B
 | inr : Î A B, Ï„ B â†’ {|sum|} A B

assert {|ind_sum|} : Î p, // Induction principle
(Î A B a, Ï€ (p A B ({|inl_sum|} A B a))) â†’
(Î A B b, Ï€ (p A B (inr A B b))) â†’
Î A B s, Ï€ (p A B s)

symbol pS : Î (A:Set) (B:Set), {|sum|} A B â†’ Prop// Tests about inductive rules
symbol G : Set
symbol g : Ï„ G
symbol D : Set
symbol d : Ï„ D
symbol piinl : Î A B a, Ï€ (pS A B ({|inl_sum|} A B a))
symbol piinr : Î A B b, Ï€ (pS A B (inr A B b))

assert {|ind_sum|} pS piinl piinr G D ({|inl_sum|} G D g)
     â‰¡ piinl G D g
assert {|ind_sum|} pS piinl piinr G D (inr G D d)
     â‰¡ piinr G D d

assert inr nat bool true : {|sum|} nat bool // Examples
assert inr nat bool false : {|sum|} nat bool
assert {|inl_sum|} nat bool z : {|sum|} nat bool
assert {|inl_sum|} nat bool (succ z) : {|sum|} nat bool

////////////////// Type Bush (nested inductive type)

symbol bush : Set â†’  Set
inductive Bush : Î (_:Set), TYPE â‰”
 | BNil : Î a, Bush a
 | BCons : Î a, Ï„ a â†’ Bush (bush a) â†’ Bush a
rule Bush $a â†ª Ï„ (bush $a)

assert ind_Bush : // Induction principle
  Î p, (Î a, Ï€(p a (BNil a))) â†’ (Î a x l, Ï€(p (bush a) l) â†’ Ï€(p a (BCons a x l))) â†’ Î a l, Ï€(p a l)

symbol pB : Î a, Bush a â†’ Prop // Tests about inductive rules
symbol piBNil : Î a, Ï€ (pB a (BNil a))
symbol B : Bush (bush a)
symbol piBCons : Î a x l, Ï€ (pB (bush a) l) â†’ Ï€ (pB a (BCons a x l))
assert ind_Bush pB piBNil _ a (BNil a) â‰¡ piBNil a
assert ind_Bush pB piBNil piBCons a (BCons a x0 B)
     â‰¡ piBCons a x0 B (ind_Bush pB piBNil piBCons (bush a) B)

assert BNil a : Bush a // Examples
assert consL nat (succ (succ (succ z))) (nilL nat) : L nat
assert consL nat (succ (succ (succ z))) (consL nat (succ z) (nilL nat)) : L nat
assert consL nat (succ (succ (succ z))) (consL nat (succ z) (consL nat z (nilL nat))) : L nat
assert consL bool true (nilL bool) : L bool

///////////////// An example of the heterogenous dependent family

inductive fin : Nat â†’ TYPE â‰”
  | new : Î n, fin (succ n)
  | inj : Î n, fin n â†’ fin (succ n)

assert ind_fin : // Induction principle
  Î p, (Î n, Ï€ (p (succ n) (new n))) â†’ (Î n f, Ï€ (p n f) â†’ Ï€ (p (succ n) (inj n f))) â†’ Î n f, Ï€ (p n f)

symbol pF : Î n, fin n â†’ Prop // Tests about inductive rules
symbol pinew : Î n, Ï€ (pF (succ n) (new n))
symbol f : fin n
symbol piinj : Î n f, Ï€ (pF n f) â†’ Ï€ (pF (succ n) (inj n f))
assert ind_fin pF pinew _ (succ n) (new n) â‰¡ pinew n
assert ind_fin pF pinew piinj (succ n) (inj n f)
     â‰¡ piinj n f (ind_fin pF pinew piinj n f)

assert new n : fin (succ n) // Examples
assert inj (succ n) (new n) : fin (succ (succ n))

///////////////// Bounded List

symbol le : Nat â†’ Nat â†’ Prop
set infix left 6 "â‰¤" â‰” le

//inductive â‰¤ : Î (n:Ï„ nat), Nat â†’ Prop â‰”
//  | le_n : Î n, Ï€ (n â‰¤ n)
//  | le_S : Î n m:Ï„ nat, Ï€ (n â‰¤ m) â†’ Ï€ (n â‰¤ (succ m))

inductive listb : Ï„ nat â†’ TYPE â‰”
 | Bnil  : Î bound, listb bound
 | Bcons : Î bound x, Ï€ (x â‰¤ bound) â†’ listb bound â†’ listb bound

assert ind_listb : // Induction principle
Î p, (Î bound, Ï€(p bound (Bnil bound))) â†’
(Î bound x (prf:Ï€ (x â‰¤ bound)) l, Ï€(p bound l) â†’ Ï€(p bound (Bcons bound x prf l))) â†’ 
Î bound l, Ï€(p bound l)

symbol pbound : Î bound, listb bound â†’ Prop // Tests about inductive rules
symbol piBnil : Î bound, Ï€(pbound bound (Bnil bound))
symbol bound : Ï„ nat
symbol prf : Ï€ (x â‰¤ bound)
symbol lb : listb bound
symbol piBcons : Î bound x (prf:Ï€ (x â‰¤ bound)) l, Ï€(pbound bound l) â†’ Ï€(pbound bound (Bcons bound x prf l))
assert ind_listb pbound piBnil _ bound (Bnil bound) â‰¡ piBnil bound
assert ind_listb pbound piBnil piBcons bound (Bcons bound x prf lb)
     â‰¡ piBcons bound x prf lb (ind_listb pbound piBnil piBcons bound lb)

assert Bnil bound : listb bound // Examples
assert Bcons bound x prf (Bnil bound) : listb bound

///////////////// Type rom

inductive rom : Nat â†’ TYPE â‰”
 | mty : rom z // leaf node
 | bin : Î e1 e2, rom e1 â†’ rom e2 â†’ rom (e1+e2+1) // binary nodes
 | unl : Î e k, Ï€ (k â‰¤ 2Ã—e) â†’ rom e â†’ rom (succ e) // unary labeled nodes

assert ind_rom : Î p: Î x: Nat, rom x â†’ Prop, // Induction principle
  Ï€ (p 0 mty) â†’
  (Î e1: Ï„ nat, Î e2: Ï„ nat, Î x: rom e1, Ï€ (p e1 x) â†’ Î x0: rom e2, Ï€ (p e2 x0) â†’ Ï€ (p ((e1 + e2) + 1) (bin e1 e2 x x0))) â†’ 
  (Î e: Ï„ nat, Î k: Ï„ nat, Î x: Ï€ (k â‰¤ (2 Ã— e)), Î x0: rom e, Ï€ (p e x0) â†’ Ï€ (p (succ e) (unl e k x x0))) â†’ 
Î x: Nat, Î x0: rom x, Ï€ (p x x0)

symbol pRom : Î x: Nat, rom x â†’ Prop // Tests about inductive rules
symbol pimty : Ï€ (pRom z mty)
symbol romx : rom x
symbol romn : rom n
symbol pibin : Î e1: Ï„ nat, Î e2: Ï„ nat, Î x: rom e1,
 Ï€ (pRom e1 x) â†’ Î x0: rom e2, Ï€ (pRom e2 x0) â†’ Ï€ (pRom ((e1 + e2) + 1) (bin e1 e2 x x0))
symbol prf_le : Ï€ (n â‰¤ 2Ã—x)
symbol piunl : Î e: Ï„ nat, Î k: Ï„ nat, Î x: Ï€ (k â‰¤ (2 Ã— e)), Î x0: rom e, Ï€ (pRom e x0) â†’ Ï€ (pRom (succ e) (unl e k x x0))
assert ind_rom pRom pimty pibin piunl _ mty â‰¡ pimty
assert ind_rom pRom pimty pibin piunl _ (unl x n prf_le romx)
     â‰¡ piunl x n prf_le romx (ind_rom pRom pimty pibin piunl _ romx)
assert ind_rom pRom pimty pibin piunl _ (bin x n romx romn)
 â‰¡ pibin x n romx (ind_rom pRom pimty pibin piunl x romx) romn (ind_rom pRom pimty pibin piunl n romn)

assert mty : rom z // Examples
assert bin z z mty mty : rom (succ z)
assert bin z (succ z) mty (bin z z mty mty) : rom (succ (succ z))
symbol t : Ï€ (z â‰¤ 2Ã—z)
assert bin (succ z) z (unl z z t mty) mty : rom (succ (succ z))
assert unl z z t mty : rom (succ z)
symbol t12 : Ï€ (z â‰¤ 2Ã—(succ z))
assert unl (succ z) z t12 (bin z z mty mty) : rom (succ (succ z))

//symbol rom : Nat â†’ TYPE
//symbol mty : rom z
//symbol bin : Î e1 e2, rom e1 â†’ rom e2 â†’ rom (e1+e2+1)
//symbol unl : Î e k, Ï€ (k â‰¤ 2Ã—e) â†’ rom e â†’ rom (succ e)

//symbol ind_rom : Î p: Î x: Nat, rom x â†’ Prop,
//  Ï€ (p 0 mty) â†’
//  (Î e1: Ï„ nat, Î e2: Ï„ nat, Î x: rom e1, Ï€ (p e1 x) â†’ Î x0: rom e2, Ï€ (p e2 x0) â†’ Ï€ (p ((e1 + e2) + 1) (bin e1 e2 x x0))) â†’ 
//  (Î e: Ï„ nat, Î k: Ï„ nat, Î x: Ï€ (k â‰¤ (2 Ã— e)), Î x0: rom e, Ï€ (p e x0) â†’ Ï€ (p (succ e) (unl e k x x0))) â†’ 
//Î x: Nat, Î x0: rom x, Ï€ (p x x0)

//rule ind_rom $p $pmty $pbin $punl (($x0 + $x1)+1) (bin $x0 $x1 $x2 $x3)
//   â†ª $pbin $x0 $x1 $x2 (ind_rom $p $pmty $pbin $punl $x0 $x2) $x3 (ind_rom $p $pmty $pbin $punl $x1 $x3)

///////////////// Fibonacci suite

inductive fibo : Nat â†’ Nat â†’ TYPE â‰”
 | cgen' : Î  (n r1 r2 : Nat),
    fibo n r1 â†’ fibo (succ n) r2 â†’  fibo (succ (succ n)) (plus r1 r2)
 | cbase1 : fibo z (succ z)
 | cbase2 : fibo (succ z) (succ z)

assert ind_fibo : Î p: Î x: Nat, Î x0: Nat, fibo x x0 â†’ Prop, // Induction principle
(Î n r1 r2,
     Î x0: fibo n r1, Ï€ (p n r1 x0) â†’
     Î x1: fibo (succ n) r2, Ï€ (p (succ n) r2 x1) â†’
Ï€ (p (succ (succ n)) (r1 + r2) (cgen' n r1 r2 x0 x1))) â†’
Ï€ (p 0 1 cbase1) â†’
Ï€ (p 1 1 cbase2) â†’
Î x: Nat, Î x0: Nat, Î x1: fibo x x0, Ï€ (p x x0 x1)

symbol pFibo : Î x: Nat, Î x0: Nat, fibo x x0 â†’ Prop // Tests about inductive rules
symbol picgen' : (Î n r1 r2, Î x0: fibo n r1, Ï€ (pFibo n r1 x0) â†’ Î x1: fibo (succ n) r2,
                  Ï€ (pFibo (succ n) r2 x1) â†’ Ï€ (pFibo (succ (succ n)) (r1 + r2) (cgen' n r1 r2 x0 x1)))
symbol picbase1 : Ï€ (pFibo 0 1 cbase1)
symbol picbase2 : Ï€ (pFibo 1 1 cbase2)
symbol r1 : Nat
symbol r2 : Nat
symbol hypF1 : fibo n r1
symbol hypF2 : fibo (succ n) r2
assert ind_fibo pFibo picgen' picbase1 picbase2 _ _ (cgen' n r1 r2 hypF1 hypF2)
     â‰¡ picgen' n r1 r2 hypF1 (ind_fibo pFibo picgen' picbase1 picbase2 _ _ hypF1) 
                         hypF2 (ind_fibo pFibo picgen' picbase1 picbase2 _ _ hypF2)
assert ind_fibo pFibo picgen' picbase1 picbase2 _ _ cbase1 â‰¡ picbase1
assert ind_fibo pFibo picgen' picbase1 picbase2 _ _ cbase2 â‰¡ picbase2

assert cbase1 : fibo z (succ z) // Examples
assert cbase1 : fibo z (succ z)
assert cbase2 : fibo (succ z) (succ z)
assert cgen' z (succ z) (succ z) cbase1 cbase2 : fibo (succ (succ z)) (succ (succ z))

/////////////////////////////
// Some proofs
/////////////////////////////

theorem plus_0_n : Î n, Ï€ ((0 + n) = n)
proof
  assume n
  reflexivity
qed

theorem plus_n_0 : Î n, Ï€ ((n + 0) = n)
proof
  assume n
  refine ind_Nat (Î»z, (z + 0) = z) _ _ _
  // Case n = O
  refine eq_refl 0
  // Case = S n'
  assume n' Hn'
  simpl
  rewrite Hn'
  reflexivity
qed

// About lists
symbol length : List â†’ Nat
rule length nil â†ª 0
 with length (cons _ $l) â†ª succ (length $l)

symbol app : List â†’ List â†’ List
rule  app      nil     $m â†ª $m
 with app (cons $x $l) $m â†ª cons $x (app $l $m)

theorem length_app :
  Î (l1 l2 : List), Ï€ ((length l1 + length l2) = length (app l1 l2))
proof
  assume l1 l2
  apply ind_List
        (Î»z, (length z+length l2) = length (app z l2)) _ _ l1
  reflexivity
  assume x l2 IHl1
  simpl rewrite IHl1 reflexivity
qed
