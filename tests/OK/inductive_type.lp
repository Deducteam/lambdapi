/////////////////////////////
// Configuration
/////////////////////////////

constant symbol Prop : TYPE;      // Type of propositions
injective symbol Ï€ : Prop â†’ TYPE; // Interpretation of propositions in TYPE

set builtin "Prop"     â‰” Prop;
set builtin "P"     â‰” Ï€;

constant symbol Set : TYPE;       // Type of set codes
injective symbol Ï„ : Set â†’ TYPE;  // Interpretation of set codes in TYPE

/////////////////////////////
// Equality
/////////////////////////////

constant symbol eq {a} : Ï„ a â†’ Ï„ a â†’ Prop;
set infix 8 "=" â‰” eq;
constant symbol eq_refl {a} (x : Ï„ a) : Ï€ (x = x);
constant symbol eq_ind {a} (x y : Ï„ a) : Ï€ (x = y) â†’ Î  p, Ï€ (p y) â†’ Ï€ (p x);

// Set builtins for the rewrite tactic
set builtin "T"     â‰” Ï„;
set builtin "eq"    â‰” eq;
set builtin "refl"  â‰” eq_refl;
set builtin "eqind" â‰” eq_ind;

/////////////////////////////
// Some examples of inductive types
/////////////////////////////

////////////////// Primary color

inductive RGB : TYPE â‰”
 | â„  : RGB
 | ğ”¾ : RGB
 | Blue : RGB;

assert âŠ¢ ind_RGB : // Induction principle
  Î  p : RGB â†’ Prop,
  Ï€ (p â„) â†’ Ï€ (p ğ”¾) â†’ Ï€ (p Blue) â†’
  Î  x, Ï€ (p x);

symbol pRGB : RGB â†’ Prop; // Tests about inductive rules
symbol piR : Ï€ (pRGB â„);
symbol piG : Ï€ (pRGB ğ”¾);
symbol piB: Ï€ (pRGB Blue);
assert âŠ¢ ind_RGB pRGB piR _ _  â„ â‰¡ piR;
assert âŠ¢ ind_RGB pRGB _ piG _ ğ”¾ â‰¡ piG;
assert âŠ¢ ind_RGB pRGB _ _ piB Blue â‰¡ piB;

assert âŠ¢ â„    : RGB; // Examples
assert âŠ¢ ğ”¾   : RGB;
assert âŠ¢ Blue : RGB;

////////////////// Type color

inductive Color : TYPE â‰”
 | black : Color
 | white : Color
 | primary : RGB â†’ Color;

assert âŠ¢ ind_Color : // Induction principle
  Î  p : Color â†’ Prop,
  Ï€ (p black) â†’ Ï€ (p white) â†’ (Î  x, Ï€ (p (primary x))) â†’
  Î  x, Ï€ (p x);

symbol pC : Color â†’ Prop; // Tests about inductive rules
symbol piblack : Ï€ (pC black);
symbol piwhite : Ï€ (pC white);
symbol rgb : RGB;
symbol piprimary: Î  x, Ï€ (pC (primary x));
assert âŠ¢ ind_Color pC piblack piwhite piprimary black â‰¡ piblack;
assert âŠ¢ ind_Color pC piblack piwhite piprimary white â‰¡ piwhite;
assert âŠ¢ ind_Color pC piblack piwhite piprimary (primary rgb) â‰¡ piprimary rgb;

assert âŠ¢ white : Color; // Examples
assert âŠ¢ black : Color;
assert âŠ¢ primary â„ : Color;
assert âŠ¢ primary ğ”¾ : Color;
assert âŠ¢ primary Blue : Color;

////////////////// Boolean type

constant symbol bool : Set;
inductive ğ”¹ : TYPE â‰”
 | true  : ğ”¹
 | false : ğ”¹;
rule ğ”¹ â†ª Ï„ bool;

//assert ind_ğ”¹ : // Induction principle
//  Î  p : ğ”¹ â†’ Prop,
//  Ï€ (p true) â†’ Ï€ (p false) â†’
//  Î  b, Ï€ (p b)

symbol pBool : ğ”¹ â†’ Prop; // Tests about inductive rules
symbol pitrue  : Ï€ (pBool true);
symbol pifalse : Ï€ (pBool false);
// assert ind_ğ”¹ pğ”¹ pitrue pifalse true  â‰¡ pitrue
// assert ind_ğ”¹ pğ”¹ pitrue pifalse false â‰¡ pifalse

assert âŠ¢ true  : ğ”¹; // Examples
assert âŠ¢ false : ğ”¹;

////////////////// False (not predicate one)

inductive False : TYPE â‰”;

assert âŠ¢ ind_False : // Induction principle
 Î (p:False â†’ Prop) (f : False), Ï€ (p f);

///////////////// Natural number

constant symbol nat : Set;
inductive Nat : TYPE â‰”
 | z    : Nat
 | succ : Nat â†’ Nat;
rule Nat â†ª Ï„ nat;

assert âŠ¢ ind_Nat : // Induction principle
  Î  p:Nat â†’ Prop, Ï€(p z) â†’ (Î  x, Ï€ (p x) â†’ Ï€ (p (succ x))) â†’ Î  x, Ï€ (p x);

symbol p : Nat â†’ Prop; // Tests about inductive rules
symbol pizero : Ï€ (p z);
symbol x : Nat;
symbol pisucc : Î  x, Ï€ (p x) â†’ Ï€ (p (succ x));
assert âŠ¢ ind_Nat p pizero _ z â‰¡ pizero;
assert âŠ¢ ind_Nat p pizero pisucc (succ x) â‰¡ pisucc x (ind_Nat p pizero pisucc x);

assert âŠ¢ z : Nat; // Examples
assert âŠ¢ succ z : Nat;
assert âŠ¢ succ (succ (succ z)) : Nat;

// About natural numbers
set builtin "0"  â‰” z;
set builtin "+1" â‰” succ;

symbol plus : Nat â†’ Nat â†’ Nat;
set infix left 6 "+" â‰” plus;
rule       0 + $y â†ª $y
with succ $x + $y â†ª succ ($x + $y);

symbol mult : Nat â†’ Nat â†’ Nat;
set infix left 7 "Ã—" â‰” mult;
rule       0 Ã— _  â†ª 0
with succ $x Ã— $y â†ª $y + $x Ã— $y;

symbol le : Nat â†’ Nat â†’ Prop;
set infix left 6 "â‰¤" â‰” le;

//inductive â‰¤ : Î (n:Ï„ nat), Nat â†’ Prop â‰”
//  | le_n : Î  n, Ï€ (n â‰¤ n)
//  | le_S : Î  n m:Ï„ nat, Ï€ (n â‰¤ m) â†’ Ï€ (n â‰¤ (succ m))

////////////////////// List of natural numbers

constant symbol list : Set;
inductive List : TYPE â‰”
 | nil  : List
 | cons : Nat â†’ List â†’ List;
rule List â†ª Ï„ list;

assert âŠ¢ ind_List : // Induction principle
  Î (p:List â†’ Prop), Ï€(p nil) â†’ (Î  x l,Ï€(p l) â†’ Ï€(p(cons x l))) â†’ Î  l,Ï€(p l);

symbol pList : List â†’ Prop; // Tests about inductive rules
symbol pinil : Ï€ (pList nil);
symbol l : List;
symbol picons : Î  x l, Ï€ (pList l) â†’ Ï€ (pList (cons x l));
assert âŠ¢ ind_List pList pinil _ nil â‰¡ pinil;
assert âŠ¢ ind_List pList pinil picons (cons x l)
     â‰¡ picons x l (ind_List pList pinil picons l);

assert âŠ¢ nil : List; // Examples
assert âŠ¢ cons (succ (succ (succ z))) nil : List;
assert âŠ¢ cons (succ (succ (succ z))) (cons (succ z) nil) : List;
assert âŠ¢ cons (succ (succ (succ z))) (cons (succ z) (cons z nil)) : List;

///////////////// Couple of natural numbers

inductive nat_prod : TYPE â‰”
 | prod : Nat â†’ Nat â†’ nat_prod;

assert âŠ¢ ind_nat_prod : // Induction principle
Î  p : nat_prod â†’ Prop,
(Î  x0 x1, Ï€ (p (prod x0 x1))) â†’
Î  x, Ï€ (p x);

symbol pNP : nat_prod â†’ Prop; // Tests about inductive rules
symbol piprod : Î  x0 x1, Ï€ (pNP (prod x0 x1));
symbol nat1 : Nat;
symbol nat2 : Nat;
assert âŠ¢ ind_nat_prod pNP piprod (prod nat1 nat2) â‰¡ piprod nat1 nat2;

assert âŠ¢ prod z z : nat_prod; // Examples
assert âŠ¢ prod (succ (succ (succ z))) z : nat_prod;
assert âŠ¢ prod (succ (succ (succ z))) (succ z) : nat_prod;
assert âŠ¢ prod (succ z) (succ (succ (succ z))) : nat_prod;

///////////////// Binary tree

inductive Tree : TYPE â‰”
  | leaf : Tree
  | consTree : Tree â†’ Nat â†’ Tree â†’ Tree;

assert âŠ¢ ind_Tree : Î  p, // Induction principle
Ï€ (p leaf) â†’
(Î  t1, Ï€ (p t1) â†’ Î  x t2, Ï€ (p t2) â†’ Ï€ (p (consTree t1 x t2))) â†’
Î  t, Ï€ (p t);

symbol pT : Tree â†’ Prop; // Tests about inductive rules
symbol pileaf : Ï€ (pT leaf);
symbol t1 : Tree;
symbol t2 : Tree;
symbol piconsTree : Î  t1, Ï€ (pT t1) â†’ Î  x t2, Ï€ (pT t2) â†’ Ï€ (pT (consTree t1 x t2));
assert âŠ¢ ind_Tree pT pileaf piconsTree leaf â‰¡ pileaf;
assert âŠ¢ ind_Tree pT pileaf piconsTree (consTree t1 x t2)
     â‰¡ piconsTree t1 (ind_Tree pT pileaf piconsTree t1)
                x t2 (ind_Tree pT pileaf piconsTree t2);

assert âŠ¢ leaf : Tree; // Examples
assert âŠ¢ consTree (consTree leaf z leaf) z (consTree leaf (succ z) leaf) : Tree;
assert âŠ¢ consTree (consTree (consTree leaf z leaf) z leaf) z (consTree leaf z leaf) : Tree;

///////////////////// Polymorphic list

inductive L : Set â†’ TYPE â‰”
 | nilL  : Î  a, L a
 | consL : Î  a, Ï„ a â†’ L a â†’ L a;

assert âŠ¢ ind_L : // Induction principle
  Î  p, (Î  a, Ï€(p a (nilL a))) â†’ (Î  a x l, Ï€(p a l) â†’ Ï€(p a (consL a x l))) â†’ Î  a l, Ï€(p a l);

symbol pL : Î  a, L a â†’ Prop; // Tests about inductive rules
symbol pinilL : Î  a, Ï€ (pL a (nilL a));
symbol a : Set;
symbol xa : Ï„ a;
symbol la : L a;
symbol piconsL : Î  a x l, Ï€ (pL a l) â†’ Ï€ (pL a (consL a x l));
assert âŠ¢ ind_L pL pinilL _ a (nilL a) â‰¡ pinilL a;
assert âŠ¢ ind_L pL pinilL piconsL a (consL a xa la)
     â‰¡ piconsL a xa la (ind_L pL pinilL piconsL a la);

assert âŠ¢ nilL a : L a; // Examples
assert âŠ¢ consL nat (succ (succ (succ z))) (nilL nat) : L nat;
assert âŠ¢ consL nat (succ (succ (succ z))) (consL nat (succ z) (nilL nat)) : L nat;
assert âŠ¢ consL nat (succ (succ (succ z))) (consL nat (succ z) (consL nat z (nilL nat))) : L nat;
assert âŠ¢ consL bool true (nilL bool) : L bool;

////////////////// Type sum

inductive {|sum|} : Set â†’ Set â†’ TYPE â‰”
 | {|inl_sum|} : Î  A B, Ï„ A â†’ {|sum|} A B
 | inr : Î  A B, Ï„ B â†’ {|sum|} A B;

assert âŠ¢ {|ind_sum|} : Î  p, // Induction principle
(Î  A B a, Ï€ (p A B ({|inl_sum|} A B a))) â†’
(Î  A B b, Ï€ (p A B (inr A B b))) â†’
Î  A B s, Ï€ (p A B s);

symbol pS : Î (A:Set) (B:Set), {|sum|} A B â†’ Prop;// Tests about inductive rules
symbol G : Set;
symbol g : Ï„ G;
symbol D : Set;
symbol d : Ï„ D;
symbol piinl : Î  A B a, Ï€ (pS A B ({|inl_sum|} A B a));
symbol piinr : Î  A B b, Ï€ (pS A B (inr A B b));

assert âŠ¢ {|ind_sum|} pS piinl piinr G D ({|inl_sum|} G D g)
     â‰¡ piinl G D g;
assert âŠ¢ {|ind_sum|} pS piinl piinr G D (inr G D d)
     â‰¡ piinr G D d;

assert âŠ¢ inr nat bool true : {|sum|} nat bool; // Examples
assert âŠ¢ inr nat bool false : {|sum|} nat bool;
assert âŠ¢ {|inl_sum|} nat bool z : {|sum|} nat bool;
assert âŠ¢ {|inl_sum|} nat bool (succ z) : {|sum|} nat bool;

//////////////////// Vector

inductive Vec : Nat â†’ TYPE â‰”
 | nil_vec   : Vec z
 | cons_vec  : Î  n, Nat â†’ Vec n â†’ Vec (succ n);

assert âŠ¢ ind_Vec : // Induction principle
 Î  p, Ï€(p z nil_vec) â†’ (Î  n x v, Ï€(p n v) â†’ Ï€(p (succ n) (cons_vec n x v))) â†’ Î  n v, Ï€(p n v);

symbol pV : Î  n, Vec n â†’ Prop; // Tests about inductive rules
symbol pinil_vec : Ï€ (pV z nil_vec);
symbol n : Nat;
symbol v : Vec n;
symbol picons_vec : Î  n x v, Ï€(pV n v) â†’ Ï€(pV (succ n) (cons_vec n x v));
assert âŠ¢ ind_Vec pV pinil_vec _ z nil_vec â‰¡ pinil_vec;
assert âŠ¢ ind_Vec pV pinil_vec picons_vec (succ n) (cons_vec n x v)
     â‰¡ picons_vec n x v (ind_Vec pV pinil_vec picons_vec n v);

assert âŠ¢ nil_vec : Vec z; // Examples
assert âŠ¢ cons_vec (succ z) x (cons_vec z x nil_vec) : Vec (succ (succ z));

///////////////// An example of the heterogenous dependent family

inductive fin : Nat â†’ TYPE â‰”
  | new : Î  n, fin (succ n)
  | inj : Î  n, fin n â†’ fin (succ n);

assert âŠ¢ ind_fin : // Induction principle
  Î  p, (Î  n, Ï€ (p (succ n) (new n))) â†’ (Î  n f, Ï€ (p n f) â†’ Ï€ (p (succ n) (inj n f))) â†’ Î  n f, Ï€ (p n f);

symbol pF : Î  n, fin n â†’ Prop; // Tests about inductive rules
symbol pinew : Î  n, Ï€ (pF (succ n) (new n));
symbol f : fin n;
symbol piinj : Î  n f, Ï€ (pF n f) â†’ Ï€ (pF (succ n) (inj n f));
assert âŠ¢ ind_fin pF pinew _ (succ n) (new n) â‰¡ pinew n;
assert âŠ¢ ind_fin pF pinew piinj (succ n) (inj n f)
     â‰¡ piinj n f (ind_fin pF pinew piinj n f);

assert âŠ¢ new n : fin (succ n); // Examples
assert âŠ¢ inj (succ n) (new n) : fin (succ (succ n));

///////////////// Bounded List

inductive listb : Ï„ nat â†’ TYPE â‰”
 | nilb  : Î  bound, listb bound
 | consb : Î  bound x, Ï€ (x â‰¤ bound) â†’ listb bound â†’ listb bound;

assert âŠ¢ ind_listb : // Induction principle
Î  p, (Î  bound, Ï€(p bound (nilb bound))) â†’
(Î  bound x (prf:Ï€ (x â‰¤ bound)) l, Ï€(p bound l) â†’ Ï€(p bound (consb bound x prf l))) â†’ 
Î  bound l, Ï€(p bound l);

symbol pbound : Î  bound, listb bound â†’ Prop; // Tests about inductive rules
symbol pinilb : Î  bound, Ï€(pbound bound (nilb bound));
symbol bound : Ï„ nat;
symbol prf : Ï€ (x â‰¤ bound);
symbol lb : listb bound;
symbol piconsb : Î  bound x (prf:Ï€ (x â‰¤ bound)) l, Ï€(pbound bound l) â†’ Ï€(pbound bound (consb bound x prf l));
assert âŠ¢ ind_listb pbound pinilb _ bound (nilb bound) â‰¡ pinilb bound;
assert âŠ¢ ind_listb pbound pinilb piconsb bound (consb bound x prf lb)
     â‰¡ piconsb bound x prf lb (ind_listb pbound pinilb piconsb bound lb);

assert âŠ¢ nilb bound : listb bound; // Examples
assert âŠ¢ consb bound x prf (nilb bound) : listb bound;

///////////////// Type rom

inductive rom : Nat â†’ TYPE â‰”
 | mty : rom z // leaf node
 | bin : Î  e1 e2, rom e1 â†’ rom e2 â†’ rom (e1 + e2 + 1)  // binary nodes
 | unl : Î  e k, Ï€ (k â‰¤ 2 Ã— e) â†’ rom e â†’ rom (succ e); // unary labeled nodes

assert âŠ¢ ind_rom : Î  p: Î  x: Nat, rom x â†’ Prop, // Induction principle
  Ï€ (p 0 mty) â†’
  (Î  e1: Ï„ nat, Î  e2: Ï„ nat, Î  x: rom e1, Ï€ (p e1 x) â†’ Î  x0: rom e2, Ï€ (p e2 x0) â†’ Ï€ (p ((e1 + e2) + 1) (bin e1 e2 x x0))) â†’ 
  (Î  e: Ï„ nat, Î  k: Ï„ nat, Î  x: Ï€ (k â‰¤ (2 Ã— e)), Î  x0: rom e, Ï€ (p e x0) â†’ Ï€ (p (succ e) (unl e k x x0))) â†’ 
Î  x: Nat, Î  x0: rom x, Ï€ (p x x0);

symbol pRom : Î  x: Nat, rom x â†’ Prop; // Tests about inductive rules
symbol pimty : Ï€ (pRom z mty);
symbol romx : rom x;
symbol romn : rom n;
symbol pibin : Î  e1: Ï„ nat, Î  e2: Ï„ nat, Î  x: rom e1,
 Ï€ (pRom e1 x) â†’ Î  x0: rom e2, Ï€ (pRom e2 x0) â†’ Ï€ (pRom ((e1 + e2) + 1) (bin e1 e2 x x0));
symbol prf_le : Ï€ (n â‰¤ 2 Ã— x);
symbol piunl : Î  e: Ï„ nat, Î  k: Ï„ nat, Î  x: Ï€ (k â‰¤ (2 Ã— e)), Î  x0: rom e, Ï€ (pRom e x0) â†’ Ï€ (pRom (succ e) (unl e k x x0));
assert âŠ¢ ind_rom pRom pimty pibin piunl _ mty â‰¡ pimty;
assert âŠ¢ ind_rom pRom pimty pibin piunl _ (unl x n prf_le romx)
     â‰¡ piunl x n prf_le romx (ind_rom pRom pimty pibin piunl _ romx);
assert âŠ¢ ind_rom pRom pimty pibin piunl _ (bin x n romx romn)
 â‰¡ pibin x n romx (ind_rom pRom pimty pibin piunl x romx) romn (ind_rom pRom pimty pibin piunl n romn);

assert âŠ¢ mty : rom z; // Examples
assert âŠ¢ bin z z mty mty : rom (succ z);
assert âŠ¢ bin z (succ z) mty (bin z z mty mty) : rom (succ (succ z));
symbol t : Ï€ (z â‰¤ 2 Ã— z);
assert âŠ¢ bin (succ z) z (unl z z t mty) mty : rom (succ (succ z));
assert âŠ¢ unl z z t mty : rom (succ z);
symbol t12 : Ï€ (z â‰¤ 2Ã—(succ z));
assert âŠ¢ unl (succ z) z t12 (bin z z mty mty) : rom (succ (succ z));

//symbol rom : Nat â†’ TYPE
//symbol mty : rom z
//symbol bin : Î  e1 e2, rom e1 â†’ rom e2 â†’ rom (e1+e2+1)
//symbol unl : Î  e k, Ï€ (k â‰¤ 2Ã—e) â†’ rom e â†’ rom (succ e)

//symbol ind_rom : Î  p: Î x: Nat, rom x â†’ Prop,
//  Ï€ (p 0 mty) â†’
//  (Î  e1: Ï„ nat, Î  e2: Ï„ nat, Î  x: rom e1, Ï€ (p e1 x) â†’ Î  x0: rom e2, Ï€ (p e2 x0) â†’ Ï€ (p ((e1 + e2) + 1) (bin e1 e2 x x0))) â†’ 
//  (Î  e: Ï„ nat, Î  k: Ï„ nat, Î  x: Ï€ (k â‰¤ (2 Ã— e)), Î  x0: rom e, Ï€ (p e x0) â†’ Ï€ (p (succ e) (unl e k x x0))) â†’ 
//Î  x: Nat, Î  x0: rom x, Ï€ (p x x0)

//rule ind_rom $p $pmty $pbin $punl (($x0 + $x1)+1) (bin $x0 $x1 $x2 $x3)
//   â†ª $pbin $x0 $x1 $x2 (ind_rom $p $pmty $pbin $punl $x0 $x2) $x3 (ind_rom $p $pmty $pbin $punl $x1 $x3)

/////////////////// Polymorphic vector

inductive Vec_param : Set â†’ Nat â†’ TYPE â‰”
 | nil_vec_p   : Î  a, Vec_param a z
 | cons_vec_p  : Î  a n (_:Ï„ a), Vec_param a n â†’ Vec_param a (succ n);

assert âŠ¢ ind_Vec_param : // Induction principle
  Î  p, (Î  a, Ï€(p a z (nil_vec_p a))) â†’ (Î  a n x v, Ï€(p a n v) â†’ Ï€(p a (succ n) (cons_vec_p a n x v))) â†’ Î  a n v, Ï€(p a n v);

symbol pV_p : Î  a n, Vec_param a n â†’ Prop; // Tests about inductive rules
symbol pinil_vec_p : Î  a, Ï€ (pV_p a z (nil_vec_p a));
symbol xV_p : Ï„ a;
symbol v_p : Vec_param a n;
symbol picons_vec_p : Î  a n x v, Ï€(pV_p a n v) â†’ Ï€(pV_p a (succ n) (cons_vec_p a n x v));
assert âŠ¢ ind_Vec_param pV_p pinil_vec_p _ a z (nil_vec_p a) â‰¡ pinil_vec_p a;
assert âŠ¢ ind_Vec_param pV_p pinil_vec_p picons_vec_p a (succ n) (cons_vec_p a n xV_p v_p)
     â‰¡ picons_vec_p a n xV_p v_p (ind_Vec_param pV_p pinil_vec_p picons_vec_p a n v_p);

assert âŠ¢ nil_vec_p a : Vec_param a z; // Examples
assert âŠ¢ nil_vec_p nat : Vec_param nat z;
assert âŠ¢ cons_vec_p nat (succ z) (succ (succ (succ z))) (cons_vec_p nat z z (nil_vec_p nat)) : Vec_param nat (succ (succ z));
assertnot âŠ¢ cons_vec_p nat (succ z) (succ (succ (succ z))) (cons_vec_p nat z true (nil_vec_p nat)) : Vec_param nat (succ (succ z));
assert âŠ¢ cons_vec_p bool (succ z) false (cons_vec_p bool z true (nil_vec_p bool)) : Vec_param bool (succ (succ z));

////////////////// Type Bush (nested inductive type)

symbol bush : Set â†’  Set;
inductive Bush : Î (_:Set), TYPE â‰”
 | bnil : Î  a, Bush a
 | bcons : Î  a, Ï„ a â†’ Bush (bush a) â†’ Bush a;
rule Bush $a â†ª Ï„ (bush $a);

assert âŠ¢ ind_Bush : // Induction principle
  Î  p, (Î  a, Ï€(p a (bnil a))) â†’ (Î  a x l, Ï€(p (bush a) l) â†’ Ï€(p a (bcons a x l))) â†’ Î  a l, Ï€(p a l);

symbol pB : Î  a, Bush a â†’ Prop; // Tests about inductive rules
symbol pibnil : Î  a, Ï€ (pB a (bnil a));
symbol B : Bush (bush a);
symbol pibcons : Î  a x l, Ï€ (pB (bush a) l) â†’ Ï€ (pB a (bcons a x l));
assert âŠ¢ ind_Bush pB pibnil _ a (bnil a) â‰¡ pibnil a;
assert âŠ¢ ind_Bush pB pibnil pibcons a (bcons a xa B)
     â‰¡ pibcons a xa B (ind_Bush pB pibnil pibcons (bush a) B);

assert âŠ¢ bnil a : Bush a; // Examples
assert âŠ¢ bcons nat (succ (succ (succ z))) (bnil (bush nat)) : Bush nat;
//assert bcons nat (succ (succ (succ z))) (bcons (bush nat) (Ï„ (bush nat)) (bnil (bush (bush nat)))) : Bush nat;
//assert bcons nat (succ (succ (succ z))) (bcons nat (succ z) (bcons nat z (bnil nat))) : Bush nat;
assert âŠ¢ bcons bool true (bnil (bush bool)) : Bush bool;

/////////////////////////////
// Some â‰” begins
/////////////////////////////

opaque symbol plus_0_n : Î  n, Ï€ ((0 + n) = n)
â‰” begin
  assume n;
  reflexivity;
end

opaque symbol plus_n_0 : Î  n, Ï€ ((n + 0) = n)
â‰” begin
  assume n;
  refine ind_Nat (Î» z, (z + 0) = z) _ _ _;
  // Case n = O
  refine eq_refl 0;
  // Case n = S n'
  assume n' Hn';
  simpl;
  rewrite Hn';
  reflexivity;
end

// About lists
symbol length : List â†’ Nat;
rule length nil â†ª 0
 with length (cons _ $l) â†ª succ (length $l);

symbol app : List â†’ List â†’ List;
rule  app      nil     $m â†ª $m
 with app (cons $x $l) $m â†ª cons $x (app $l $m);

opaque symbol length_app :
  Î (l1 l2 : List), Ï€ ((length l1 + length l2) = length (app l1 l2))
â‰” begin
  assume l1 l2;
  apply ind_List
        (Î» z, (length z + length l2) = length (app z l2)) _ _ l1;
  reflexivity;
  assume x l2 IHl1;
  simpl; rewrite IHl1; reflexivity;
end
