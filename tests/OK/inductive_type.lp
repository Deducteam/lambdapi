/////////////////////////////
// Some examples of inductive types
/////////////////////////////

// Configuration

constant symbol Prop : TYPE      // Type of propositions
set declared "Ï€"
injective symbol Ï€ : Prop â†’ TYPE // Interpretation of propositions in TYPE

set builtin "Prop"     â‰” Prop
set builtin "P"     â‰” Ï€

constant symbol Set : TYPE       // Type of set codes
set declared "Ï„"
injective symbol Ï„ : Set â†’ TYPE  // Interpretation of set codes in TYPE

////////////////// Primary colors

begin inductive RGB : TYPE â‰”
 | red  : RGB
 | green : RGB
 | blue : RGB
end

assert RGB : TYPE
assert red : RGB
assert green : RGB
assert blue : RGB

assert ind_RGB :
  Î p : RGB â†’ Prop,
  Ï€ (p red) â†’ Ï€ (p green) â†’ Ï€ (p blue) â†’
  Î x, Ï€ (p x)

assert p pred pgreen pblue âŠ¢ ind_RGB p pred pgreen pblue red â‰¡ pred
assert p pred pgreen pblue âŠ¢ ind_RGB p pred pgreen pblue green â‰¡ pgreen
assert p pred pgreen pblue âŠ¢ ind_RGB p pred pgreen pblue blue â‰¡ pblue

////////////////// More colors

begin inductive Color : TYPE â‰”
 | black : Color
 | white : Color
 | primary : RGB â†’ Color
end

assert Color : TYPE
assert white : Color
assert black : Color
assert primary : RGB â†’ Color

assert ind_Color :
  Î p : Color â†’ Prop,
  Ï€ (p black) â†’ Ï€ (p white) â†’ (Î x, Ï€ (p (primary x))) â†’
  Î x, Ï€ (p x)

assert pColor pblack pwhite pprimary
âŠ¢ ind_Color pColor pblack pwhite pprimary black â‰¡ pblack
assert pColor pblack pwhite pprimary
âŠ¢ ind_Color pColor pblack pwhite pprimary white â‰¡ pwhite
assert pColor pblack pwhite pprimary rgb
âŠ¢ ind_Color pColor pblack pwhite pprimary (primary rgb) â‰¡ pprimary rgb

////////////////// Boolean type

//FIXME:
//set declared "ğ”¹"
//inductive ğ”¹ : TYPE â‰”
// | true  : ğ”¹
// | false : ğ”¹
// identifier ind_ğ”¹ not recognized

begin inductive B : TYPE â‰”
 | true  : B
 | false : B
end

assert B: TYPE
assert true  : B
assert false : B

assert ind_B :
  Î p : B â†’ Prop,
  Ï€ (p true) â†’ Ï€ (p false) â†’
  Î b, Ï€ (p b)

assert p ptrue pfalse âŠ¢ ind_B p ptrue pfalse true â‰¡ ptrue
assert p ptrue pfalse âŠ¢ ind_B p ptrue pfalse false â‰¡ pfalse

constant symbol bool : Set
rule B â†ª Ï„ bool

////////////////// False (empty type)

begin inductive False : TYPE â‰” end

assert False : TYPE
assert ind_False : Î (p:False â†’ Prop) (f : False), Ï€ (p f)

///////////////// Natural numbers

begin inductive N : TYPE â‰”
 | z    : N
 | succ : N â†’ N
end

assert N : TYPE
assert z : N
assert succ : N â†’ N

assert ind_N :
  Î p:N â†’ Prop, Ï€(p z) â†’ (Î x, Ï€ (p x) â†’ Ï€ (p (succ x))) â†’ Î x, Ï€ (p x)

assert p pz psucc âŠ¢ ind_N p pz psucc z â‰¡ pz
assert p pz psucc n âŠ¢ ind_N p pz psucc (succ n) â‰¡ psucc n (ind_N p pz psucc n)

constant symbol nat : Set
rule N â†ª Ï„ nat

set builtin "0"  â‰” z
set builtin "+1" â‰” succ

symbol plus : N â†’ N â†’ N
set infix left 6 "+" â‰” plus
rule       0 + $y â†ª $y
with succ $x + $y â†ª succ ($x + $y)

symbol mult : N â†’ N â†’ N
set infix left 7 "Ã—" â‰” mult
rule       0 Ã— _  â†ª 0
with succ $x Ã— $y â†ª $y + $x Ã— $y

symbol le : N â†’ N â†’ Prop
set infix left 6 "â‰¤" â‰” le

/////////////////// Arithmetic and boolean expressions

begin inductive Expr : TYPE â‰”
 | Lit : N â†’ Expr
 | Add : Expr â†’ Expr â†’ Expr
 | If  : BExpr â†’ Expr â†’ Expr â†’ Expr
with BExpr : TYPE â‰”
 | BLit : B â†’ BExpr
 | And  : BExpr â†’ BExpr â†’ BExpr
 | Not  : BExpr â†’ BExpr
 | Equal  : Expr â†’ Expr â†’ BExpr
end

assert Expr : TYPE
assert Lit : N â†’ Expr
assert Add : Expr â†’ Expr â†’ Expr
assert If  : BExpr â†’ Expr â†’ Expr â†’ Expr
assert BExpr : TYPE
assert BLit : B â†’ BExpr
assert And  : BExpr â†’ BExpr â†’ BExpr
assert Not  : BExpr â†’ BExpr
assert Equal  : Expr â†’ Expr â†’ BExpr

assert ind_Expr :
  Î p0: Expr â†’ Prop, Î p1: BExpr â†’ Prop,
    (Î x: N, Ï€ (p0 (Lit x))) â†’
    (Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p0 (Add x x0))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Î x1: Expr, Ï€ (p0 x1) â†’ Ï€ (p0 (If x x0 x1))) â†’ 
    (Î x: B, Ï€ (p1 (BLit x))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Î x0: BExpr, Ï€ (p1 x0) â†’ Ï€ (p1 (And x x0))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Ï€ (p1 (Not x))) â†’
    (Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p1 (Equal x x0))) â†’
  Î x: Expr, Ï€ (p0 x)

assert ind_BExpr :
  Î p0: Expr â†’ Prop, Î p1: BExpr â†’ Prop,
    (Î x: N, Ï€ (p0 (Lit x))) â†’
    (Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p0 (Add x x0))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Î x1: Expr, Ï€ (p0 x1) â†’ Ï€ (p0 (If x x0 x1))) â†’
    (Î x: B, Ï€ (p1 (BLit x))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Î x0: BExpr, Ï€ (p1 x0) â†’ Ï€ (p1 (And x x0))) â†’
    (Î x: BExpr, Ï€ (p1 x) â†’ Ï€ (p1 (Not x))) â†’
    (Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p1 (Equal x x0))) â†’
  Î x: BExpr, Ï€ (p1 x)

symbol p0 : Expr â†’ Prop
symbol p1 : BExpr â†’ Prop
symbol pLit : Î x: N, Ï€ (p0 (Lit x))
symbol pAdd : Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p0 (Add x x0))
symbol pIf : Î x: BExpr, Ï€ (p1 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Î x1: Expr, Ï€ (p0 x1) â†’ Ï€ (p0 (If x x0 x1))
symbol pBLit : Î x: B, Ï€ (p1 (BLit x))
symbol pAnd : Î x: BExpr, Ï€ (p1 x) â†’ Î x0: BExpr, Ï€ (p1 x0) â†’ Ï€ (p1 (And x x0))
symbol pNot : Î x: BExpr, Ï€ (p1 x) â†’ Ï€ (p1 (Not x))
symbol pEqual : Î x: Expr, Ï€ (p0 x) â†’ Î x0: Expr, Ï€ (p0 x0) â†’ Ï€ (p1 (Equal x x0))
symbol indE â‰” ind_Expr p0 p1 pLit pAdd pIf pBLit pAnd pNot pEqual
symbol indBE â‰” ind_BExpr p0 p1 pLit pAdd pIf pBLit pAnd pNot pEqual
symbol x : B
symbol e1 : Expr
symbol e2 : Expr
symbol be1 : BExpr
symbol be2 : BExpr
symbol n : N
assert indE (Lit n) â‰¡ pLit n
assert indE (Add e1 e2) â‰¡ pAdd e1 (indE e1) e2 (indE e2)
assert indE (If be1 e1 e2) â‰¡ pIf be1 (indBE be1) e1 (indE e1) e2 (indE e2)
assert indBE (BLit x) â‰¡ pBLit x
assert indBE (And be1 be2) â‰¡ pAnd be1 (indBE be1) be2 (indBE be2)
assert indBE (Not be1) â‰¡ pNot be1 (indBE be1)
assert indBE (Equal e1 e2) â‰¡ pEqual e1 (indE e1) e2 (indE e2)

assert p0 p1 pLit pAdd pIf pBLit pAnd pNot pEqual n
âŠ¢ ind_Expr p0 p1 pLit pAdd pIf pBLit pAnd pNot pEqual (Lit n) â‰¡ pLit n

assert p0 p1 pLit pAdd pIf pBLit pAnd pNot pEqual e1 e2
âŠ¢ ind_Expr p0 p1 pLit pAdd pIf pBLit pAnd pNot pEqual (Add e1 e2)
â‰¡ pAdd e1 (ind_Expr p0 p1 pLit pAdd pIf pBLit pAnd pNot pEqual e1)
       e2 (ind_Expr p0 p1 pLit pAdd pIf pBLit pAnd pNot pEqual e2)

/////////////////// Arithmetic and boolean expressions, and commands

begin inductive AExp : TYPE â‰”
 | aLit : N â†’ AExp
 | aAdd : AExp â†’ AExp â†’ AExp
 | aIf  : BExp â†’ AExp â†’ AExp â†’ AExp
with BExp : TYPE â‰”
 | bLit : B â†’ BExp
 | bEq : AExp â†’ AExp â†’ BExp
with CExp : TYPE â‰”
 | cSkip : CExp
 | cAss  : Set â†’ AExp â†’ CExp // FIXME: What Set is doing here ?
 | cSeq  : CExp â†’ CExp â†’ CExp
 | cIf   : BExp â†’ CExp â†’ CExp â†’ CExp
end

assert AExp : TYPE
assert aLit : N â†’ AExp
assert aAdd : AExp â†’ AExp â†’ AExp
assert aIf  : BExp â†’ AExp â†’ AExp â†’ AExp
assert BExp : TYPE
assert bLit : B â†’ BExp
assert bEq : AExp â†’ AExp â†’ BExp
assert CExp : TYPE
assert cSkip : CExp
assert cAss  : Set â†’ AExp â†’ CExp
assert cSeq  : CExp â†’ CExp â†’ CExp
assert cIf   : BExp â†’ CExp â†’ CExp â†’ CExp

assert ind_AExp :
  Î pA: AExp â†’ Prop, Î pB: BExp â†’ Prop, Î pC: CExp â†’ Prop,
   (Î x: N, Ï€ (pA (aLit x))) â†’
   (Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pA (aAdd x x0))) â†’
   (Î x: BExp, Ï€ (pB x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Î x1: AExp, Ï€ (pA x1) â†’ Ï€ (pA (aIf x x0 x1))) â†’
   (Î x: B, Ï€ (pB (bLit x))) â†’
   (Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pB (bEq x x0))) â†’
   Ï€ (pC cSkip) â†’
   (Î x: Set, Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pC (cAss x x0))) â†’
   (Î x: CExp, Ï€ (pC x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Ï€ (pC (cSeq x x0))) â†’
   (Î x: BExp, Ï€ (pB x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Î x1: CExp, Ï€ (pC x1) â†’ Ï€ (pC (cIf x x0 x1))) â†’
  Î x: AExp, Ï€ (pA x)

assert ind_BExp :
  Î pA: AExp â†’ Prop, Î pB: BExp â†’ Prop, Î pC: CExp â†’ Prop,
   (Î x: N, Ï€ (pA (aLit x))) â†’
   (Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pA (aAdd x x0))) â†’
   (Î x: BExp, Ï€ (pB x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Î x1: AExp, Ï€ (pA x1) â†’ Ï€ (pA (aIf x x0 x1))) â†’
   (Î x: B, Ï€ (pB (bLit x))) â†’
   (Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pB (bEq x x0))) â†’
   Ï€ (pC cSkip) â†’
   (Î x: Set, Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pC (cAss x x0))) â†’
   (Î x: CExp, Ï€ (pC x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Ï€ (pC (cSeq x x0))) â†’
   (Î x: BExp, Ï€ (pB x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Î x1: CExp, Ï€ (pC x1) â†’ Ï€ (pC (cIf x x0 x1))) â†’
  Î x: BExp, Ï€ (pB x)

assert ind_CExp :
  Î pA: AExp â†’ Prop, Î pB: BExp â†’ Prop, Î pC: CExp â†’ Prop,
   (Î x: N, Ï€ (pA (aLit x))) â†’
   (Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pA (aAdd x x0))) â†’
   (Î x: BExp, Ï€ (pB x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Î x1: AExp, Ï€ (pA x1) â†’ Ï€ (pA (aIf x x0 x1))) â†’
   (Î x: B, Ï€ (pB (bLit x))) â†’
   (Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pB (bEq x x0))) â†’
   Ï€ (pC cSkip) â†’
   (Î x: Set, Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pC (cAss x x0))) â†’
   (Î x: CExp, Ï€ (pC x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Ï€ (pC (cSeq x x0))) â†’
   (Î x: BExp, Ï€ (pB x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Î x1: CExp, Ï€ (pC x1) â†’ Ï€ (pC (cIf x x0 x1))) â†’
  Î x: CExp, Ï€ (pC x)

symbol pA : AExp â†’ Prop
symbol pB : BExp â†’ Prop
symbol pC : CExp â†’ Prop
symbol paLit : Î x: N, Ï€ (pA (aLit x))
symbol paAdd : Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pA (aAdd x x0))
symbol paIf : Î x: BExp, Ï€ (pB x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Î x1: AExp, Ï€ (pA x1) â†’ Ï€ (pA (aIf x x0 x1))
symbol pbLit : Î x: B, Ï€ (pB (bLit x))
symbol pbEq :Î x: AExp, Ï€ (pA x) â†’ Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pB (bEq x x0))
symbol pcSkip : Ï€ (pC cSkip)
symbol pcAss : Î x: Set, Î x0: AExp, Ï€ (pA x0) â†’ Ï€ (pC (cAss x x0))
symbol pcSeq : Î x: CExp, Ï€ (pC x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Ï€ (pC (cSeq x x0))
symbol pcIf : Î x: BExp, Ï€ (pB x) â†’ Î x0: CExp, Ï€ (pC x0) â†’ Î x1: CExp, Ï€ (pC x1) â†’ Ï€ (pC (cIf x x0 x1))
symbol indA â‰” ind_AExp pA pB pC paLit paAdd paIf pbLit pbEq pcSkip pcAss pcSeq pcIf
symbol indB â‰” ind_BExp pA pB pC paLit paAdd paIf pbLit pbEq pcSkip pcAss pcSeq pcIf
symbol indC â‰” ind_CExp pA pB pC paLit paAdd paIf pbLit pbEq pcSkip pcAss pcSeq pcIf
symbol a1 : AExp
symbol a2 : AExp
symbol b : BExp
symbol c1 : CExp
symbol c2 : CExp
symbol s : Set
assert indA (aLit n) â‰¡ paLit n
assert indA (aAdd a1 a2) â‰¡ paAdd a1 (indA a1) a2 (indA a2)
assert indA (aIf b a1 a2) â‰¡ paIf b (indB b) a1 (indA a1) a2 (indA a2)
assert indB (bLit x) â‰¡ pbLit x
assert indB (bEq a1 a2) â‰¡ pbEq a1 (indA a1) a2 (indA a2)
assert indC cSkip â‰¡ pcSkip
assert indC (cAss s a1) â‰¡ pcAss s a1 (indA a1)
assert indC (cSeq c1 c2) â‰¡ pcSeq c1 (indC c1) c2 (indC c2)
assert indC (cIf b c1 c2) â‰¡ pcIf b (indB b) c1 (indC c1) c2 (indC c2)

////////////////////// Even and odd

begin inductive even : N â†’ TYPE â‰”
  | even_O : even 0
  | even_S : Î n, odd n â†’ even (succ n)
with odd : N â†’ TYPE â‰”
  | odd_S : Î n, even n â†’ odd (succ n)
end

assert even : N â†’ TYPE
assert even_O : even 0
assert even_S : Î n, odd n â†’ even (succ n)
assert odd : N â†’ TYPE
assert odd_S : Î n, even n â†’ odd (succ n)

assert ind_even :
  Î p0: Î x: N, even x â†’ Prop, Î p1: Î x: N, odd x â†’ Prop,
    Ï€ (p0 0 even_O) â†’
   (Î n: Ï„ nat, Î x: odd n, Ï€ (p1 n x) â†’ Ï€ (p0 (succ n) (even_S n x))) â†’
   (Î n: Ï„ nat, Î x: even n, Ï€ (p0 n x) â†’ Ï€ (p1 (succ n) (odd_S n x))) â†’
  Î x: N, Î x0: even x, Ï€ (p0 x x0)

assert ind_odd :
  Î p0: Î x: N, even x â†’ Prop, Î p1: Î x: N, odd x â†’ Prop,
    Ï€ (p0 0 even_O) â†’
    (Î n: Ï„ nat, Î x: odd n, Ï€ (p1 n x) â†’ Ï€ (p0 (succ n) (even_S n x))) â†’
    (Î n: Ï„ nat, Î x: even n, Ï€ (p0 n x) â†’ Ï€ (p1 (succ n) (odd_S n x))) â†’
  Î x: N, Î x0: odd x, Ï€ (p1 x x0)

assert peven podd peven_O peven_S podd_S n evenn
âŠ¢ ind_odd peven podd peven_O peven_S podd_S _ (odd_S n evenn)
â‰¡ podd_S n evenn (ind_even peven podd peven_O peven_S podd_S _ evenn)

assert peven podd peven_O peven_S podd_S n evenn
âŠ¢ ind_even peven podd peven_O peven_S podd_S _ even_O â‰¡ peven_O

assert peven podd peven_O peven_S podd_S n oddn
âŠ¢ ind_even peven podd peven_O peven_S podd_S _ (even_S n oddn)
â‰¡ peven_S n oddn (ind_odd peven podd peven_O peven_S podd_S _ oddn)

////////////////////// Lists of natural numbers

begin inductive List : TYPE â‰”
 | nil  : List
 | cons : N â†’ List â†’ List
end

assert List : TYPE
assert nil  : List
assert cons : N â†’ List â†’ List

assert ind_List :
  Î (p:List â†’ Prop), Ï€(p nil) â†’ (Î x l,Ï€(p l) â†’ Ï€(p(cons x l))) â†’ Î l,Ï€(p l)

assert p pnil pcons âŠ¢ ind_List p pnil pcons nil â‰¡ pnil
assert p pnil pcons n l
âŠ¢ ind_List p pnil pcons (cons n l) â‰¡ pcons n l (ind_List p pnil pcons l)

constant symbol list : Set
rule List â†ª Ï„ list

///////////////// Pairs of natural numbers

begin inductive nat_prod : TYPE â‰”
 | prod : N â†’ N â†’ nat_prod
end

assert nat_prod : TYPE
assert prod : N â†’ N â†’ nat_prod

assert ind_nat_prod :
Î p : nat_prod â†’ Prop,
(Î x0 x1, Ï€ (p (prod x0 x1))) â†’
Î x, Ï€ (p x)

assert p pprod n1 n2 âŠ¢ ind_nat_prod p pprod (prod n1 n2) â‰¡ pprod n1 n2

///////////////// Binary trees

begin inductive Tree : TYPE â‰”
  | leaf : Tree
  | consTree : Tree â†’ N â†’ Tree â†’ Tree
end

assert Tree : TYPE
assert leaf : Tree
assert consTree : Tree â†’ N â†’ Tree â†’ Tree

assert ind_Tree : Î p,
Ï€ (p leaf) â†’
(Î t1, Ï€ (p t1) â†’ Î x t2, Ï€ (p t2) â†’ Ï€ (p (consTree t1 x t2))) â†’
Î t, Ï€ (p t)

assert p pleaf pconsTree âŠ¢ ind_Tree p pleaf pconsTree leaf â‰¡ pleaf
assert p pleaf pconsTree t1 x t2
âŠ¢ ind_Tree p pleaf pconsTree (consTree t1 n t2)
â‰¡ pconsTree t1 (ind_Tree p pleaf pconsTree t1)
  n t2 (ind_Tree p pleaf pconsTree t2)

///////////////////// Polymorphic list

begin (a:Set) inductive L : TYPE â‰”
 | nilL  : L a
 | consL : Ï„ a â†’ L a â†’ L a
end

assert L : Set â†’ TYPE
assert @nilL : Î  a, L a
assert @consL : Î  a, Ï„ a â†’ L a â†’ L a
assert ind_L : Î  a p,
  Ï€(p nilL) â†’ (Î  x l, Ï€(p l) â†’ Ï€(p (consL x l))) â†’ Î  l, Ï€(p l)

assert a p pnil pcons âŠ¢ ind_L a p pnil pcons nilL â‰¡ pnil
assert a p pnil pcons x l âŠ¢ ind_L a p pnil pcons (consL x l)
â‰¡ pcons x l (ind_L a p pnil pcons l)

////////////////// Polymorphic trees

begin (a:Set)
inductive T:TYPE â‰”
| node:Ï„ a â†’ F a â†’ T a
with F:TYPE â‰”
| nilF:F a
| consF:T a â†’ F a â†’ F a
end

assert T:Setâ†’TYPE
assert F:Setâ†’TYPE
assert @node:Î  a, Ï„ a â†’ F a â†’ T a
assert @nilF:Î  a, F a
assert @consF:Î  a, T a â†’ F a â†’ F a
assert ind_F: Î  a, Î  p:T aâ†’Prop, Î  q:F aâ†’Prop,
  (Î  x, Î  l, Ï€(q l) â†’ Ï€(p (node x l))) â†’
  Ï€(q nilF) â†’
  (Î  t, Ï€(p t) â†’ Î  l, Ï€(q l) â†’ Ï€(q (consF t l))) â†’
  Î  l, Ï€(q l)
assert ind_T: Î  a, Î  p:T aâ†’Prop, Î  q:F aâ†’Prop,
  (Î  x, Î  l, Ï€(q l) â†’ Ï€(p (node x l))) â†’
  Ï€(q nilF) â†’
  (Î  t, Ï€(p t) â†’ Î  l, Ï€(q l) â†’ Ï€(q (consF t l))) â†’
  Î  t, Ï€(p t)
assert a p q pnode pnil pcons x l âŠ¢
  ind_T a p q pnode pnil pcons (node x l)
  â‰¡ pnode x l (ind_F a p q pnode pnil pcons l)
assert a p q pnode pnil pcons âŠ¢
  ind_F a p q pnode pnil pcons nilF
  â‰¡ pnil
assert a p q pnode pnil pcons t l âŠ¢
  ind_F a p q pnode pnil pcons (consF t l)
  â‰¡ pcons t (ind_T a p q pnode pnil pcons t) l (ind_F a p q pnode pnil pcons l)

////////////////// Type sum - test names between {|...|} too

begin inductive {|sum|} : Set â†’ Set â†’ TYPE â‰”
 | {|inl_sum|} : Î a b, Ï„ a â†’ {|sum|} a b
 | inr : Î a b, Ï„ b â†’ {|sum|} a b
end

assert {|sum|} : Set â†’ Set â†’ TYPE
assert {|inl_sum|} : Î a b, Ï„ a â†’ {|sum|} a b
assert inr : Î a b, Ï„ b â†’ {|sum|} a b

assert {|ind_sum|} : Î p,
(Î a b xa, Ï€ (p a b ({|inl_sum|} a b xa))) â†’
(Î a b xb, Ï€ (p a b (inr a b xb))) â†’
Î a b s, Ï€ (p a b s)

assert pS pinl pinr g d xg
âŠ¢ {|ind_sum|} pS pinl pinr g d ({|inl_sum|} g d xg) â‰¡ pinl g d xg
assert pS pinl pinr g d xd
âŠ¢ {|ind_sum|} pS pinl pinr g d (inr g d xd) â‰¡ pinr g d xd

//////////////////// Vectors of natural numbers

begin inductive V : N â†’ TYPE â‰”
 | nil_vec   : V z
 | cons_vec  : Î n, N â†’ V n â†’ V (succ n)
end

assert V : N â†’ TYPE
assert nil_vec   : V z
assert cons_vec  : Î n, N â†’ V n â†’ V (succ n)

assert ind_V :
 Î p, Ï€(p z nil_vec) â†’ (Î n x v, Ï€(p n v) â†’ Ï€(p (succ n) (cons_vec n x v))) â†’ Î n v, Ï€(p n v)

assert p pnil pcons âŠ¢ ind_V p pnil pcons z nil_vec â‰¡ pnil
assert p pnil pcons n y v
âŠ¢ ind_V p pnil pcons (succ n) (cons_vec n y v)
â‰¡ pcons n y v (ind_V p pnil pcons n v)

/////////////////

begin inductive fin : N â†’ TYPE â‰”
  | new : Î n, fin (succ n)
  | inj : Î n, fin n â†’ fin (succ n)
end

assert fin : N â†’ TYPE
assert new : Î n, fin (succ n)
assert inj : Î n, fin n â†’ fin (succ n)

assert ind_fin :
  Î p, (Î n, Ï€ (p (succ n) (new n))) â†’ (Î n f, Ï€ (p n f) â†’ Ï€ (p (succ n) (inj n f))) â†’ Î n f, Ï€ (p n f)

symbol pF : Î n, fin n â†’ Prop
symbol pnew : Î n, Ï€ (pF (succ n) (new n))
symbol pinj : Î n f, Ï€ (pF n f) â†’ Ï€ (pF (succ n) (inj n f))
symbol indF â‰” ind_fin pF pnew pinj
symbol f : fin n
assert indF (succ n) (new n) â‰¡ pnew n
assert indF (succ n) (inj n f) â‰¡ pinj n f (indF n f)

///////////////// Bounded List

begin inductive listb : Ï„ nat â†’ TYPE â‰”
 | nilb  : Î bound, listb bound
 | consb : Î bound x, Ï€ (x â‰¤ bound) â†’ listb bound â†’ listb bound
end

assert listb : Ï„ nat â†’ TYPE
assert nilb  : Î bound, listb bound
assert consb : Î bound x, Ï€ (x â‰¤ bound) â†’ listb bound â†’ listb bound

assert ind_listb :
Î p, (Î bound, Ï€(p bound (nilb bound))) â†’
(Î bound x (prf:Ï€ (x â‰¤ bound)) l, Ï€(p bound l) â†’ Ï€(p bound (consb bound x prf l))) â†’ 
Î bound l, Ï€(p bound l)

symbol pbound : Î bound, listb bound â†’ Prop
symbol pnilb : Î bound, Ï€(pbound bound (nilb bound))
symbol pconsb : Î bound x (prf:Ï€ (x â‰¤ bound)) l, Ï€(pbound bound l) â†’ Ï€(pbound bound (consb bound x prf l))
symbol indb â‰” ind_listb pbound pnilb pconsb
symbol y : N
symbol prf : Ï€ (y â‰¤ n)
symbol lb : listb n
assert indb n (nilb n) â‰¡ pnilb n
assert indb n (consb n y prf lb) â‰¡ pconsb n y prf lb (indb n lb)

///////////////// Type rom

begin inductive rom : N â†’ TYPE â‰”
 | mty : rom z // leaf node
 | bin : Î e1 e2, rom e1 â†’ rom e2 â†’ rom (e1+e2+1)  // binary nodes
 | unl : Î e k, Ï€ (k â‰¤ 2Ã—e) â†’ rom e â†’ rom (succ e) // unary labeled nodes
end

assert rom : N â†’ TYPE
assert mty : rom z
assert bin : Î e1 e2, rom e1 â†’ rom e2 â†’ rom (e1+e2+1)
assert unl : Î e k, Ï€ (k â‰¤ 2Ã—e) â†’ rom e â†’ rom (succ e)

assert ind_rom : Î p: Î x: N, rom x â†’ Prop,
  Ï€ (p 0 mty) â†’
  (Î e1: Ï„ nat, Î e2: Ï„ nat, Î x: rom e1, Ï€ (p e1 x) â†’ Î x0: rom e2, Ï€ (p e2 x0) â†’ Ï€ (p ((e1 + e2) + 1) (bin e1 e2 x x0))) â†’ 
  (Î e: Ï„ nat, Î k: Ï„ nat, Î x: Ï€ (k â‰¤ (2 Ã— e)), Î x0: rom e, Ï€ (p e x0) â†’ Ï€ (p (succ e) (unl e k x x0))) â†’ 
Î x: N, Î x0: rom x, Ï€ (p x x0)

symbol pRom : Î x: N, rom x â†’ Prop
symbol pmty : Ï€ (pRom z mty)
symbol pbin : Î e1: Ï„ nat, Î e2: Ï„ nat, Î x: rom e1,
 Ï€ (pRom e1 x) â†’ Î x0: rom e2, Ï€ (pRom e2 x0) â†’ Ï€ (pRom ((e1 + e2) + 1) (bin e1 e2 x x0))
symbol punl : Î e: Ï„ nat, Î k: Ï„ nat, Î x: Ï€ (k â‰¤ (2 Ã— e)), Î x0: rom e, Ï€ (pRom e x0) â†’ Ï€ (pRom (succ e) (unl e k x x0))
symbol indr â‰” ind_rom pRom pmty pbin punl
symbol prf_le : Ï€ (n â‰¤ 2Ã—y)
symbol romy : rom y
symbol romn : rom n
assert indr _ mty â‰¡ pmty
assert indr _ (unl y n prf_le romy) â‰¡ punl y n prf_le romy (indr _ romy)
assert indr _ (bin y n romy romn) â‰¡ pbin y n romy (indr y romy) romn (indr n romn)

///////////////// Fibonacci suite

begin inductive fibo : N â†’ N â†’ TYPE â‰”
 | cgen' : Î  (n r1 r2 : N),
    fibo n r1 â†’ fibo (succ n) r2 â†’  fibo (succ (succ n)) (plus r1 r2)
 | cbase1 : fibo z (succ z)
 | cbase2 : fibo (succ z) (succ z)
end

assert fibo : N â†’ N â†’ TYPE
assert cgen' : Î  (n r1 r2 : N),
    fibo n r1 â†’ fibo (succ n) r2 â†’  fibo (succ (succ n)) (plus r1 r2)
assert cbase1 : fibo z (succ z)
assert cbase2 : fibo (succ z) (succ z)

assert ind_fibo : Î p: Î x: N, Î x0: N, fibo x x0 â†’ Prop,
(Î n r1 r2,
     Î x0: fibo n r1, Ï€ (p n r1 x0) â†’
     Î x1: fibo (succ n) r2, Ï€ (p (succ n) r2 x1) â†’
Ï€ (p (succ (succ n)) (r1 + r2) (cgen' n r1 r2 x0 x1))) â†’
Ï€ (p 0 1 cbase1) â†’
Ï€ (p 1 1 cbase2) â†’
Î x: N, Î x0: N, Î x1: fibo x x0, Ï€ (p x x0 x1)

symbol pFibo : Î x: N, Î x0: N, fibo x x0 â†’ Prop
symbol pcgen' : (Î n r1 r2, Î x0: fibo n r1, Ï€ (pFibo n r1 x0) â†’ Î x1: fibo (succ n) r2,
                  Ï€ (pFibo (succ n) r2 x1) â†’ Ï€ (pFibo (succ (succ n)) (r1 + r2) (cgen' n r1 r2 x0 x1)))
symbol pcbase1 : Ï€ (pFibo 0 1 cbase1)
symbol pcbase2 : Ï€ (pFibo 1 1 cbase2)
symbol indfibo â‰” ind_fibo pFibo pcgen' pcbase1 pcbase2
symbol r1 : N
symbol r2 : N
symbol hypF1 : fibo n r1
symbol hypF2 : fibo (succ n) r2
assert indfibo _ _ (cgen' n r1 r2 hypF1 hypF2)
     â‰¡ pcgen' n r1 r2 hypF1 (indfibo _ _ hypF1) 
                      hypF2 (indfibo _ _ hypF2)
assert indfibo _ _ cbase1 â‰¡ pcbase1
assert indfibo _ _ cbase2 â‰¡ pcbase2

/////////////////// Polymorphic vector

begin inductive Vec : Set â†’ N â†’ TYPE â‰”
 | Vnil   : Î a, Vec a z
 | Vcons  : Î a n (_:Ï„ a), Vec a n â†’ Vec a (succ n)
end

assert Vec : Set â†’ N â†’ TYPE
assert Vnil   : Î a, Vec a z
assert Vcons  : Î a n (_:Ï„ a), Vec a n â†’ Vec a (succ n)

assert ind_Vec :
  Î p, (Î a, Ï€(p a z (Vnil a))) â†’ (Î a n x v, Ï€(p a n v) â†’ Ï€(p a (succ n) (Vcons a n x v))) â†’ Î a n v, Ï€(p a n v)

symbol pVec : Î a n, Vec a n â†’ Prop
symbol pVecnil : Î a, Ï€ (pVec a z (Vnil a))
symbol pVeccons : Î a n x v, Ï€(pVec a n v) â†’ Ï€(pVec a (succ n) (Vcons a n x v))
symbol indVec â‰” ind_Vec pVec pVecnil pVeccons
symbol a : Set
symbol xV_p : Ï„ a
symbol v_p : Vec a n
assert ind_Vec pVec pVecnil _ a z (Vnil a) â‰¡ pVecnil a
assert indVec a (succ n) (Vcons a n xV_p v_p)
     â‰¡ pVeccons a n xV_p v_p (indVec a n v_p)

////////////////// Type Bush (nested inductive type)

symbol bush : Set â†’  Set

begin inductive Bush : Î (_:Set), TYPE â‰”
 | bnil : Î a, Bush a
 | bcons : Î a, Ï„ a â†’ Bush (bush a) â†’ Bush a
end

rule Bush $a â†ª Ï„ (bush $a)

assert Bush : Î (_:Set), TYPE
assert bnil : Î a, Bush a
assert bcons : Î a, Ï„ a â†’ Bush (bush a) â†’ Bush a

assert ind_Bush :
  Î p, (Î a, Ï€(p a (bnil a))) â†’ (Î a x l, Ï€(p (bush a) l) â†’ Ï€(p a (bcons a x l))) â†’ Î a l, Ï€(p a l)

symbol pBush : Î a, Bush a â†’ Prop
symbol pbnil : Î a, Ï€ (pBush a (bnil a))
symbol pbcons : Î a x l, Ï€ (pBush (bush a) l) â†’ Ï€ (pBush a (bcons a x l))
symbol indbush â‰” ind_Bush pBush pbnil pbcons
symbol tb : Bush (bush a)
assert indbush a (bnil a) â‰¡ pbnil a
symbol xa : Ï„ a
assert indbush a (bcons a xa tb) â‰¡ pbcons a xa tb (indbush (bush a) tb)

/////////////////////////////
// Equality
/////////////////////////////

constant symbol eq {a} : Ï„ a â†’ Ï„ a â†’ Prop
set infix 8 "=" â‰” eq
constant symbol eq_refl {a} (x : Ï„ a) : Ï€ (x = x)
constant symbol eq_ind {a} (x y : Ï„ a) : Ï€ (x = y) â†’ Î p, Ï€ (p y) â†’ Ï€ (p x)

// Set builtins for the rewrite tactic
set builtin "T"     â‰” Ï„
set builtin "eq"    â‰” eq
set builtin "refl"  â‰” eq_refl
set builtin "eqind" â‰” eq_ind

/////////////////////////////
// Some proofs
/////////////////////////////

opaque symbol plus_0_n : Î n, Ï€ ((0 + n) = n) â‰”
begin
  assume n
  reflexivity
end

opaque symbol plus_n_0 : Î n, Ï€ ((n + 0) = n) â‰”
begin
  assume n
  refine ind_N (Î»z, (z + 0) = z) _ _ _
  // Case n = O
  refine eq_refl 0
  // Case n = S n'
  assume n' Hn'
  simpl
  rewrite Hn'
  reflexivity
end

// About lists
symbol length : List â†’ N
rule length nil â†ª 0
 with length (cons _ $l) â†ª succ (length $l)

symbol app : List â†’ List â†’ List
rule  app      nil     $m â†ª $m
 with app (cons $x $l) $m â†ª cons $x (app $l $m)

opaque symbol length_app :
  Î (l1 l2 : List), Ï€ ((length l1 + length l2) = length (app l1 l2)) â‰”
begin
  assume l1 l2
  apply ind_List
        (Î»z, (length z+length l2) = length (app z l2)) _ _ l1
  reflexivity
  assume x l2 IHl1
  simpl rewrite IHl1 reflexivity
end
