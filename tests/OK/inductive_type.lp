/////////////////////////////
// Configuration
/////////////////////////////

constant symbol Prop : TYPE      // Type of propositions
set declared "Ï€"
injective symbol Ï€ : Prop â†’ TYPE // Interpretation of propositions in TYPE

set builtin "Prop"     â‰” Prop
set builtin "P"     â‰” Ï€

constant symbol Set : TYPE       // Type of set codes
set declared "Ï„"
injective symbol Ï„ : Set â†’ TYPE  // Interpretation of set codes in TYPE

/////////////////////////////
// Equality
/////////////////////////////
constant symbol eq {a} : Ï„ a â†’ Ï„ a â†’ Prop
set infix 8 "=" â‰” eq
constant symbol eq_refl {a} (x : Ï„ a) : Ï€ (x = x)
constant symbol eq_ind {a} (x y : Ï„ a) : Ï€ (x = y) â†’ Î p, Ï€ (p y) â†’ Ï€ (p x)

// Set builtins for the rewrite tactic
set builtin "T"     â‰” Ï„
set builtin "eq"    â‰” eq
set builtin "refl"  â‰” eq_refl
set builtin "eqind" â‰” eq_ind

//////////////////////
// Boolean type
//////////////////////

constant symbol bool : Set       // Type of booleans
set declared "ğ”¹"
definition ğ”¹ â‰” Ï„ bool
constant symbol true  : ğ”¹
constant symbol false : ğ”¹

/////////////////////////////
// Some examples of inductive types
/////////////////////////////
set debug +h

inductive {|sum|} : Î (A:Set) (B:Set), TYPE â‰”
  inl : Î A B, Ï„ A â†’ {|sum|} A B
| inr : Î A B, Ï„ B â†’ {|sum|} A B

type {|ind_sum|}

set declared "â„•"
inductive â„• : TYPE â‰”
 | cons1 : â„•
 | cons2 : â„• â†’ â„•

//set declared "ind_â„•"
//symbol ind_â„• : â„•
type ind_â„•

inductive RGB : TYPE â‰”
 | red   : RGB
 | green : RGB
 | blue  : RGB

type ind_RGB

inductive Color : TYPE â‰”
 | black : Color
 | white : Color
 | primary : Î (p : RGB), Color

type ind_Color

///////////////// Natural number

constant symbol nat : Set
inductive Nat : TYPE â‰”
 | z    : Nat
 | succ : Nat â†’ Nat
rule Nat â†ª Ï„ nat

type ind_Nat // Induction principle
assert ind_Nat :
  Î p:Nat â†’ Prop, Ï€(p z) â†’ (Î x, Ï€ (p x) â†’ Ï€ (p (succ x))) â†’ Î x, Ï€ (p x)

symbol p : Nat â†’ Prop // Tests about inductive rules
symbol pizero : Ï€ (p z)
symbol x : Nat
symbol pisucc : Î x, Ï€ (p x) â†’ Ï€ (p (succ x))
assert ind_Nat p pizero _ z â‰¡ pizero
assert ind_Nat p pizero pisucc (succ x) â‰¡ pisucc x (ind_Nat p pizero pisucc x)

assert z : Nat // Examples
assert succ z : Nat
assert succ (succ (succ z)) : Nat

////////////////////// Lists

constant symbol list : Set
inductive List : TYPE â‰”
 | nil  : List
 | cons : Nat â†’ List â†’ List
rule List â†ª Ï„ list

type ind_List // Induction principle
assert ind_List :
  Î (p:List â†’ Prop), Ï€(p nil) â†’ (Î x l,Ï€(p l) â†’ Ï€(p(cons x l))) â†’ Î l,Ï€(p l)

symbol pList : List â†’ Prop // Tests about inductive rules
symbol pinil : Ï€ (pList nil)
symbol l : List
symbol picons : Î x l, Ï€ (pList l) â†’ Ï€ (pList (cons x l))
assert ind_List pList pinil _ nil â‰¡ pinil
assert ind_List pList pinil picons (cons x l)
     â‰¡ picons x l (ind_List pList pinil picons l)

assert nil : List // Examples
assert cons (succ (succ (succ z))) nil : List
assert cons (succ (succ (succ z))) (cons (succ z) nil) : List
assert cons (succ (succ (succ z))) (cons (succ z) (cons z nil)) : List

///////////////////// Polymorphic list

inductive L : Î a:Set, TYPE â‰”
 | nilL  : Î a, L a
 | consL : Î a, Ï„ a â†’ L a â†’ L a

type ind_L // Induction principle
assert ind_L :
  Î p, (Î a, Ï€(p a (nilL a))) â†’ (Î a x l, Ï€(p a l) â†’ Ï€(p a (consL a x l))) â†’ Î a l, Ï€(p a l)

symbol pL : Î a, L a â†’ Prop // Tests about inductive rules
symbol pinilL : Î a, Ï€ (pL a (nilL a))
symbol a : Set
symbol x0 : Ï„ a
symbol l0 : L a
symbol piconsL : Î a x l, Ï€ (pL a l) â†’ Ï€ (pL a (consL a x l))
assert ind_L pL pinilL _ a (nilL a) â‰¡ pinilL a
assert ind_L pL pinilL piconsL a (consL a x0 l0)
     â‰¡ piconsL a x0 l0 (ind_L pL pinilL piconsL a l0)

assert nilL a : L a // Examples
assert consL nat (succ (succ (succ z))) (nilL nat) : L nat
assert consL nat (succ (succ (succ z))) (consL nat (succ z) (nilL nat)) : L nat
assert consL nat (succ (succ (succ z))) (consL nat (succ z) (consL nat z (nilL nat))) : L nat
assert consL bool true (nilL bool) : L bool

//////////////////// Vector

symbol A : TYPE
inductive Vec : Nat â†’ TYPE â‰”
 | nil_vec   : Vec z
 | cons_vec  : Î n, A â†’ Vec n â†’ Vec (succ n)

type ind_Vec // Induction principle
assert ind_Vec :
 Î p, Ï€(p z nil_vec) â†’ (Î n x v, Ï€(p n v) â†’ Ï€(p (succ n) (cons_vec n x v))) â†’ Î n v, Ï€(p n v)

symbol pV : Î n, Vec n â†’ Prop // Tests about inductive rules
symbol pinil_vec : Ï€ (pV z nil_vec)
symbol n : Nat
symbol xV : A
symbol v : Vec n
symbol picons_vec : Î n x v, Ï€(pV n v) â†’ Ï€(pV (succ n) (cons_vec n x v))
assert ind_Vec pV pinil_vec _ z nil_vec â‰¡ pinil_vec
assert ind_Vec pV pinil_vec picons_vec (succ n) (cons_vec n xV v)
     â‰¡ picons_vec n xV v (ind_Vec pV pinil_vec picons_vec n v)

assert nil_vec : Vec z // Examples
assert cons_vec (succ z) xV (cons_vec z xV nil_vec) : Vec (succ (succ z))

/////////////////// Polymorphic vector

inductive Vec_param : Î (a : Set), Î (n : Nat), TYPE â‰”
 | nil_vec_p   : Î a, Vec_param a z
 | cons_vec_p  : Î a n (_:Ï„ a), Vec_param a n â†’ Vec_param a (succ n)

type ind_Vec_param // Induction principle
assert ind_Vec_param :
  Î p, (Î a, Ï€(p a z (nil_vec_p a))) â†’ (Î a n x v, Ï€(p a n v) â†’ Ï€(p a (succ n) (cons_vec_p a n x v))) â†’ Î a n v, Ï€(p a n v)

symbol pV_p : Î a n, Vec_param a n â†’ Prop // Tests about inductive rules
symbol pinil_vec_p : Î a, Ï€ (pV_p a z (nil_vec_p a))
symbol xV_p : Ï„ a
symbol v_p : Vec_param a n
symbol picons_vec_p : Î a n x v, Ï€(pV_p a n v) â†’ Ï€(pV_p a (succ n) (cons_vec_p a n x v))
assert ind_Vec_param pV_p pinil_vec_p _ a z (nil_vec_p a) â‰¡ pinil_vec_p a
assert ind_Vec_param pV_p pinil_vec_p picons_vec_p a (succ n) (cons_vec_p a n xV_p v_p)
     â‰¡ picons_vec_p a n xV_p v_p (ind_Vec_param pV_p pinil_vec_p picons_vec_p a n v_p)

assert nil_vec_p a : Vec_param a z // Examples
assert nil_vec_p nat : Vec_param nat z
assert cons_vec_p nat (succ z) (succ (succ (succ z))) (cons_vec_p nat z z (nil_vec_p nat)) : Vec_param nat (succ (succ z))
assertnot cons_vec_p nat (succ z) (succ (succ (succ z))) (cons_vec_p nat z true (nil_vec_p nat)) : Vec_param nat (succ (succ z))
assert cons_vec_p bool (succ z) false (cons_vec_p bool z true (nil_vec_p bool)) : Vec_param bool (succ (succ z))

////////////////// Example of mutual inductive type

// inductive Expr : Set â‰”
//    Lit : Ï„ nat   â†’ Expr
//  | Add : Expr  â†’ Expr â†’ Expr
//  | If  : BExpr â†’ Expr â†’ Expr â†’ Expr
// with BExpr : Set :=
//  | BLit  : Ï„ bool  â†’ BExpr
//  | And   : BExpr â†’ BExpr â†’ BExpr
//  | Not   : BExpr â†’ BExpr
//  | Equal : Expr  â†’ Expr â†’ BExpr

////////////////// Type Bush (nested inductive type)

symbol bush : Set â†’  Set
inductive Bush : Î (_:Set), TYPE â‰”
 | BNil : Î a, Bush a
 | BCons : Î a, Ï„ a â†’ Bush (bush a) â†’ Bush a
rule Bush $a â†ª Ï„ (bush $a)

type ind_Bush // Induction principle
assert ind_Bush :
  Î p, (Î a, Ï€(p a (BNil a))) â†’ (Î a x l, Ï€(p (bush a) l) â†’ Ï€(p a (BCons a x l))) â†’ Î a l, Ï€(p a l)

symbol pB : Î a, Bush a â†’ Prop // Tests about inductive rules
symbol piBNil : Î a, Ï€ (pB a (BNil a))
symbol B : Bush (bush a)
symbol piBCons : Î a x l, Ï€ (pB (bush a) l) â†’ Ï€ (pB a (BCons a x l))
assert ind_Bush pB piBNil _ a (BNil a) â‰¡ piBNil a
assert ind_Bush pB piBNil piBCons a (BCons a x0 B)
     â‰¡ piBCons a x0 B (ind_Bush pB piBNil piBCons (bush a) B)

assert BNil a : Bush a // Examples
assert consL nat (succ (succ (succ z))) (nilL nat) : L nat
assert consL nat (succ (succ (succ z))) (consL nat (succ z) (nilL nat)) : L nat
assert consL nat (succ (succ (succ z))) (consL nat (succ z) (consL nat z (nilL nat))) : L nat
assert consL bool true (nilL bool) : L bool

///////////////// An example of the heterogenous dependent family

inductive fin : Nat â†’ TYPE â‰”
  | new : Î n, fin (succ n)
  | inj : Î n, fin n â†’ fin (succ n)

type ind_fin // Induction principle
assert ind_fin : Î p, (Î n, Ï€ (p (succ n) (new n))) â†’ (Î n f, Ï€ (p n f) â†’ Ï€ (p (succ n) (inj n f))) â†’ Î n f, Ï€ (p n f)

symbol pF : Î n, fin n â†’ Prop // Tests about inductive rules
symbol pinew : Î n, Ï€ (pF (succ n) (new n))
symbol f : fin n
symbol piinj : Î n f, Ï€ (pF n f) â†’ Ï€ (pF (succ n) (inj n f))
assert ind_fin pF pinew _ (succ n) (new n) â‰¡ pinew n
assert ind_fin pF pinew piinj (succ n) (inj n f)
     â‰¡ piinj n f (ind_fin pF pinew piinj n f)

assert new n : fin (succ n) // Examples
assert inj (succ n) (new n) : fin (succ (succ n))

///////////////// Bounded List

symbol le : Nat â†’ Nat â†’ Prop
set infix left 6 "â‰¤" â‰” le

//inductive â‰¤ : Î (n:Ï„ nat), Nat â†’ Prop â‰”
//  | le_n : Î n, Ï€ (n â‰¤ n)
//  | le_S : Î n m:Ï„ nat, Ï€ (n â‰¤ m) â†’ Ï€ (n â‰¤ (succ m))

inductive listb : Î (bound : Ï„ nat), TYPE â‰”
   Bnil  : Î bound, listb bound
 | Bcons : Î bound x, Ï€ (x â‰¤ bound) â†’ listb bound â†’ listb bound

type ind_listb // Induction principle
assert ind_listb :
Î p, (Î bound, Ï€(p bound (Bnil bound))) â†’
(Î bound x (prf:Ï€ (x â‰¤ bound)) l, Ï€(p bound l) â†’ Ï€(p bound (Bcons bound x prf l))) â†’ 
Î bound l, Ï€(p bound l)

symbol pbound : Î bound, listb bound â†’ Prop // Tests about inductive rules
symbol piBnil : Î bound, Ï€(pbound bound (Bnil bound))
symbol bound : Ï„ nat
symbol prf : Ï€ (x â‰¤ bound)
symbol lb : listb bound
symbol piBcons : Î bound x (prf:Ï€ (x â‰¤ bound)) l, Ï€(pbound bound l) â†’ Ï€(pbound bound (Bcons bound x prf l))
assert ind_listb pbound piBnil _ bound (Bnil bound) â‰¡ piBnil bound
assert ind_listb pbound piBnil piBcons bound (Bcons bound x prf lb)
     â‰¡ piBcons bound x prf lb (ind_listb pbound piBnil piBcons bound lb)

assert Bnil bound : listb bound // Examples
assert Bcons bound x prf (Bnil bound) : listb bound

///////////////// Predicat even

inductive even : Nat â†’ TYPE â‰”
| O_even      : even z
| plus_2_even : Î n:Ï„ nat, even n â†’ even (succ (succ n))

type ind_even

///////////////// Forest

// TODO ...

/////////////////////////////
// Some proofs
/////////////////////////////

// About natural numbers
set builtin "0"  â‰” z
set builtin "+1" â‰” succ

symbol plus : Nat â†’ Nat â†’ Nat
set infix left 6 "+" â‰” plus
rule       0 + $y â†ª $y
with succ $x + $y â†ª succ ($x + $y)

theorem plus_0_n : Î n, Ï€ ((0 + n) = n)
proof
  assume n
  reflexivity
qed

theorem plus_n_0 : Î n, Ï€ ((n + 0) = n)
proof
  assume n
  refine ind_Nat (Î»z, (z + 0) = z) _ _ _
  // Case n = O
  refine eq_refl 0
  // Case = S n'
  assume n' Hn'
  simpl
  rewrite Hn'
  reflexivity
qed

// About lists
symbol length : List â†’ Nat
rule length nil â†ª 0
 with length (cons _ $l) â†ª succ (length $l)

symbol app : List â†’ List â†’ List
rule  app      nil     $m â†ª $m
 with app (cons $x $l) $m â†ª cons $x (app $l $m)

theorem length_app :
  Î (l1 l2 : List), Ï€ ((length l1 + length l2) = length (app l1 l2))
proof
  assume l1 l2
  apply ind_List
        (Î»z, (length z+length l2) = length (app z l2)) _ _ l1
  reflexivity
  assume x l2 IHl1
  simpl rewrite IHl1 reflexivity
qed
