/////////////////////////////
// Configuration
/////////////////////////////

constant symbol Prop : TYPE      // Type of propositions
set declared "Ï€"
injective symbol Ï€ : Prop â†’ TYPE // Interpretation of propositions in TYPE

set builtin "Prop"     â‰” Prop
set builtin "P"     â‰” Ï€

constant symbol Set : TYPE       // Type of set codes
set declared "Ï„"
injective symbol Ï„ : Set â†’ TYPE  // Interpretation of set codes in TYPE

/////////////////////////////
// Equality
/////////////////////////////
set debug +g

set declared "â„"
set declared "ð”¾"
inductive RGB : TYPE â‰”
 | â„  : RGB
 | ð”¾ : RGB
 | Blue : RGB

constant symbol eq {a} : Ï„ a â†’ Ï„ a â†’ Prop
set infix 8 "=" â‰” eq
constant symbol eq_refl {a} (x : Ï„ a) : Ï€ (x = x)
constant symbol eq_ind {a} (x y : Ï„ a) : Ï€ (x = y) â†’ Î p, Ï€ (p y) â†’ Ï€ (p x)

inductive eq2 : Î a, Ï„ a â†’ Ï„ a â†’ TYPE â‰”
  | eq2_refl : Î a x, eq2 a x x
  //| eq2_ind  : Î a x y, eq2 a x y â†’ Î p, Ï€ (p a y) â†’ Ï€(p a y)

assert ind_eq2 : Î (p:Î (a:Set) x x0, eq2 a x x0 â†’ Prop),
 (Î a x, Ï€ (p a x x (eq2_refl a x))) â†’
Î a x x0 x1, Ï€ (p a x x0 x1)

symbol pEQ : Î (a:Set) x x0, eq2 a x x0 â†’ Prop
symbol pirefl : Î a x, Ï€ (pEQ a x x (eq2_refl a x))
symbol Aeq : Set
symbol value : Ï„ Aeq
assert ind_eq2 pEQ pirefl Aeq value value (eq2_refl Aeq value) â‰¡ pirefl Aeq value

// Set builtins for the rewrite tactic
set builtin "T"     â‰” Ï„
set builtin "eq"    â‰” eq
set builtin "refl"  â‰” eq_refl
set builtin "eqind" â‰” eq_ind

/////////////////////////////
// Some examples of inductive types
/////////////////////////////

set debug +g

////////////////// Primary color

set declared "â„"
set declared "ð”¾"
inductive RGB : TYPE â‰”
 | â„  : RGB
 | ð”¾ : RGB
 | Blue : RGB

assert ind_RGB : // Induction principle
  Î p : RGB â†’ Prop,
  Ï€ (p â„) â†’ Ï€ (p ð”¾) â†’ Ï€ (p Blue) â†’
  Î x, Ï€ (p x)

symbol pRGB : RGB â†’ Prop // Tests about inductive rules
symbol piR : Ï€ (pRGB â„)
symbol piG : Ï€ (pRGB ð”¾)
symbol piB: Ï€ (pRGB Blue)
assert ind_RGB pRGB piR _ _  â„ â‰¡ piR
assert ind_RGB pRGB _ piG _ ð”¾ â‰¡ piG
assert ind_RGB pRGB _ _ piB Blue â‰¡ piB

////////////////// Type color

inductive Color : TYPE â‰”
 | black : Color
 | white : Color
 | primary : Î (p : RGB), Color

assert ind_Color : // Induction principle
  Î p : Color â†’ Prop,
  Ï€ (p black) â†’ Ï€ (p white) â†’ (Î x, Ï€ (p (primary x))) â†’
  Î x, Ï€ (p x)

symbol pC : Color â†’ Prop // Tests about inductive rules
symbol piblack : Ï€ (pC black)
symbol piwhite : Ï€ (pC white)
symbol rgb : RGB
symbol piprimary: Î x, Ï€ (pC (primary x))
assert ind_Color pC piblack piwhite piprimary black â‰¡ piblack
assert ind_Color pC piblack piwhite piprimary white â‰¡ piwhite
assert ind_Color pC piblack piwhite piprimary (primary rgb) â‰¡ piprimary rgb

////////////////// Type sum

inductive {|sum|} : Î (A:Set) (B:Set), TYPE â‰”
  {|inl_sum|} : Î A B, Ï„ A â†’ {|sum|} A B
| inr : Î A B, Ï„ B â†’ {|sum|} A B

assert {|ind_sum|} : Î p,
(Î A B a, Ï€ (p A B ({|inl_sum|} A B a))) â†’
(Î A B b, Ï€ (p A B (inr A B b))) â†’
Î A B s, Ï€ (p A B s)

symbol pS : Î (A:Set) (B:Set), {|sum|} A B â†’ Prop
symbol G : Set
symbol g : Ï„ G
symbol D : Set
symbol d : Ï„ D
symbol piinl : Î A B a, Ï€ (pS A B ({|inl_sum|} A B a))
symbol piinr : Î A B b, Ï€ (pS A B (inr A B b))

assert {|ind_sum|} pS piinl piinr G D ({|inl_sum|} G D g)
     â‰¡ piinl G D g
assert {|ind_sum|} pS piinl piinr G D (inr G D d)
     â‰¡ piinr G D d

////////////////// Boolean type

constant symbol bool : Set
set declared "ð”¹"
inductive ð”¹  : TYPE â‰”
 | true  : ð”¹
 | false : ð”¹
rule ð”¹ â†ª Ï„ bool

//assert ind_ð”¹ : // Induction principle
//  Î p : ð”¹ â†’ Prop,
//  Ï€ (p true) â†’ Ï€ (p false) â†’
//  Î b, Ï€ (p b)

///////////////// Natural number

constant symbol nat : Set
inductive Nat : TYPE â‰”
 | z    : Nat
 | succ : Nat â†’ Nat
rule Nat â†ª Ï„ nat

assert ind_Nat : // Induction principle
  Î p:Nat â†’ Prop, Ï€(p z) â†’ (Î x, Ï€ (p x) â†’ Ï€ (p (succ x))) â†’ Î x, Ï€ (p x)

symbol p : Nat â†’ Prop // Tests about inductive rules
symbol pizero : Ï€ (p z)
symbol x : Nat
symbol pisucc : Î x, Ï€ (p x) â†’ Ï€ (p (succ x))
assert ind_Nat p pizero _ z â‰¡ pizero
assert ind_Nat p pizero pisucc (succ x) â‰¡ pisucc x (ind_Nat p pizero pisucc x)

assert z : Nat // Examples
assert succ z : Nat
assert succ (succ (succ z)) : Nat

////////////////////// List of natural numbers

constant symbol list : Set
inductive List : TYPE â‰”
 | nil  : List
 | cons : Nat â†’ List â†’ List
rule List â†ª Ï„ list

assert ind_List : // Induction principle
  Î (p:List â†’ Prop), Ï€(p nil) â†’ (Î x l,Ï€(p l) â†’ Ï€(p(cons x l))) â†’ Î l,Ï€(p l)

symbol pList : List â†’ Prop // Tests about inductive rules
symbol pinil : Ï€ (pList nil)
symbol l : List
symbol picons : Î x l, Ï€ (pList l) â†’ Ï€ (pList (cons x l))
assert ind_List pList pinil _ nil â‰¡ pinil
assert ind_List pList pinil picons (cons x l)
     â‰¡ picons x l (ind_List pList pinil picons l)

assert nil : List // Examples
assert cons (succ (succ (succ z))) nil : List
assert cons (succ (succ (succ z))) (cons (succ z) nil) : List
assert cons (succ (succ (succ z))) (cons (succ z) (cons z nil)) : List

///////////////// Binary tree

inductive Tree : TYPE â‰”
  | Leaf : Tree
  | consTree : Tree â†’ Nat â†’ Tree â†’ Tree

assert ind_Tree : Î p, // Induction principle
Ï€ (p Leaf) â†’
(Î t1, Ï€ (p t1) â†’ Î x t2, Ï€ (p t2) â†’ Ï€ (p (consTree t1 x t2))) â†’
Î t, Ï€ (p t)

symbol pT : Tree â†’ Prop // Tests about inductive rules
symbol pLeaf : Ï€ (pT Leaf)
symbol t1 : Tree
symbol t2 : Tree
symbol pconsTree : Î t1, Ï€ (pT t1) â†’ Î x t2, Ï€ (pT t2) â†’ Ï€ (pT (consTree t1 x t2))
assert ind_Tree pT pLeaf pconsTree Leaf â‰¡ pLeaf
assert ind_Tree pT pLeaf pconsTree (consTree t1 x t2)
     â‰¡ pconsTree t1 (ind_Tree pT pLeaf pconsTree t1)
                 x t2 (ind_Tree pT pLeaf pconsTree t2)

assert Leaf : Tree // Examples
assert consTree (consTree Leaf z Leaf) z (consTree Leaf (succ z) Leaf) : Tree
assert consTree (consTree (consTree Leaf z Leaf) z Leaf) z (consTree Leaf z Leaf) : Tree

///////////////////// Polymorphic list

inductive L : Î a:Set, TYPE â‰”
 | nilL  : Î a, L a
 | consL : Î a, Ï„ a â†’ L a â†’ L a

assert ind_L : // Induction principle
  Î p, (Î a, Ï€(p a (nilL a))) â†’ (Î a x l, Ï€(p a l) â†’ Ï€(p a (consL a x l))) â†’ Î a l, Ï€(p a l)

symbol pL : Î a, L a â†’ Prop // Tests about inductive rules
symbol pinilL : Î a, Ï€ (pL a (nilL a))
symbol a : Set
symbol x0 : Ï„ a
symbol l0 : L a
symbol piconsL : Î a x l, Ï€ (pL a l) â†’ Ï€ (pL a (consL a x l))
assert ind_L pL pinilL _ a (nilL a) â‰¡ pinilL a
assert ind_L pL pinilL piconsL a (consL a x0 l0)
     â‰¡ piconsL a x0 l0 (ind_L pL pinilL piconsL a l0)

assert nilL a : L a // Examples
assert consL nat (succ (succ (succ z))) (nilL nat) : L nat
assert consL nat (succ (succ (succ z))) (consL nat (succ z) (nilL nat)) : L nat
assert consL nat (succ (succ (succ z))) (consL nat (succ z) (consL nat z (nilL nat))) : L nat
assert consL bool true (nilL bool) : L bool

//////////////////// Vector

inductive Vec : Nat â†’ TYPE â‰”
 | nil_vec   : Vec z
 | cons_vec  : Î n, Nat â†’ Vec n â†’ Vec (succ n)

assert ind_Vec : // Induction principle
 Î p, Ï€(p z nil_vec) â†’ (Î n x v, Ï€(p n v) â†’ Ï€(p (succ n) (cons_vec n x v))) â†’ Î n v, Ï€(p n v)

symbol pV : Î n, Vec n â†’ Prop // Tests about inductive rules
symbol pinil_vec : Ï€ (pV z nil_vec)
symbol n : Nat
symbol v : Vec n
symbol picons_vec : Î n x v, Ï€(pV n v) â†’ Ï€(pV (succ n) (cons_vec n x v))
assert ind_Vec pV pinil_vec _ z nil_vec â‰¡ pinil_vec
assert ind_Vec pV pinil_vec picons_vec (succ n) (cons_vec n x v)
     â‰¡ picons_vec n x v (ind_Vec pV pinil_vec picons_vec n v)

assert nil_vec : Vec z // Examples
assert cons_vec (succ z) x (cons_vec z x nil_vec) : Vec (succ (succ z))

/////////////////// Polymorphic vector

inductive Vec_param : Î (a : Set), Î (n : Nat), TYPE â‰”
 | nil_vec_p   : Î a, Vec_param a z
 | cons_vec_p  : Î a n (_:Ï„ a), Vec_param a n â†’ Vec_param a (succ n)

assert ind_Vec_param : // Induction principle
  Î p, (Î a, Ï€(p a z (nil_vec_p a))) â†’ (Î a n x v, Ï€(p a n v) â†’ Ï€(p a (succ n) (cons_vec_p a n x v))) â†’ Î a n v, Ï€(p a n v)

symbol pV_p : Î a n, Vec_param a n â†’ Prop // Tests about inductive rules
symbol pinil_vec_p : Î a, Ï€ (pV_p a z (nil_vec_p a))
symbol xV_p : Ï„ a
symbol v_p : Vec_param a n
symbol picons_vec_p : Î a n x v, Ï€(pV_p a n v) â†’ Ï€(pV_p a (succ n) (cons_vec_p a n x v))
assert ind_Vec_param pV_p pinil_vec_p _ a z (nil_vec_p a) â‰¡ pinil_vec_p a
assert ind_Vec_param pV_p pinil_vec_p picons_vec_p a (succ n) (cons_vec_p a n xV_p v_p)
     â‰¡ picons_vec_p a n xV_p v_p (ind_Vec_param pV_p pinil_vec_p picons_vec_p a n v_p)

assert nil_vec_p a : Vec_param a z // Examples
assert nil_vec_p nat : Vec_param nat z
assert cons_vec_p nat (succ z) (succ (succ (succ z))) (cons_vec_p nat z z (nil_vec_p nat)) : Vec_param nat (succ (succ z))
assertnot cons_vec_p nat (succ z) (succ (succ (succ z))) (cons_vec_p nat z true (nil_vec_p nat)) : Vec_param nat (succ (succ z))
assert cons_vec_p bool (succ z) false (cons_vec_p bool z true (nil_vec_p bool)) : Vec_param bool (succ (succ z))

////////////////// Type Bush (nested inductive type)

symbol bush : Set â†’  Set
inductive Bush : Î (_:Set), TYPE â‰”
 | BNil : Î a, Bush a
 | BCons : Î a, Ï„ a â†’ Bush (bush a) â†’ Bush a
rule Bush $a â†ª Ï„ (bush $a)

assert ind_Bush : // Induction principle
  Î p, (Î a, Ï€(p a (BNil a))) â†’ (Î a x l, Ï€(p (bush a) l) â†’ Ï€(p a (BCons a x l))) â†’ Î a l, Ï€(p a l)

symbol pB : Î a, Bush a â†’ Prop // Tests about inductive rules
symbol piBNil : Î a, Ï€ (pB a (BNil a))
symbol B : Bush (bush a)
symbol piBCons : Î a x l, Ï€ (pB (bush a) l) â†’ Ï€ (pB a (BCons a x l))
assert ind_Bush pB piBNil _ a (BNil a) â‰¡ piBNil a
assert ind_Bush pB piBNil piBCons a (BCons a x0 B)
     â‰¡ piBCons a x0 B (ind_Bush pB piBNil piBCons (bush a) B)

assert BNil a : Bush a // Examples
assert consL nat (succ (succ (succ z))) (nilL nat) : L nat
assert consL nat (succ (succ (succ z))) (consL nat (succ z) (nilL nat)) : L nat
assert consL nat (succ (succ (succ z))) (consL nat (succ z) (consL nat z (nilL nat))) : L nat
assert consL bool true (nilL bool) : L bool

///////////////// An example of the heterogenous dependent family

inductive fin : Nat â†’ TYPE â‰”
  | new : Î n, fin (succ n)
  | inj : Î n, fin n â†’ fin (succ n)

assert ind_fin : // Induction principle
  Î p, (Î n, Ï€ (p (succ n) (new n))) â†’ (Î n f, Ï€ (p n f) â†’ Ï€ (p (succ n) (inj n f))) â†’ Î n f, Ï€ (p n f)

symbol pF : Î n, fin n â†’ Prop // Tests about inductive rules
symbol pinew : Î n, Ï€ (pF (succ n) (new n))
symbol f : fin n
symbol piinj : Î n f, Ï€ (pF n f) â†’ Ï€ (pF (succ n) (inj n f))
assert ind_fin pF pinew _ (succ n) (new n) â‰¡ pinew n
assert ind_fin pF pinew piinj (succ n) (inj n f)
     â‰¡ piinj n f (ind_fin pF pinew piinj n f)

assert new n : fin (succ n) // Examples
assert inj (succ n) (new n) : fin (succ (succ n))

///////////////// Bounded List

symbol le : Nat â†’ Nat â†’ Prop
set infix left 6 "â‰¤" â‰” le

//inductive â‰¤ : Î (n:Ï„ nat), Nat â†’ Prop â‰”
//  | le_n : Î n, Ï€ (n â‰¤ n)
//  | le_S : Î n m:Ï„ nat, Ï€ (n â‰¤ m) â†’ Ï€ (n â‰¤ (succ m))

inductive listb : Î (bound : Ï„ nat), TYPE â‰”
   Bnil  : Î bound, listb bound
 | Bcons : Î bound x, Ï€ (x â‰¤ bound) â†’ listb bound â†’ listb bound

assert ind_listb : // Induction principle
Î p, (Î bound, Ï€(p bound (Bnil bound))) â†’
(Î bound x (prf:Ï€ (x â‰¤ bound)) l, Ï€(p bound l) â†’ Ï€(p bound (Bcons bound x prf l))) â†’ 
Î bound l, Ï€(p bound l)

symbol pbound : Î bound, listb bound â†’ Prop // Tests about inductive rules
symbol piBnil : Î bound, Ï€(pbound bound (Bnil bound))
symbol bound : Ï„ nat
symbol prf : Ï€ (x â‰¤ bound)
symbol lb : listb bound
symbol piBcons : Î bound x (prf:Ï€ (x â‰¤ bound)) l, Ï€(pbound bound l) â†’ Ï€(pbound bound (Bcons bound x prf l))
assert ind_listb pbound piBnil _ bound (Bnil bound) â‰¡ piBnil bound
assert ind_listb pbound piBnil piBcons bound (Bcons bound x prf lb)
     â‰¡ piBcons bound x prf lb (ind_listb pbound piBnil piBcons bound lb)

assert Bnil bound : listb bound // Examples
assert Bcons bound x prf (Bnil bound) : listb bound

///////////////// Predicat even

inductive even : Nat â†’ TYPE â‰”
| O_even      : even z
| plus_2_even : Î n:Nat, even n â†’ even (succ (succ n))

assert ind_even : Î (p:Î (n:Nat), even n â†’ Prop), // Induction principle
  Ï€ (p z O_even) â†’
  (Î n prf, Ï€ (p n prf) â†’ Ï€ (p (succ (succ n)) (plus_2_even n prf))) â†’
  Î n e, Ï€ (p n e)

symbol pE : Î n, even n â†’ Prop // Tests about inductive rules
symbol piO_even : Ï€ (pE z O_even)
symbol e0 : even z
symbol e : even n
symbol piplus_2_even : Î n e, Ï€ (pE n e) â†’ Ï€ (pE (succ (succ n)) (plus_2_even n e))
assert ind_even pE piO_even piplus_2_even z O_even â‰¡ piO_even
assert ind_even pE piO_even piplus_2_even (succ (succ n)) (plus_2_even n e)
     â‰¡ piplus_2_even n e (ind_even pE piO_even piplus_2_even n e)

assert ind_even : Î p, // Induction principle
  Ï€ (p z O_even) â†’
  (Î n prf, Ï€ (p n prf) â†’ Ï€ (p (succ (succ n)) (plus_2_even n prf))) â†’
  Î n e, Ï€ (p n e)

///////////////// Couple of natural numbers

inductive nat_prod : TYPE â‰”
  P : Nat â†’ Nat â†’ nat_prod

assert ind_nat_prod : // Induction principle
Î p : nat_prod â†’ Prop,
(Î x0 x1, Ï€ (p (P x0 x1))) â†’
Î x, Ï€ (p x)

symbol pNP : nat_prod â†’ Prop // Tests about inductive rules
symbol piP : Î x0 x1, Ï€ (pNP (P x0 x1))
symbol nat1 : Nat
symbol nat2 : Nat
assert ind_nat_prod pNP piP (P nat1 nat2) â‰¡ piP nat1 nat2


// Inductive pc : nat -> nat -> nat_prod -> Prop :=
// | pc0 : forall a b c d e f, add c d f -> pc a c (P d e) -> pc a b (P c O) -> pc (S a) b (P f e)
// | pc1 : forall a b c d e f, pc a (plus d b) (P e f) -> pc a c (P O d) -> pc a b (P c O) -> pc (S a) b (P c e)
// | pc2 : forall a b c, pc a (S b) c -> pc a b (P (S (S O)) O) -> pc (S a) b c
// | pc3 : forall a b c d, pc a b (P c d) -> pc (S a) b (P d c)
// | pc4 : forall a, pc O a (P O O).



// Inductive fibo: nat -> nat -> Prop :=
// | cgenâ€™ : forall (a n r1 r2:nat),
// fiboâ€™ n r1 -> fibo (S n) r2 ->  fibo (S (S n)) (plus r1 r2)
// | cbase1 : forall (a:nat), fibo O (S O)
// | cbase2 : forall (a:nat), fibo (S O) (S O).



// (** * Recursive dependent type for rooted ordinary maps

//  [(rom e)] is the type of terms representing rooted ordinary maps with [e] edges. *)

// Inductive rom : nat -> Type :=
// | mty : rom 0                                           (* leaf node *)
// | bin : forall e1 e2, rom e1 -> rom e2 -> rom (e1+e2+1) (* binary nodes *)
// | unl : forall e k, k <= 2*e -> rom e -> rom (S e).     (* unary labeled nodes *)



// Inductive is_blist (b : nat) : list nat -> Prop :=
// | Blist_nil: is_blist b nil
// | Blist_cons : forall v l,
//    v < b -> is_blist b l
//    -> is_blist b (v::l).

// Paires dÃ©pendantes

// Inductive DPair : forall (a : Type) (p : a -> Type) Type :=
//    MkDPair : forall (a: Type) (p : a -> Type)  (x : a), p x -> DPair a p.
// (* C'est une adpaptation d'un type Agda *)
// https://cs.stackexchange.com/questions/56283/examples-of-dependent-types

//inductive DPair : Î (a:TYPE) (p : a â†’ TYPE), TYPE â‰”
//  MkDPair :Î a p x, p x â†’ DPair a p

// (* extrait du bouquin de A. Chipala - expressions bien typÃ©es.*) (* http://adam.chlipala.net/cpdt/*)

// Inductive type : Set := Nat | Bool.

set declared "ð•Š"
inductive ð•Š: TYPE â‰”
    nat_s  : ð•Š
  | bool_s : ð•Š

//symbol truc : TYPE â†’ TYPE

// Inductive tbinop : type -> type ->  type ->  Set :=
// | TPlus : tbinop Nat Nat Nat
// | TTimes : tbinop Nat Nat Nat
// | TEq : forall t, tbinop t t Bool
// | TLt : tbinop Nat Nat Bool.

// Inductive texp : type -> Set :=
// | TNConst : nat -> texp Nat
// | TBConst : bool ->  texp Bool
// | TBinop : forall t1 t2 t, tbinop t1 t2 t ->  texp t1 ->  texp t2 ->  texp t.




/////////////////////////////
// Some proofs
/////////////////////////////

// About natural numbers
set builtin "0"  â‰” z
set builtin "+1" â‰” succ

symbol plus : Nat â†’ Nat â†’ Nat
set infix left 6 "+" â‰” plus
rule       0 + $y â†ª $y
with succ $x + $y â†ª succ ($x + $y)

theorem plus_0_n : Î n, Ï€ ((0 + n) = n)
proof
  assume n
  reflexivity
qed

theorem plus_n_0 : Î n, Ï€ ((n + 0) = n)
proof
  assume n
  refine ind_Nat (Î»z, (z + 0) = z) _ _ _
  // Case n = O
  refine eq_refl 0
  // Case = S n'
  assume n' Hn'
  simpl
  rewrite Hn'
  reflexivity
qed

// About lists
symbol length : List â†’ Nat
rule length nil â†ª 0
 with length (cons _ $l) â†ª succ (length $l)

symbol app : List â†’ List â†’ List
rule  app      nil     $m â†ª $m
 with app (cons $x $l) $m â†ª cons $x (app $l $m)

theorem length_app :
  Î (l1 l2 : List), Ï€ ((length l1 + length l2) = length (app l1 l2))
proof
  assume l1 l2
  apply ind_List
        (Î»z, (length z+length l2) = length (app z l2)) _ _ l1
  reflexivity
  assume x l2 IHl1
  simpl rewrite IHl1 reflexivity
qed

///////////////// Type rom

symbol mult : Nat â†’ Nat â†’ Nat
set infix left 7 "Ã—" â‰” mult
rule       0 Ã— _  â†ª 0
 with succ $x Ã— $y â†ª $y + $x Ã— $y
//set debug +s

//inductive rom : Nat â†’ TYPE â‰”
//  | mty : rom z // leaf node
//  | bin : Î e1 e2, rom e1 â†’ rom e2 â†’ rom (e1+e2+1) // binary nodes
//  | unl : Î e k, Ï€ (k â‰¤ 2Ã—e) â†’ rom e â†’ rom (succ e) // unary labeled nodes

symbol rom : Nat â†’ TYPE
symbol mty : rom z
symbol bin : Î e1 e2, rom e1 â†’ rom e2 â†’ rom (e1+e2+1)
symbol unl : Î e k, Ï€ (k â‰¤ 2Ã—e) â†’ rom e â†’ rom (succ e)

symbol ind_rom : Î p: Î x: Nat, rom x â†’ Prop,
  Ï€ (p 0 mty) â†’
  (Î e1: Ï„ nat, Î e2: Ï„ nat, Î x: rom e1, Ï€ (p e1 x) â†’ Î x0: rom e2, Ï€ (p e2 x0) â†’ Ï€ (p ((e1 + e2) + 1) (bin e1 e2 x x0))) â†’ 
  (Î e: Ï„ nat, Î k: Ï„ nat, Î x: Ï€ (k â‰¤ (2 Ã— e)), Î x0: rom e, Ï€ (p e x0) â†’ Ï€ (p (succ e) (unl e k x x0))) â†’ 
Î x: Nat, Î x0: rom x, Ï€ (p x x0)

rule ind_rom $p $pmty $pbin $punl (($x0 + $x1)+1) (bin $x0 $x1 $x2 $x3)
   â†ª $pbin $x0 $x1 $x2 (ind_rom $p $pmty $pbin $punl $x0 $x2) $x3 (ind_rom $p $pmty $pbin $punl $x1 $x3)
