/* Binary integers

by Quentin Garchery (May 2021). */

require open tests.OK.Pos;

inductive â„¤ : TYPE â‰” // \BbbZ
| Z0 : â„¤
| Zpos : â„™ â†’ â„¤
| Zneg : â„™ â†’ â„¤;

// set code for â„¤

constant symbol int : Set;

rule Ï„ int â†ª â„¤;

// boolean functions for testing head constructor

symbol isZ0 : â„¤ â†’ ğ”¹;

rule isZ0 Z0       â†ª true
with isZ0 (Zpos _) â†ª false
with isZ0 (Zneg _) â†ª false;

symbol isZpos : â„¤ â†’ ğ”¹;

rule isZpos Z0       â†ª false
with isZpos (Zpos _) â†ª true
with isZpos (Zneg _) â†ª false;

symbol isZneg : â„¤ â†’ ğ”¹;

rule isZneg Z0       â†ª false
with isZneg (Zpos _) â†ª false
with isZneg (Zneg _) â†ª true;

// Discriminate constructors

opaque symbol Zposâ‰ Z0 p : Ï€ (Zpos p â‰  Z0) â‰”
begin
  assume n h; refine ind_eq h (Î» n, istrue(isZ0 n)) âŠ¤áµ¢
end;

opaque symbol Znegâ‰ Z0 p : Ï€ (Zneg p â‰  Z0) â‰”
begin
  assume n h; refine ind_eq h (Î» n, istrue(isZ0 n)) âŠ¤áµ¢
end;

opaque symbol Zposâ‰ Zneg p q : Ï€ (Zpos p â‰  Zneg q) â‰”
begin
  assume x y h; refine ind_eq h (Î» n, istrue(isZneg n)) âŠ¤áµ¢
end;

// Unary opposite

symbol â€” : â„¤ â†’ â„¤;
notation â€” prefix 24;

rule â€” Z0 â†ª Z0
with â€” (Zpos $p) â†ª Zneg $p
with â€” (Zneg $p) â†ª Zpos $p;

symbol â€”_idem z : Ï€ (â€” â€” z = z) â‰”
begin
  induction { reflexivity } { reflexivity } { reflexivity }
end;

// Doubling functions

symbol double : â„¤ â†’ â„¤;

rule double Z0 â†ª Z0
with double (Zpos $p) â†ª Zpos (O $p)
with double (Zneg $p) â†ª Zneg (O $p);

symbol succ_double : â„¤ â†’ â„¤;

rule succ_double Z0 â†ª Zpos H
with succ_double (Zpos $p) â†ª Zpos (I $p)
with succ_double (Zneg $p) â†ª Zneg (pos_pred_double $p);

symbol pred_double : â„¤ â†’ â„¤;

rule pred_double Z0 â†ª Zneg H
with pred_double (Zpos $p) â†ª Zpos (pos_pred_double $p)
with pred_double (Zneg $p) â†ª Zneg (I $p);

// Interaction of opp and doubling functions

opaque symbol double_opp z : Ï€ (double (â€” z) = â€” double z) â‰”
begin
  induction { reflexivity } { reflexivity } { reflexivity }
end;

opaque symbol succ_double_opp z : Ï€ (succ_double (â€” z) = â€” pred_double z) â‰”
begin
  induction { reflexivity } { reflexivity } { reflexivity }
end;

opaque symbol pred_double_opp z : Ï€ (pred_double (â€” z) = â€” succ_double z) â‰”
begin
  induction { reflexivity } { reflexivity } { reflexivity }
end;

// Binary negation on â„™

symbol sub : â„™ â†’ â„™ â†’ â„¤;

rule sub (I $p) (I $q) â†ª double (sub $p $q)
with sub (I $p) (O $q) â†ª succ_double (sub $p $q)
with sub (I $p) H      â†ª Zpos (O $p)
with sub (O $p) (I $q) â†ª pred_double (sub $p $q)
with sub (O $p) (O $q) â†ª double (sub $p $q)
with sub (O $p) H      â†ª Zpos (pos_pred_double $p)
with sub H      (I $q) â†ª Zneg (O $q)
with sub H      (O $q) â†ª Zneg (pos_pred_double $q)
with sub H       H     â†ª Z0;

opaque symbol sub_same z : Ï€ (sub z z = Z0) â‰”
begin
  induction
   { assume x xrec; simplify; rewrite xrec; reflexivity }
   { assume x xrec; simplify; rewrite xrec; reflexivity }
   { reflexivity }
end;

opaque symbol sub_opp x y : Ï€ (â€” sub x y = sub y x) â‰”
begin
  induction
  // case I
  { assume x xrec;
    induction
     { assume y h; simplify; rewrite left xrec y; rewrite double_opp; reflexivity }
     { assume y h; simplify; rewrite left xrec y; rewrite pred_double_opp; reflexivity }
     { reflexivity } }
  // case O
  { assume x xrec;
    induction
     { assume y h; simplify; rewrite left xrec y; rewrite succ_double_opp; reflexivity }
     { assume y h; simplify; rewrite left xrec y; rewrite double_opp; reflexivity }
     { reflexivity } }
  // case H
  { induction { reflexivity } { reflexivity } { reflexivity } }
end;

// Addition of integers

symbol + : â„¤ â†’ â„¤ â†’ â„¤;
notation + infix right 20;

rule Z0      + $y      â†ª $y
with $x      + Z0      â†ª $x
with Zpos $x + Zpos $y â†ª Zpos (add $x $y)
with Zpos $x + Zneg $y â†ª sub $x $y
with Zneg $x + Zpos $y â†ª sub $y $x
with Zneg $x + Zneg $y â†ª Zneg (add $x $y);

// Interaction of addition with opposite

opaque symbol distr_â€”_+ x y : Ï€ (â€” (x + y) = â€” x + â€” y) â‰”
begin
  induction
  // case Z0
  { reflexivity }
  // case Zpos
  { assume x;
    induction
     { reflexivity }
     { reflexivity }
     { assume y; simplify; rewrite sub_opp; reflexivity } }
  // case Zneg
  { assume x;
    induction
      { reflexivity }
      { assume y; simplify; rewrite sub_opp; reflexivity }
      { reflexivity } }
end;

// Commutativity of addition

opaque symbol +_com x y : Ï€ (x + y = y + x) â‰”
begin
  induction
  // case Z0
  { induction { reflexivity } { reflexivity } { reflexivity } }
  // case Zpos
  { assume x;
    induction
     { reflexivity }
     { assume y; simplify; rewrite add_com; reflexivity }
     { reflexivity } }
  // case Zneg
  { assume x;
    induction
     { reflexivity }
     { reflexivity }
     { assume y; simplify; rewrite add_com; reflexivity } }
end;

// Interaction of succ and doubling functions

opaque symbol pred_double_succ x : Ï€ (pred_double (x + Zpos H) = succ_double x) â‰”
begin
  induction
   { reflexivity }
   { assume x; simplify; rewrite pos_pred_double_succ; reflexivity }
   { induction { reflexivity } { reflexivity } { reflexivity } }
end;

opaque symbol succ_pred_double x : Ï€ (pred_double x + Zpos H = double x) â‰”
begin
  induction
   { reflexivity }
   { assume x; simplify; rewrite succ_pos_pred_double; reflexivity }
   { reflexivity }
end;

opaque symbol succ_double_carac x : Ï€ (succ_double x = double x + Zpos H) â‰”
begin
  induction { reflexivity } { reflexivity } { reflexivity }
end;

opaque symbol double_succ x : Ï€ (double (x + Zpos H) = succ_double x + Zpos H) â‰”
begin
  induction
   { reflexivity }
   { reflexivity }
   { induction { reflexivity } { reflexivity } { reflexivity } }
end;

// Negation

symbol - x y â‰” x + â€” y;

notation - infix left 20;

opaque symbol -_same z : Ï€ (z + â€” z = Z0) â‰”
begin
  induction
   { reflexivity }
   { simplify; refine sub_same }
   { simplify; refine sub_same }
end;

// Associativity

opaque symbol sub_succ x y : Ï€ (sub (succ x) y = sub x y + Zpos H) â‰”
begin
  induction
  // case I
  { assume x xrec;
    induction
      { assume y h; simplify; rewrite xrec; rewrite pred_double_succ;
        rewrite succ_double_carac; reflexivity }
      { assume y h; simplify; rewrite xrec; rewrite double_succ; reflexivity }
      { simplify; rewrite pos_pred_double_succ; reflexivity } }
  // case O
  { assume x xrec;
    induction
      { assume y h; simplify; rewrite left succ_pred_double; reflexivity }
      { assume y h; simplify; rewrite succ_double_carac; reflexivity }
      { simplify; rewrite succ_pos_pred_double; reflexivity } }
  // case H
  { induction
     { induction { reflexivity } { reflexivity } { reflexivity } }
     { induction { reflexivity } { reflexivity } { reflexivity } }
     { reflexivity } }
end;

opaque symbol add_Zpos_succ x p : Ï€ (x + Zpos (succ p) = (x + Zpos p) + Zpos H) â‰”
begin
  induction
   { reflexivity }
   { assume x p; simplify; rewrite add_succ_right; reflexivity }
   { assume x p; simplify; rewrite sub_succ; reflexivity }
end;

opaque symbol sub_add_Zpos a b c : Ï€ (sub a b + Zpos c = sub (add a c) b) â‰”
begin
  assume a b c;
  refine ind_â„™eano (Î» c, sub a b + Zpos c = sub (add a c) b) _ _ c
  // case H
  { simplify; rewrite sub_succ; reflexivity }
  // case succ
  { assume r rrec; rewrite add_Zpos_succ; rewrite rrec;
    rewrite add_succ_right; rewrite sub_succ; reflexivity }
end;

opaque symbol sub_add_Zneg a b c : Ï€ (sub a b + Zneg c = sub a (add b c)) â‰”
begin
  assume a b c;
  rewrite left sub_opp (add b c) a;
  rewrite left sub_add_Zpos;
  rewrite distr_â€”_+; rewrite sub_opp; reflexivity;
end;

opaque symbol +_assoc x y z : Ï€ ((x + y) + z = x + (y + z)) â‰”
begin
  induction
  { reflexivity }
  { assume x;
    induction
     { reflexivity }
     { assume y;
       induction
         { reflexivity }
         // case Zpos - Zpos - Zpos
         { assume z; simplify; rewrite add_assoc; reflexivity }
         // case Zpos - Zpos - Zneg
         { assume z; simplify; rewrite +_com; rewrite sub_add_Zpos;
           rewrite add_com; reflexivity } }

     { assume y;
       induction
         { reflexivity }
         // case Zpos - Zneg - Zpos
         { assume z; simplify; rewrite sub_add_Zpos; rewrite +_com;
           rewrite sub_add_Zpos; rewrite add_com; reflexivity }
         // case Zpos - Zneg - Zneg
         { assume z; simplify; rewrite sub_add_Zneg; reflexivity } } }

  { assume x;
    induction
      { reflexivity }
      { assume y;
        induction
          { reflexivity }
          // case Zneg - Zpos - Zpos
          { assume z; simplify; rewrite sub_add_Zpos; reflexivity }
          // case Zneg - Zpos - Zneg
          { assume z; simplify; rewrite sub_add_Zneg; rewrite +_com;
            rewrite sub_add_Zneg; rewrite add_com; reflexivity } }

      { assume y;
        induction
          { reflexivity }
          // case Zneg - Zneg - Zpos
          { assume z; simplify; rewrite +_com; rewrite sub_add_Zneg;
            rewrite add_com; reflexivity }
          // case Zneg - Zneg - Zneg
          { assume z; simplify; rewrite add_assoc; reflexivity } } }
end;

// Comparison of integers

require open tests.OK.Comp;

symbol â‰ : â„¤ â†’ â„¤ â†’ Comp; notation â‰ infix 12; // \doteq

rule Z0      â‰ Z0      â†ª Eq
with Z0      â‰ Zpos _  â†ª Lt
with Z0      â‰ Zneg _  â†ª Gt
with Zpos _  â‰ Z0      â†ª Gt
with Zpos $p â‰ Zpos $q â†ª compare $p $q
with Zpos _  â‰ Zneg _  â†ª Gt
with Zneg _  â‰ Z0      â†ª Lt
with Zneg _  â‰ Zpos _  â†ª Lt
with Zneg $p â‰ Zneg $q â†ª compare $q $p;

// â‰ decides the equality of integers

opaque symbol â‰_decides x y : Ï€ (x â‰ y = Eq â‡’ x = y) â‰”
begin
  induction
  // case Z0
  { induction
      { reflexivity }
      { assume y H; apply âŠ¥â‚‘; refine Ltâ‰ Eq H }
      { assume y H; apply âŠ¥â‚‘; refine Gtâ‰ Eq H } }
  // case Zpos
  { assume x;
    induction
     { assume H; apply âŠ¥â‚‘; refine Gtâ‰ Eq H }
     { assume y H; rewrite compare_decides x y H; reflexivity }
     { assume y H; apply âŠ¥â‚‘; refine Gtâ‰ Eq H } }
  // case Zneg
  { assume x;
    induction
     { assume H; apply âŠ¥â‚‘; refine Ltâ‰ Eq H }
     { assume y H; apply âŠ¥â‚‘; refine Ltâ‰ Eq H }
     { assume y H; rewrite compare_decides y x H; reflexivity } }
end;

// Commutative properties of â‰

opaque symbol â‰_com x y : Ï€ (x â‰ y = opp (y â‰ x)) â‰”
begin
  induction
  // case Z0
  { induction { reflexivity } { reflexivity } { reflexivity } }
  // case Zpos
  { assume x;
    induction
     { reflexivity }
     { assume y; simplify; rewrite compare_acc_com; reflexivity }
     { reflexivity } }
  // case Zneg
  { assume x;
    induction
     { reflexivity }
     { reflexivity }
     { assume y; simplify; rewrite compare_acc_com; reflexivity } }
end;

opaque symbol â‰_opp x y : Ï€ (â€” x â‰ â€” y = opp (x â‰ y)) â‰”
begin
  induction
  // case Z0
  { induction { reflexivity } { reflexivity } { reflexivity } }
  // case Zpos
  { assume x;
    induction
     { reflexivity }
     { assume y; simplify; rewrite compare_acc_com; reflexivity }
     { reflexivity } }
  // case Zneg
  { assume x;
    induction
      { reflexivity }
      { reflexivity }
      { assume y; simplify; rewrite compare_acc_com; reflexivity } }
end;

// General results

opaque symbol simpl_right x a : Ï€ ((x + a) - a = x) â‰”
begin
  assume x a; simplify; rewrite +_assoc;
  rewrite -_same; reflexivity;
end;

opaque symbol simpl_inv_right x a : Ï€ ((x - a) + a = x) â‰”
begin
  assume x a; simplify; rewrite +_assoc;
  rewrite .[â€” a + a] +_com; rewrite -_same; reflexivity;
end;

// â‰ with 0

opaque symbol â‰_double x : Ï€ ((double x â‰ Z0) = (x â‰ Z0)) â‰”
begin
  induction { reflexivity } { reflexivity } { reflexivity }
end;

opaque symbol â‰_pred_double x :
  Ï€ (pred_double x â‰ Z0 = case_Comp (x â‰ Z0) Lt Lt Gt) â‰”
begin
  induction { reflexivity } { reflexivity } { reflexivity }
end;

opaque symbol â‰_succ_double x :
  Ï€ (succ_double x â‰ Z0 = case_Comp (x â‰ Z0) Gt Lt Gt) â‰”
begin
  induction { reflexivity } { reflexivity } { reflexivity }
end;

opaque symbol â‰_pos_sub x y : Ï€ ((sub x y â‰ Z0) = compare x y) â‰”
begin
  induction
  // case I
  { assume x xrec;
    induction
     { assume y h; simplify; rewrite â‰_double; refine xrec y }
     { assume y h; simplify; rewrite â‰_succ_double; rewrite xrec;
       rewrite compare_Gt; reflexivity }
     { reflexivity } }
  // case O
  { assume x xrec;
    induction
     { assume y h; simplify; rewrite â‰_pred_double; rewrite xrec;
        rewrite compare_Lt; reflexivity }
     { assume y h; simplify; rewrite â‰_double; refine xrec y }
     { reflexivity } }
  // case H
  { induction { reflexivity } { reflexivity } { reflexivity } }
end;

opaque symbol â‰_sub x y : Ï€ ((x â‰ y) = (x + â€” y â‰ Z0)) â‰”
begin
  induction
  // case Z0
  { induction { reflexivity } { reflexivity } { reflexivity } }
  // case Zpos
  { assume x;
    induction
     { reflexivity }
     { assume y; simplify; rewrite â‰_pos_sub; reflexivity }
     { reflexivity } }
  // case Zneg
  { assume x;
    induction
     { reflexivity }
     { reflexivity }
     { assume y; simplify; rewrite â‰_pos_sub; reflexivity } }
end;

// Compatibility of comparison with the addition

opaque symbol â‰_compat_add x y z : Ï€ ((x â‰ y) = (x + z â‰ y + z)) â‰”
begin
  assume x y z;
  rewrite â‰_sub; rewrite .[x in _ = x] â‰_sub;
  rewrite distr_â€”_+; rewrite .[â€” y + â€” z] +_com;
  rewrite +_assoc; rewrite left +_assoc z (â€” z) (â€” y);
  rewrite -_same z; reflexivity;
end;

// Directional comparison operators

symbol â‰¤ x y â‰” Â¬ (istrue(isGt(x â‰ y)));
notation â‰¤ infix 10;

symbol < x y â‰” istrue(isLt(x â‰ y));
notation < infix 10;

symbol â‰¥ x y â‰” Â¬ (x < y);
notation â‰¥ infix 10;

symbol > x y â‰” Â¬ (x â‰¤ y);
notation > infix 10;

opaque symbol <_â‰¤ x y : Ï€ (x < y â‡’ x â‰¤ y) â‰”
begin
  assume x y;
  refine ind_Comp (Î» u, istrue(isLt u) â‡’ istrue(isGt u) â‡’ âŠ¥) _ _ _ (x â‰ y)
   { refine (Î» x _, x) }
   { refine (Î» _ y, y) }
   { refine (Î» x _, x) }
end;

// Compatibility of directional comparison operators

opaque symbol â‰¤_compat_add x y a : Ï€ (x â‰¤ y â‡’ x + a â‰¤ y + a) â‰”
begin
  assume x y a; simplify;
  assume H; refine fold_â‡’ _; rewrite â‰_sub;
  simplify; refine fold_â‡’ _; rewrite +_assoc;
  rewrite .[y + a] +_com; rewrite distr_â€”_+;
  rewrite left +_assoc a (â€” a) (â€” y); rewrite -_same;
  rewrite left +_assoc x Z0 (â€” y); simplify; refine fold_â‡’ _;
  rewrite left â‰_sub x y; refine H;
end;

opaque symbol <_compat_add x y a : Ï€ (x < y â‡’ x + a < y + a) â‰”
begin
  assume x y a; simplify; assume H; rewrite â‰_sub;
  rewrite +_assoc; rewrite .[y + a] +_com;
  rewrite distr_â€”_+; rewrite left +_assoc a (â€” a) (â€” y);
  rewrite -_same; rewrite left +_assoc;
  simplify; rewrite left â‰_sub; refine H;
end;

opaque symbol â‰¤_compat_â‰¤ x y : Ï€ (Z0 â‰¤ x â‡’ Z0 â‰¤ y â‡’ Z0 â‰¤ x + y) â‰”
begin
  induction
   { assume y h H; refine H }
   { assume x;
     induction
      { assume h1 h2; refine h1 }
      { assume y h h' i; refine i }
      { assume y h f i; refine f âŠ¤áµ¢ } }
  { assume x y f h i; refine f âŠ¤áµ¢ }
end;

opaque symbol <_compat_â‰¤ x y : Ï€ (Z0 < x â‡’ Z0 â‰¤ y â‡’ Z0 < x + y) â‰”
begin
  induction
   { assume y f h; apply âŠ¥â‚‘; refine f }
   { assume x;
     induction
      { assume h1 h2; refine âŠ¤áµ¢ }
      { assume y h h'; refine âŠ¤áµ¢ }
      { simplify; assume y h f; apply âŠ¥â‚‘; refine f âŠ¤áµ¢ } }
  { assume x; assume y f h; apply âŠ¥â‚‘; refine f }
end;

// Reflexivity

opaque symbol â‰¤_refl x : Ï€ (x â‰¤ x) â‰”
begin
  assume x; refine â‰¤_compat_add Z0 Z0 x _; refine (Î» x, x);
end;

// Antisymmetry

opaque symbol â‰¤_antisym x y : Ï€ (x â‰¤ y â‡’ y â‰¤ x â‡’ x = y) â‰”
begin
  assume x y;
  have e : Ï€ (Â¬ (istrue(isGt (x â‰ y))) â‡’ Â¬ (istrue(isGt (y â‰ x))) â‡’ x = y)
  { rewrite â‰_com } ;
  refine ind_Comp (Î» c, (y â‰ x) = c â‡’ Â¬ (istrue(isGt (opp c))) â‡’ Â¬ (istrue(isGt c)) â‡’ x = y) _ _ _ (y â‰ x) _
   { assume H h1 h2; symmetry; refine â‰_decides y x H }
   { assume h1 f h2; apply âŠ¥â‚‘; refine f âŠ¤áµ¢ }
   { assume h1 h2 f; apply âŠ¥â‚‘; refine f âŠ¤áµ¢ }
   { reflexivity; refine e }
end;

// Transitivity theorems

opaque symbol â‰¤_trans x y z : Ï€ (x â‰¤ y â‡’ y â‰¤ z â‡’ x â‰¤ z) â‰”
begin
   assume x y z lxy lyz;
   have H : Ï€ (Z0 â‰¤ (z + â€” y) + (y + â€” x))
   { refine â‰¤_compat_â‰¤ (z - y) (y - x) _ _
      { rewrite left -_same y; refine â‰¤_compat_add y z (â€” y) _; refine lyz }
      { rewrite left -_same x; refine â‰¤_compat_add x y (â€” x) _; refine lxy } } ;
   generalize H; refine fold_â‡’ _;
   rewrite +_assoc; rewrite left +_assoc (â€” y) y (â€” x);
   rewrite .[â€” y + y] +_com; rewrite -_same;
   refine (Î» p : Ï€ ((Z0 â‰¤ (z + â€” x)) â‡’ (x â‰¤ z)), p) _;
   rewrite left .[in x â‰¤ z] simpl_inv_right z x;
   refine â‰¤_compat_add Z0 (z - x) x;
end;

opaque symbol <_trans_1 x y z : Ï€ (x < y â‡’ y â‰¤ z â‡’ x < z) â‰”
begin
  assume x y z lxy lyz;
  have H : Ï€ (Z0 < (z + â€” y) + (y + â€” x))
   { rewrite +_com; apply <_compat_â‰¤ (y - x) (z - y)
      { rewrite left -_same x; refine <_compat_add x y (â€” x) _; refine lxy }
      { rewrite left -_same y; refine â‰¤_compat_add y z (â€” y) _; refine lyz } } ;
  generalize H; refine fold_â‡’ _;
  rewrite +_assoc; rewrite left +_assoc (â€” y) y (â€” x);
  rewrite .[â€” y + y] +_com; rewrite -_same;
  rewrite left .[in x < z] simpl_inv_right z x;
  refine <_compat_add Z0 (z - x) x;
end;

opaque symbol <_trans_2 x y z : Ï€ (x â‰¤ y â‡’ y < z â‡’ x < z) â‰”
begin
  assume x y z lxy lyz;
  have H : Ï€ (Z0 < (z + â€” y) + (y + â€” x))
  { apply <_compat_â‰¤ (z - y) (y - x)
     { rewrite left -_same y; refine <_compat_add y z (â€” y) _; refine lyz }
     { rewrite left -_same x; refine â‰¤_compat_add x y (â€” x) _; refine lxy } };
  generalize H; refine fold_â‡’ _;
  rewrite +_assoc; rewrite left +_assoc (â€” y) y (â€” x);
  rewrite .[â€” y + y] +_com; rewrite -_same;
  rewrite left .[in x < z] simpl_inv_right z x;
  refine <_compat_add Z0 (z - x) x;
end;

// Multiplication

symbol * : â„¤ â†’ â„¤ â†’ â„¤;
notation * infix right 22;

rule Z0      * _       â†ª Z0
with _       * Z0       â†ª Z0
with Zpos $x * Zpos $y â†ª Zpos (mul $x $y)
with Zpos $x * Zneg $y â†ª Zneg (mul $x $y)
with Zneg $x * Zpos $y â†ª Zneg (mul $x $y)
with Zneg $x * Zneg $y â†ª Zpos (mul $x $y);

// shortcuts

symbol _1 â‰” Zpos _1;
symbol _2 â‰” Zpos _2;
symbol _3 â‰” Zpos _3;
symbol _4 â‰” Zpos _4;
symbol _5 â‰” Zpos _5;
symbol _6 â‰” Zpos _6;
symbol _7 â‰” Zpos _7;
symbol _8 â‰” Zpos _8;
symbol _9 â‰” Zpos _9;
symbol _10 â‰” Zpos _10;

// enable printing of integers in decimal notation

builtin "int_zero" â‰” Z0;
builtin "int_positive" â‰” Zpos;
builtin "int_negative" â‰” Zneg;

// enable parsing of integers in decimal notation

builtin "0" â‰” Z0;
builtin "1" â‰” _1;
builtin "2" â‰” _2;
builtin "3" â‰” _3;
builtin "4" â‰” _4;
builtin "5" â‰” _5;
builtin "6" â‰” _6;
builtin "7" â‰” _7;
builtin "8" â‰” _8;
builtin "9" â‰” _9;
builtin "10" â‰” _10;

builtin "+" â‰” +;
builtin "*" â‰” *;
builtin "-" â‰” â€”;
