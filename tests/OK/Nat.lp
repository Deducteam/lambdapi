/* Library on natural numbers

by Quentin Buzet (July 2022)

following https://github.com/math-comp/math-comp/blob/master/mathcomp/ssreflect/ssrnat.v

Documentation of ssrnat.v
-------------------------

The following operations and notations are provided:

successor and predecessor
     n +1 and n âˆ¸1

basic arithmetic
  m + n, m - n, m * n
Important: m - n denotes TRUNCATED subtraction: m - n = 0 if m <= n.

exponentiation, factorial
     m ^ n, n !
     m ^ 1 is convertible to m, and m ^ 2 to m * m

comparison
   m <= n, m < n, m >= n, m > n, m == n, m <= n <= p, etc.,
comparisons are BOOLEAN operators.
  Most compatibility lemmas are stated as boolean equalities; this keeps
the size of the library down. All the inequalities refer to the same
constant "leq"; in particular m < n is identical to m.+1 <= n.

maximum and minimum
   maxn m n, minn m n
Note that maxn m n = m + (n - m), due to the truncating subtraction.

Not available
-------------

doubling, halving, and parity
   n.*2, n./2, odd n, uphalf n,  with uphalf n = n.+1./2
bool coerces to nat so we can write, e.g., n = odd n + n./2.*2.

iteration
          iter n f x0  == f ( .. (f x0))
          iteri n g x0 == g n.âˆ¸1 (g ... (g 0 x0))
      iterop n op x x0 == op x (... op x x) (n x's) or x0 if n = 0

conditionally strict inequality `leqif'
   m <= n ?= iff condition   ==   (m <= n) and ((m == n) = condition)
This is actually a pair of boolean equalities, so rewriting with an
`leqif' lemma can affect several kinds of comparison. The transitivity
lemma for leqif aggregates the conditions, allowing for arguments of
the form ``m <= n <= p <= m, so equality holds throughout''.

countable choice
  ex_minn : forall P : pred nat, (exists n, P n) -> nat
This returns the smallest n such that P n holds.
  ex_maxn : forall (P : pred nat) m,
     (exists n, P n) -> (forall n, P n -> n <= m) -> nat
This returns the largest n such that P n holds (given an explicit upper
bound).

Naming convention
-----------------

This file adds the following suffix conventions to those documented in
ssrbool.v and eqtype.v:
A (infix) -- conjunction, as in
   ltn_neqAle : (m < n) = (m != n) && (m <= n).
B -- subtraction, as in subBn : (m - n) - p = m - (n + p).
D -- addition, as in mulnDl : (m + n) * p = m * p + n * p.
M -- multiplication, as in expnMn : (m * n) ^ p = m ^ p * n ^ p.
p (prefix) -- positive, as in
   eqn_pmul2l : m > 0 -> (m * n1 == m * n2) = (n1 == n2).
P  -- greater than 1, as in
   ltn_Pmull : 1 < n -> 0 < m -> m < n * m.
S -- successor, as in addSn : n +1 + m = (n + m) +1.
V (infix) -- disjunction, as in
   leq_eqVlt : (m <= n) = (m == n) || (m < n).
X - exponentiation, as in lognX : logn p (m ^ n) = logn p m * n in
      file prime.v (the suffix is not used in this file).
Suffixes that abbreviate operations (D, B, M and X) are used to abbreviate
second-rank operations in equational lemma names that describe left-hand
sides (e.g., mulnDl); they are not used to abbreviate the main operation
of relational lemmas (e.g., leq_add2l).
For the asymmetrical exponentiation operator expn (m ^ n) a right suffix
indicates an operation on the exponent, e.g., expnM : m ^ (n1 * n2) = ...;
a trailing "n" is used to indicate the left operand, e.g.,
expnMn : (m1 * m2) ^ n = ... The operands of other operators are selected
using the l/r suffixes.
*/

require open tests.OK.Bool;

inductive â„• : TYPE â‰”
| _0 : â„•
| +1 : â„• â†’ â„•; notation +1 postfix 100;

// set code for â„•

constant symbol nat : Set;

rule Ï„ nat â†ª â„•;

// non confusion of constructors

symbol is0 : â„• â†’ ğ”¹;

rule is0 _0 â†ª true
with is0 (_ +1) â†ª false;

opaque symbol sâ‰ 0 [n] : Ï€ (n +1 â‰  _0) â‰”
begin
  assume n h; refine ind_eq h (Î» n, istrue(is0 n)) âŠ¤áµ¢
end;

opaque symbol 0â‰ s [n] : Ï€ (_0 â‰  n +1) â‰”
begin
  assume n h; apply @sâ‰ 0 n; symmetry; apply h
end;

opaque symbol casen n : Ï€(n = _0 âˆ¨ n â‰  _0) â‰”
begin
  induction
  { apply âˆ¨áµ¢â‚; reflexivity }
  { assume n h; apply âˆ¨áµ¢â‚‚; refine sâ‰ 0 }
end;

// predecessor

symbol âˆ¸1 : â„• â†’ â„•; notation âˆ¸1 postfix 100;

rule _0 âˆ¸1 â†ª _0
with ($x +1) âˆ¸1 â†ª $x;

opaque symbol +1_inj [x y] : Ï€ (x +1 = y +1) â†’ Ï€ (x = y) â‰”
begin
  assume x y h; apply feq (âˆ¸1) h
end;

// boolean equality on â„•

symbol eqn : â„• â†’ â„• â†’ ğ”¹;

rule eqn _0 _0 â†ª true
with eqn ($x +1) ($y +1) â†ª eqn $x $y
with eqn _0 (_ +1) â†ª false
with eqn (_ +1) _0 â†ª false;

opaque symbol eqn_correct x y : Ï€(istrue(eqn x y)) â†’ Ï€(x = y) â‰”
begin
  induction
  { induction { reflexivity } { assume x h i; apply âŠ¥â‚‘ i } }
  { assume x h; induction
    { assume i; apply âŠ¥â‚‘ i }
    { assume y i j; apply feq (+1); apply h _ j }
  }
end;

opaque symbol eqn_complete x y : Ï€(x = y) â†’ Ï€(istrue(eqn x y)) â‰”
begin
  induction
  { assume y i; rewrite left i; apply âŠ¤áµ¢ }
  { simplify; assume x h; induction
    { assume i; apply sâ‰ 0 i }
    { assume y i j; simplify; refine h y _; apply +1_inj; refine j }
  }
end;

// addition

symbol + : â„• â†’ â„• â†’ â„•; notation + infix left 20;

rule _0 + $y â†ª $y
with $x +1 + $y â†ª ($x + $y) +1;

opaque symbol add0n x : Ï€ (_0 + x = x) â‰”
begin
  assume x; reflexivity;
end;

opaque symbol addn0 x : Ï€ (x + _0 = x) â‰”
begin
  induction
  { reflexivity }
  { assume x' h; simplify; rewrite h; reflexivity }
end;

rule $x + _0 â†ª $x;

opaque symbol addSn x y : Ï€ (x +1 + y = (x + y) +1) â‰”
begin
  assume x; reflexivity;
end;

opaque symbol addnS x y : Ï€ (x + y +1 = (x + y) +1) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite h; reflexivity }
end;

rule $x + $y +1 â†ª ($x + $y) +1;

opaque symbol add1n n : Ï€ ((_0 +1) + n = n +1) â‰”
begin
  assume n; reflexivity;
end;

opaque symbol addn1 n : Ï€ (n + (_0 +1) = n +1) â‰”
begin
  assume n; reflexivity;
end;

opaque symbol addSnnS m n : Ï€ (m +1 + n = m + n +1) â‰”
begin
  assume m n; reflexivity;
end;

opaque symbol addnC x y : Ï€ (x + y = y + x) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite h; reflexivity }
end;

opaque symbol addnA x y z : Ï€ ((x + y) + z = x + (y + z)) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y z; simplify; rewrite h; reflexivity }
end;

rule ($x + $y) + $z â†ª $x + ($y + $z);

opaque symbol addnCA m n p : Ï€ ((m + n) + p = (m + p) + n) â‰”
begin
  assume m n p; symmetry; rewrite addnA; rewrite .[p + n] addnC;
  rewrite left addnA; reflexivity;
end;

opaque symbol addnAC m n p : Ï€ (m + (n + p) = n + (m + p)) â‰”
begin
  assume m n p; symmetry; rewrite left addnA; rewrite .[n + m] addnC;
  rewrite addnA; reflexivity;
end;

opaque symbol addnCAC m n p : Ï€ (m + n + p = p + n + m) â‰”
begin
  assume m n p; rewrite addnC; rewrite .[m + _] addnC; rewrite addnA;
  reflexivity;
end;

opaque symbol addnACl m n p : Ï€ (m + n + p = n + (p + m)) â‰”
begin
  assume m n p; rewrite .[m + _] addnC; rewrite addnA; rewrite .[m + _] addnC;
  reflexivity;
end;

opaque symbol addnACA m n p q : Ï€ ((m + n) + (p + q) = (m + p) + (n + q)) â‰”
begin
  assume m n p q; simplify; rewrite left .[p + (n + q)] addnA;
  rewrite .[p + n] addnC; rewrite .[(n + p) + q] addnA; reflexivity;
end;

opaque symbol addnI x y z : Ï€ (z + x = z + y) â†’ Ï€ (x = y) â‰”
begin
  assume x y; induction
  { assume h; apply h;}
  { assume z h i; apply h; apply +1_inj; apply i;}
end;

opaque symbol addIn x y z : Ï€ (x + z = y + z) â†’ Ï€ (x = y) â‰”
begin
  assume x y; induction
  { assume h; apply h;}
  { assume z h i; apply h; apply +1_inj; apply i;}
end;

opaque symbol addn_eq0 m n : Ï€ (m + n = _0 â‡” m = _0 âˆ§ n = _0) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize m; induction
    { assume m h; apply âˆ§áµ¢ (eq_refl _0) h }
    { assume m h n i; apply âŠ¥â‚‘ (sâ‰ 0 i) }
  } {
    generalize m; induction
    { assume n h; apply âˆ§â‚‘â‚‚ h }
    { assume m h n i; apply âŠ¥â‚‘ (sâ‰ 0 (âˆ§â‚‘â‚ i)) }
  }
end;

opaque symbol eqn_add2l p m n : Ï€ ((p + m = p + n) â‡” (m = n)) â‰”
begin
  assume p m n;
  apply âˆ§áµ¢ {
    refine addnI m n p
  } {
    generalize p; induction
    { assume m n h; apply h }
    { assume z h m n i; simplify; rewrite h m n i; reflexivity }
  };
end;

opaque symbol eqn_add2r p m n : Ï€ ((m + p = n + p) â‡” (m = n)) â‰”
begin
  assume p m n; rewrite addnC m p; rewrite addnC n p; apply eqn_add2l p m n;
end;

opaque symbol 2*=0 n : Ï€(n + n = _0) â†’ Ï€(n = _0) â‰”
begin
  assume n h; apply âˆ§â‚‘â‚ (âˆ§â‚‘â‚ (addn_eq0 n n) h)
end;

opaque symbol 2*_inj x y : Ï€(x + x = y + y) â†’ Ï€(x = y) â‰”
begin
  induction
  { assume y h; symmetry; apply 2*=0; symmetry; apply h }
  { assume x h; induction
    { assume i; apply âŠ¥â‚‘ (sâ‰ 0 i) }
    { assume y i j; apply feq (+1); apply h; apply +1_inj; apply +1_inj j }
}
end;

opaque symbol oddâ‰ even p q : Ï€((p + p) +1 â‰  q + q) â‰”
begin
  induction
  { induction
    { refine sâ‰ 0 }
    { assume x h; simplify; assume i; apply 0â‰ s (+1_inj i) }
  }
  { assume x h; induction
    { refine sâ‰ 0 }
    { assume y i j; apply h y; apply +1_inj; apply +1_inj; apply j }
  }
end;

// substraction

symbol - : â„• â†’ â„• â†’ â„•; notation - infix left 20;

rule _0 - _ â†ª _0
with $x - _0 â†ª $x
with $x +1 - $y +1 â†ª $x - $y;

opaque symbol sub0n n : Ï€ (n - _0 = n) â‰”
begin
  reflexivity;
end;

opaque symbol subn0 n : Ï€ (_0 - n = _0) â‰”
begin
  reflexivity;
end;

opaque symbol subnn x : Ï€ (x - x = _0) â‰”
begin
  induction
  { reflexivity }
  { assume x h; simplify; apply h;}
end;

opaque symbol subSS m n : Ï€ (m +1 - (n +1) = m - n) â‰”
begin
  reflexivity;
end;

opaque symbol subn1 n : Ï€ (n - (_0 +1) = n âˆ¸1) â‰”
begin
  induction
  { reflexivity }
  { assume n h; reflexivity;  }
end;

opaque symbol subnS x y : Ï€ (x - (y +1) = (x - y) âˆ¸1) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; simplify; rewrite h; reflexivity }
  }
end;

opaque symbol subSnn n : Ï€ (n +1 - n = (_0 +1)) â‰”
begin
  induction
  { reflexivity }
  { assume n h; simplify; apply h }
end;

opaque symbol predn_sub x y : Ï€ ((x - y) âˆ¸1 = x âˆ¸1 - y) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; simplify; symmetry; rewrite subnS; reflexivity }
  }
end;

opaque symbol subnAC z x y : Ï€ ((x - y) - z = (x - z) - y) â‰”
begin
  induction
  { reflexivity }
  { assume z h; induction
    { reflexivity }
    { assume x i; induction
      { reflexivity }
      { assume y j; simplify; rewrite i; rewrite subnS; symmetry;
        rewrite subnS; rewrite predn_sub; reflexivity}
    }
  }
end;

opaque symbol addnK x y : Ï€ ((x + y) - y = x) â‰”
begin
  induction
  { assume x; simplify; rewrite subnn; reflexivity }
  { assume x h; induction
    { reflexivity }
    { simplify; assume y i; rewrite i; reflexivity }
  }
end;

opaque symbol subnDA x y z : Ï€ (x - (y + z) = (x - y) - z) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; simplify; rewrite subnS; symmetry; rewrite subnS;
        rewrite h; reflexivity }
    }
  }
end;

opaque symbol subnDl z x y : Ï€ ((z + x) - (z + y) = x - y) â‰”
begin
  induction
  { assume x y; simplify; reflexivity }
  { assume z h; induction
    { assume y; simplify; rewrite subnDA; rewrite subnn; reflexivity }
    { assume x i; induction
      { rewrite addnC; rewrite addn0; rewrite addnK; reflexivity }
      { assume y j; rewrite addnC; rewrite subnDA; rewrite addnK; reflexivity }
    }
  }
end;

opaque symbol subnDr z x y : Ï€ ((x + z) - (y + z) = x - y) â‰”
begin
  assume z x y; rewrite addnC; rewrite .[y + _] addnC; rewrite subnDl;
  reflexivity;
end;

opaque symbol subSKn m n : Ï€ ((m +1 - n) âˆ¸1 = m - n) â‰”
begin
  assume m n; rewrite left subnS; reflexivity;
end;

// multiplication

symbol * : â„• â†’ â„• â†’ â„•; notation * infix left 30; // \times

assert x y z âŠ¢ x + y * z â‰¡ x + (y * z);

rule _0 * _  â†ª _0
with ($x +1) * $y â†ª $y + $x * $y;

opaque symbol mul0n x : Ï€ (x * _0 = _0) â‰”
begin
  induction { reflexivity } { assume x' h; apply h }
end;

rule _ * _0 â†ª _0;

opaque symbol muln0 x : Ï€ (_0 * x = _0) â‰”
begin
  assume x; reflexivity;
end;

opaque symbol mul1n n : Ï€ ((_0 +1) * n = n) â‰”
begin
  assume n; reflexivity;
end;

opaque symbol muln1 n : Ï€ (n * (_0 +1) = n) â‰”
begin
  induction
  { reflexivity }
  { assume n h; simplify; rewrite h; reflexivity }
end;

opaque symbol mulSn m n : Ï€ ((m +1) * n = n + m * n) â‰”
begin
  reflexivity;
end;

opaque symbol mulSnr m n : Ï€ ((m +1) * n = m * n + n) â‰”
begin
  assume m n; rewrite addnC; reflexivity;
end;

opaque symbol mulnS x y : Ï€ (x * (y +1) = x + x * y) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite h; rewrite addnAC; reflexivity }
end;

//rule $x * ($y +1) â†ª $x + $x * $y; is confluent modulo C only

opaque symbol mulnSr x y : Ï€ (x * (y +1) = x * y + x) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite mulnS; rewrite .[x' + _] addnC;
    reflexivity }
end;

//rule $x * s $y â†ª $x * $y + $x; is confluent modulo C only

opaque symbol mulnC x y : Ï€ (x * y = y * x) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y; simplify; rewrite mulnS; rewrite h; reflexivity }
end;

opaque symbol mulnDl x y z : Ï€ ((x + y) * z = x * z + y * z) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y z; simplify; rewrite h; reflexivity }
end;

//rule ($x + $y) * $z â†ª $x * $z + $y * $z; is confluent modulo AC only

opaque symbol mulnDr x y z : Ï€ (z * (x + y) = z * x + z * y) â‰”
begin
  assume x y z; rewrite mulnC; rewrite mulnDl; rewrite mulnC;
  rewrite .[y * _] mulnC; reflexivity
end;

//rule $z * ($x + $y) â†ª $z * $x + $z * $y; is confluent modulo AC only

opaque symbol mulnBr x y z : Ï€ (x * (y - z) = x * y - x * z) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; simplify; rewrite mulnS; rewrite mulnS;
        rewrite left addnAC; rewrite .[z + (x + _)] addnAC;
        rewrite subnDl; rewrite left mulSn; rewrite left mulSn;
        rewrite left mulSn; rewrite left i; reflexivity }
    }
  }
end;

opaque symbol mulnBl x y z : Ï€ ((x - y) * z = x * z - y * z) â‰”
begin
  assume x y z; rewrite mulnC; rewrite .[x * z] mulnC; rewrite .[y * z] mulnC;
  rewrite left mulnBr; reflexivity;
end;

opaque symbol mulnA x y z : Ï€ ((x * y) * z = x * (y * z)) â‰”
begin
  induction
  { reflexivity }
  { assume x' h y z; simplify; rewrite mulnDl; rewrite h; reflexivity }
end;

//rule ($x * $y) * $z â†ª $x * ($y * $z); is not confluent

opaque symbol mulnCA x y z: Ï€ (x * (y * z) = y * (x * z)) â‰”
begin
  assume x y z; rewrite left mulnA; rewrite .[x * y] mulnC; rewrite mulnA;
  reflexivity;
end;

opaque symbol mulnAC x y z: Ï€ ((x * y) * z = (x * z) * y) â‰”
begin
  assume x y z; rewrite mulnA; rewrite .[y * z] mulnC; rewrite left mulnA;
  reflexivity;
end;

opaque symbol mulnACA x y z t: Ï€ ((x * y) * (z * t) = (x * z) * (y * t)) â‰”
begin
  assume x y z t; rewrite mulnA; rewrite .[y * _] mulnCA; rewrite mulnA;
  reflexivity;
end;

opaque symbol muln_eq0 m n : Ï€ (m * n = _0 â‡” m = _0 âˆ¨ n = _0) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize m; induction
    { assume n h; apply âˆ¨áµ¢â‚ h }
    { assume m h n i;
      have t: Ï€ (n = _0 âˆ§ (m * n) = _0) { apply âˆ§â‚‘â‚ (addn_eq0 n (m * n)) i };
      have u: Ï€ (n = _0) { apply âˆ§â‚‘â‚ t };
      apply âˆ¨áµ¢â‚‚ u;
    }
  } {
    assume h;
    refine âˆ¨â‚‘ h _ _ {
      assume i; rewrite i; reflexivity;
    } {
      assume i; rewrite i; reflexivity;
    };
  };
end;

// Boolean ordering functions

symbol â‰¤ : â„• â†’ â„• â†’ ğ”¹; notation â‰¤ infix left 10;

rule _0 â‰¤ _ â†ª true
with _ +1 â‰¤ _0 â†ª false
with $x +1 â‰¤ $y +1 â†ª $x â‰¤ $y;

symbol < : â„• â†’ â„• â†’ ğ”¹; notation < infix 10;

rule $x < $y â†ª $x +1 â‰¤ $y;

symbol â‰¥ : â„• â†’ â„• â†’ ğ”¹; notation â‰¥ infix 10;

rule $x â‰¥ $y â†ª $y â‰¤ $x;

symbol > : â„• â†’ â„• â†’ ğ”¹; notation > infix 10;

rule $x > $y â†ª $y +1 â‰¤ $x;

opaque symbol â‰¤0 x : Ï€ (istrue (x â‰¤ _0)) â†’ Ï€ (x = _0) â‰”
begin
  induction
  { assume h; reflexivity;}
  { assume x h i; apply âŠ¥â‚‘; apply i }
end;

opaque symbol â‰¤_refl x : Ï€ (istrue (x â‰¤ x)) â‰”
begin
  induction
  { simplify; apply âŠ¤áµ¢;}
  { assume x h; simplify; apply h }
end;

opaque symbol eq_leq x y : Ï€ (x = y) â†’ Ï€ (istrue (x â‰¤ y)) â‰”
begin
  assume x y h; rewrite h; apply â‰¤_refl y;
end;

opaque symbol leq_trans [x y z] :
  Ï€ (istrue (x â‰¤ y)) â†’ Ï€ (istrue (y â‰¤ z)) â†’ Ï€ (istrue (x â‰¤ z)) â‰”
begin
  induction
  { assume y z h i; apply h }
  { assume x h; induction
    { assume y i; apply âŠ¥â‚‘ i }
    { assume y i; induction
      { assume j k; apply k }
      { assume z j k l; apply h y z k l }
    }
  }
end;

opaque symbol eqn_leq x y : Ï€ (istrue (x â‰¤ y) âˆ§ istrue (y â‰¤ x) â‡” (x = y)) â‰”
begin
  assume x y; apply âˆ§áµ¢ {
    generalize x; induction
    { assume y g;
      have i: Ï€ (istrue (y â‰¤ _0)) { apply âˆ§â‚‘â‚‚ g };
      symmetry; apply â‰¤0 y i;
    }
    {
      assume x h; induction
      { assume g;
        have i: Ï€ (istrue (x +1 â‰¤ _0)) { apply âˆ§â‚‘â‚ g };
        apply â‰¤0 (x +1) i;
      }
      { assume y i j; apply feq (+1); apply h y j;}
    }
  } {
    assume h;
    have t: Ï€ (istrue (x â‰¤ y)) { apply eq_leq _ _ h;};
    have u: Ï€ (istrue (y â‰¤ x)) { apply eq_leq y x _; symmetry; apply h;};
    apply âˆ§áµ¢ t u;
  };
end;

opaque symbol leqsnn n: Ï€ (istrue (n +1 â‰¤ n)) â†’ Ï€ âŠ¥ â‰”
begin
  induction
  { assume h; apply h }
  { assume n h i; apply h; apply i;}
end;

opaque symbol letnS m n : Ï€ (istrue (m < n +1)) â†’ Ï€ (istrue (m â‰¤ n)) â‰”
begin
  assume m n h; apply h;
end;

opaque symbol ltn0 n : Ï€ (istrue (n < _0)) â†’ Ï€ âŠ¥ â‰”
begin
  assume n h; apply h;
end;

opaque symbol ltnn n : Ï€ (istrue (n < n)) â†’ Ï€ âŠ¥ â‰”
begin
  assume n h; apply leqsnn n; apply h;
end;

opaque symbol ltnSn n : Ï€ (istrue (n < n +1)) â‰”
begin
  assume n; simplify; apply â‰¤_refl n;
end;

opaque symbol leq0n n : Ï€ (istrue (_0 â‰¤ n)) â‰”
begin
  induction
  { apply â‰¤_refl _0;}
  { assume n h; simplify; apply h }
end;

opaque symbol ltn0Sn n : Ï€ (istrue (_0 < n +1)) â‰”
begin
  assume n; apply leq0n n;
end;

opaque symbol leqnSn n : Ï€ (istrue (n â‰¤ n +1)) â‰”
begin
  induction
  { apply leq0n (_0 +1) }
  { assume n h; simplify; apply h }
end;

opaque symbol leq_pred n : Ï€ (istrue (n âˆ¸1 â‰¤ n)) â‰”
begin
  induction
  { apply âŠ¤áµ¢;}
  { assume n h; simplify; apply leqnSn n;}
end;

opaque symbol ltnW m n : Ï€ (istrue (m < n)) â†’ Ï€ (istrue (m â‰¤ n)) â‰”
begin
  induction
  { assume m h; apply âŠ¤áµ¢;}
  { assume m h; induction
    { assume i; apply i;}
    { assume n i j; apply h n; apply j;}
  }
end;

opaque symbol leqW m n : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ (istrue (m â‰¤ n +1)) â‰”
begin
  assume m n h; apply ltnW m (n +1); simplify; apply h;
end;

opaque symbol ltn_trans x y z : Ï€ (istrue (x < y)) â†’ Ï€ (istrue (y < z)) â†’ Ï€ (istrue (x < z)) â‰”
begin
  assume x y z h i;
  have v:Ï€ (istrue (x +1 â‰¤ y +1)) { apply leqW (x +1) y h };
  apply @leq_trans (x +1) (y +1) z v i;
end;

opaque symbol <_asym x y : Ï€ (istrue (x < y)) â†’ Ï€ (Â¬ (istrue (y < x))) â‰”
begin
  assume x y h i;
  have t:Ï€ (istrue (y â‰¤ y +1)) { apply leqnSn y };
  have u:Ï€ (istrue (x +1 â‰¤ y +1)) { apply @leq_trans (x +1) y (y +1) h t };
  have v:Ï€ (istrue (x +1 â‰¤ x)) { apply @leq_trans (x +1) (y +1) x u i };
  apply leqsnn x; apply v;
end;

opaque symbol anti_ltn x y : Ï€(istrue (x < y)) â†’ Ï€(istrue (y < x)) â†’ Ï€(x = y) â‰”
begin
  assume x y h i;
  have c:Ï€ (istrue (x â‰¤ x +1)) { apply leqnSn x };
  have d:Ï€ (istrue (y â‰¤ y +1)) { apply leqnSn y };
  have e:Ï€ (istrue (x â‰¤ y)) { apply @leq_trans x (x +1) y c h };
  have f:Ï€ (istrue (y â‰¤ x)) { apply @leq_trans y (y +1) x d i };
  have g:Ï€ (istrue (x â‰¤ y) âˆ§ istrue (y â‰¤ x)) { apply âˆ§áµ¢ e f };
  apply âˆ§â‚‘â‚ (eqn_leq x y) g;
end;

opaque symbol leq_total x y : Ï€ (istrue (x â‰¤ y) âˆ¨ istrue (y â‰¤ x)) â‰”
begin
  induction
  { assume y; simplify; apply âˆ¨áµ¢â‚; apply âŠ¤áµ¢ }
  { assume x h; induction
    { simplify; apply âˆ¨áµ¢â‚‚; apply âŠ¤áµ¢ }
    { assume y i; simplify; apply h y }
  }
end;

opaque symbol lt0n n : Ï€ (istrue (n > _0) â‡” (n â‰  _0)) â‰”
begin
  assume n; apply âˆ§áµ¢ {
    generalize n; induction
    { assume h i; apply h }
    { assume n h i j; apply sâ‰ 0 j;}
  } {
    generalize n; induction
    { assume h; apply h (eq_refl _0) }
    { assume n h i; apply âŠ¤áµ¢ }
  };
end;

opaque symbol leq_eqVlt m n : Ï€ (istrue (m â‰¤ n) â‡” (m = n) âˆ¨ istrue (m < n)) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize m; induction
    { induction
      { assume h; apply âˆ¨áµ¢â‚ (eq_refl _0) }
      { assume n h i; apply âˆ¨áµ¢â‚‚ âŠ¤áµ¢ }
    }
    { assume m h; induction
      { assume i; apply âˆ¨áµ¢â‚‚ i }
      { assume n i j; apply âˆ¨â‚‘ (h n j)
        { assume e; apply âˆ¨áµ¢â‚; rewrite e; reflexivity }
        { assume e; apply âˆ¨áµ¢â‚‚; apply e }
      }
    }
  } {
    assume h; apply âˆ¨â‚‘ h {
      assume i; apply eq_leq m n i
    } {
      assume i; apply ltnW m n i
    }
  }
end;

opaque symbol leq_add0 m n :
  Ï€ (istrue (_0 â‰¤ m)) â†’ Ï€ (istrue (_0 â‰¤ n)) â†’ Ï€ (istrue (_0 â‰¤ m + n)) â‰”
begin
  assume m n h i; apply leq0n (m + n);
end;

opaque symbol leq_add2l p m n : Ï€ (istrue (p + m â‰¤ p + n) â‡” istrue (m â‰¤ n)) â‰”
begin
  assume p m n; apply âˆ§áµ¢ {
    generalize p; induction
    { assume m n h; apply h }
    { assume p h m n i; apply h m n i }
  } {
    generalize p; induction
    { assume m n h; apply h }
    { assume p h m n i; apply h m n i }
  }; 
end;

opaque symbol ltn_add2l p m n : Ï€ (istrue (p + m < p + n) â‡” istrue (m < n)) â‰”
begin
  assume p m n; simplify; rewrite left addnS; refine leq_add2l p (m +1) n;
end;

opaque symbol leq_add2r p m n : Ï€ (istrue (m + p â‰¤ n + p) â‡” istrue (m â‰¤ n)) â‰”
begin
  assume p m n; rewrite addnC m p; rewrite addnC n p; refine leq_add2l p m n;
end;

opaque symbol ltn_add2r p m n : Ï€ (istrue (m + p < n + p) â‡” istrue (m < n)) â‰”
begin
  assume p m n; rewrite addnC m p; rewrite addnC n p; refine ltn_add2l p m n;
end;

opaque symbol leq_addl m n : Ï€ (istrue (n â‰¤ m + n)) â‰”
begin
  assume m; induction
  { apply âŠ¤áµ¢ }
  { assume n h; apply h }
end;

opaque symbol leq_addr m n : Ï€ (istrue (n â‰¤ n + m)) â‰”
begin
  assume m n; rewrite addnC n m; apply leq_addl m n;
end;

opaque symbol leq_subr m n : Ï€ (istrue (n - m â‰¤ n)) â‰”
begin
  induction
  { assume n; apply â‰¤_refl n }
  { assume m h; induction
    { apply âŠ¤áµ¢ }
    { assume n i; simplify;
      have t: Ï€ (istrue (n â‰¤ n +1)) { apply leqnSn n };
      apply @leq_trans (n - m) n (n +1) (h n) t;
    }
  }
end;

opaque symbol subn_eq0 m n : Ï€ ((m - n = _0) â‡” istrue (m â‰¤ n)) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize m; induction
    { assume n h; apply âŠ¤áµ¢ }
    { assume m h; induction
      { assume i; apply sâ‰ 0 i }
      { assume n i j; apply h n j }
    }
  } {
    generalize m; induction
    { assume n h; apply eq_refl _0 }
    { assume m h; induction
      { assume i; apply âŠ¥â‚‘ i }
      { assume n i j; apply h n j }
    }
  };
end;

opaque symbol ltn_addl m n p : Ï€ (istrue (m < n)) â†’ Ï€ (istrue (m < p + n)) â‰”
begin
  assume m n; induction
  { assume h; apply h }
  { assume p h i; refine @leq_trans m (m +1) (p + n) (leqnSn m) (h i) }
end;

opaque symbol ltn_addr m n p : Ï€ (istrue (m < n)) â†’ Ï€ (istrue (m < n + p)) â‰”
begin
  assume m n p h; rewrite addnC n p; apply ltn_addl m n p; apply h;
end;

opaque symbol addn_gt0 m n :
  Ï€ (istrue (_0 < m + n) â‡” istrue (_0 < m) âˆ¨ istrue (_0 < n)) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize m; induction
    { assume n i; apply âˆ¨áµ¢â‚‚ i }
    { assume m h n i; apply âˆ¨áµ¢â‚; apply ltn0Sn m }
  } {
    assume h; apply âˆ¨â‚‘ h {
      assume i; apply ltn_addr _0 m n i;
    } {
      assume i; apply ltn_addl _0 n m i;
    };
  };
end;

opaque symbol subn_gt0 m n : Ï€ (istrue (_0 < n - m) â‡” istrue (m < n)) â‰”
begin
  assume m n; apply âˆ§áµ¢ {
    generalize m; induction
    { assume n h; apply h }
    { assume m h; induction
      { assume i; apply i }
      { assume n i; rewrite subSS; assume j;
        have t: Ï€ (istrue (m < n)) { apply h n j };
        have u: Ï€ (istrue (m +1 < n +1))
                  { refine âˆ§â‚‘â‚‚ (ltn_add2r (_0 +1) m n) t };
        rewrite left addn1 m; rewrite left addn1 n; apply u;
      }
    }
  } {
    generalize m; induction
    { assume n h; apply h }
    { assume m h; induction
      { assume i; apply i }
      { assume n i j; rewrite subSS; apply h n;
        refine âˆ§â‚‘â‚ (ltn_add2r (_0 +1) m n) j;
      }
    }
  };
end;

opaque symbol leq_add m1 m2 n1 n2 :
  Ï€ (istrue (m1 â‰¤ n1)) â†’ Ï€ (istrue (m2 â‰¤ n2)) â†’ Ï€ (istrue (m1 + m2 â‰¤ n1 + n2)) â‰”
begin
  assume m1 m2 n1 n2 h i;
  have a: Ï€ (istrue (m1 + m2 â‰¤ m1 + n2)) { apply âˆ§â‚‘â‚‚ (leq_add2l m1 m2 n2) i };
  have b: Ï€ (istrue (m1 + n2 â‰¤ n1 + n2)) { refine âˆ§â‚‘â‚‚ (leq_add2r n2 m1 n1) h };
  refine @leq_trans (m1 + m2) (m1 + n2) (n1 + n2) a b;
end;

opaque symbol leq_subLR m n p : Ï€ (istrue (m - n â‰¤ p) â‡” istrue (m â‰¤ n + p)) â‰”
begin
  assume m n p; apply âˆ§áµ¢
  { assume h;
    have t: Ï€ (((m - (n + p)) = _0)) â†’ Ï€ (istrue (m â‰¤ (n + p)))
      { apply âˆ§â‚‘â‚ (subn_eq0 m (n + p)) };
    apply t; rewrite subnDA; apply âˆ§â‚‘â‚‚ (subn_eq0 (m - n) p) h;
  }
  { assume h;
    have t: Ï€ (((m - n) - p) = _0) â†’ Ï€ (istrue ((m - n) â‰¤ p))
      { apply âˆ§â‚‘â‚ (subn_eq0 (m - n) p) };
    apply t; rewrite left subnDA; apply âˆ§â‚‘â‚‚ (subn_eq0 m (n + p)) h;
  };
end;

opaque symbol subnKC m n : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ (m + (n - m) = n) â‰”
begin
  induction
  { assume n h; apply eq_refl n }
  { assume m h; induction
    { assume i; apply âŠ¥â‚‘ i }
    { assume n i j; apply feq (+1); apply h; apply j }
  }
end;

opaque symbol addnBn m n : Ï€ (m + (n - m) = m - n + n) â‰”
begin
  induction
  { assume n; apply eq_refl n }
  { assume m h; induction
    { apply eq_refl (m +1) }
    { assume n i; simplify; apply feq (+1); apply h n }
  }
end;

opaque symbol subnK m n : Ï€ (istrue (m â‰¤ n)) â†’ Ï€ ((n - m) + m = n) â‰”
begin
  assume m n h; rewrite addnC; apply subnKC m n h;
end;

opaque symbol subSn n p : Ï€ (istrue (p â‰¤ n)) â†’ Ï€ (n +1 - p = (n - p) +1) â‰”
begin
  induction
  { assume p h; simplify;
    have t: Ï€ (p = _0) { apply â‰¤0 p h };
    rewrite t; reflexivity;
  } {
    assume n h; induction
    { assume i; reflexivity }
    { assume p i j; apply h p j }
  }
end;

opaque symbol addnBA m n p : Ï€ (istrue (p â‰¤ n))  â†’ Ï€ (m + (n - p) = m + n - p) â‰”
begin
  induction
  { assume n p h; reflexivity }
  { assume m h n p i; simplify; rewrite left addnS m (n - p);
    rewrite left addnS m n; rewrite left h (n +1) p (leqW p n i);
    rewrite subSn n p i; reflexivity;
  }
end;

opaque symbol addnBAC m n p : Ï€ (istrue (n â‰¤ m)) â†’ Ï€ (m - n + p = m + p - n) â‰”
begin
  assume m n p h;
  rewrite addnC; rewrite addnBA p m n h; rewrite addnC; reflexivity;
end;

opaque symbol leq_sub2r m n p :
  Ï€ (istrue (m â‰¤ n)) â†’ Ï€ (istrue (m - p â‰¤ n - p)) â‰”
begin
  assume m n p h; apply âˆ§â‚‘â‚‚ (leq_subLR m p (n - p)) _;
  apply âˆ¨â‚‘ (leq_total p n) {
    assume i; rewrite subnKC p n i; apply h;
  } {
    assume i;
    have t: Ï€(n - p = _0) { apply âˆ§â‚‘â‚‚ (subn_eq0 n p) i };
    rewrite t; simplify; apply @leq_trans m n p h i;
  };
end;

opaque symbol leq_sub2l m n p :
  Ï€ (istrue (m â‰¤ n)) â†’ Ï€ (istrue (p - n â‰¤ p - m)) â‰”
begin
  assume m n p h; apply âˆ§â‚‘â‚‚ (leq_subLR p n (p - m)) _;
  apply âˆ¨â‚‘ (leq_total p m) {
    assume i;
    have t:Ï€ (p - m = _0) { apply (âˆ§â‚‘â‚‚ (subn_eq0 p m) i) };
    rewrite t; simplify; apply @leq_trans p m n i h;
  } {
    assume i; apply âˆ§â‚‘â‚ (leq_add2r m p (n + (p - m))) _;
    rewrite addnA; rewrite subnK m p i; rewrite addnC n p;
    apply âˆ§â‚‘â‚‚ (leq_add2l p m n) h;
  };
end;

opaque symbol leq_sub m1 m2 n1 n2 :
  Ï€ (istrue (m1 â‰¤ m2)) â†’ Ï€ (istrue (n2 â‰¤ n1)) â†’ Ï€ (istrue (m1 - n1 â‰¤ m2 - n2)) â‰”
begin
  assume m1 m2 n1 n2 h i;
  have t:Ï€ (istrue (m1 - n1 â‰¤ m2 - n1)) { apply leq_sub2r m1 m2 n1 h };
  have u:Ï€ (istrue (m2 - n1 â‰¤ m2 - n2)) { apply leq_sub2l n2 n1 m2 i };
  apply @leq_trans (m1 - n1) (m2 - n1) (m2 - n2) t u;
end;

// max

symbol max: â„• â†’ â„• â†’ â„•;

rule max _0 $x â†ª $x
with max $x _0 â†ª $x
with max ($x +1) ($y +1) â†ª (max $x $y) +1;

opaque symbol maxnC x y : Ï€ (max x y = max y x) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; simplify; rewrite h; reflexivity }
  }
end;

opaque symbol maxnA x y z : Ï€ (max (max x y) z = max x (max y z)) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; simplify; rewrite h; reflexivity }
    }
  }
end;

opaque symbol maxnAC x y z : Ï€ (max (max x y) z = max (max x z) y) â‰”
begin
  assume x y z; rewrite maxnA; rewrite maxnC y z; rewrite left maxnA;
  reflexivity;
end;

opaque symbol maxnCA x y z : Ï€ (max x (max y z) = max y (max x z)) â‰”
begin
  assume x y z; rewrite left maxnA; rewrite maxnC x y; rewrite maxnA;
  reflexivity;
end;

opaque symbol maxnACA x y z t:
  Ï€ (max (max x y) (max z t) = max (max x z) (max y t)) â‰”
begin
  assume x y z t; rewrite maxnA; rewrite maxnC y (max z t); rewrite maxnA;
  rewrite left maxnA x z; rewrite maxnC t y; reflexivity;
end;

opaque symbol addn_maxl x y z: Ï€ ((max y z) + x = max (y + x) (z + x)) â‰”
begin
  induction
  { reflexivity }
  { assume x h y z; simplify; apply feq (+1); rewrite h; reflexivity;}
end;

opaque symbol addn_maxr x y z : Ï€ (x + (max y z) = max (x + y) (x + z)) â‰”
begin
  induction
  { reflexivity }
  { assume x h y z; simplify; apply feq (+1); rewrite h; reflexivity }
end;

opaque symbol subn_maxl x y z: Ï€ ( (max x y) - z = max (x - z) (y - z) ) â‰”
begin
  induction
  { assume y z; reflexivity }
  { assume x h; induction
    { assume z; reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; simplify; apply h y z }
    }
  }
end;

opaque symbol maxnE m n : Ï€ (max m n = m + (n - m)) â‰”
begin
  induction
  { assume n; reflexivity }
  { assume m h; induction
    { simplify;  reflexivity }
    { assume n i; simplify; rewrite h; reflexivity }
  }
end;

opaque symbol maxnn x : Ï€ (max x x = x) â‰”
begin
  induction
  { reflexivity }
  { assume x h; simplify; rewrite h; reflexivity }
end;

rule max $x $x â†ª $x;

opaque symbol leq_maxl m n : Ï€ (istrue (m â‰¤ max m n)) â‰”
begin
  induction
  { assume n; apply âŠ¤áµ¢ }
  { assume m h; induction
    { simplify; apply â‰¤_refl m }
    { assume n i; simplify; apply h n }
  }
end;

opaque symbol leq_maxr m n : Ï€ (istrue (n â‰¤ max m n)) â‰”
begin
  assume m n; rewrite maxnC m n; apply leq_maxl n m;
end;

opaque symbol ltn_predK m n : Ï€ (istrue (m < n)) â†’ Ï€ (n âˆ¸1 +1 = n) â‰”
begin
  assume m; induction
  { assume h; refine âŠ¥â‚‘ h }
  { assume n h i; reflexivity }
end;

opaque symbol prednK n : Ï€ (istrue (_0 < n)) â†’ Ï€ (n âˆ¸1 +1 = n) â‰”
begin
  refine ltn_predK _0;
end;

opaque symbol leq_pmull m n : Ï€ (istrue (n > _0)) â†’ Ï€ (istrue (m â‰¤ n * m)) â‰”
begin
  assume m n h;
  have t: Ï€ (n âˆ¸1 +1 = n) { apply prednK n h };
  rewrite left t; simplify; apply leq_addr ((n âˆ¸1) * m) m;
end;

opaque symbol leq_pmulr m n : Ï€ (istrue (n > _0)) â†’ Ï€ (istrue (m â‰¤ m * n)) â‰”
begin
  assume m n h; rewrite mulnC; apply leq_pmull m n h;
end;

opaque symbol leq_mul2l m n1 n2 :
  Ï€ (istrue (m * n1 â‰¤ m * n2) â‡” (m = _0) âˆ¨ istrue (n1 â‰¤ n2)) â‰”
begin
  assume m n1 n2;
  apply âˆ§áµ¢ {
    assume h;
    have t:Ï€ (m * (n1 - n2) = _0) {
      rewrite mulnBr; apply âˆ§â‚‘â‚‚ (subn_eq0 (m * n1) (m * n2)) h;
    };
    have u: Ï€ (m = _0 âˆ¨ n1 - n2 = _0) { apply âˆ§â‚‘â‚ (muln_eq0 m (n1 - n2)) t };
    apply âˆ¨â‚‘ u {
      assume i; refine âˆ¨áµ¢â‚ i;
    } {
      assume i; apply âˆ¨áµ¢â‚‚; apply âˆ§â‚‘â‚ (subn_eq0 n1 n2) i;
    };
  } {
    assume h; apply âˆ§â‚‘â‚ (subn_eq0 (m * n1) (m * n2)) _; rewrite left mulnBr;
    apply âˆ¨â‚‘ h {
      assume i; rewrite i; reflexivity;
    } {
      assume i;
      have t:Ï€ (n1 - n2 = _0) { apply âˆ§â‚‘â‚‚ (subn_eq0 n1 n2) i };
      rewrite t; reflexivity;
    };
  }
end;

opaque symbol leq_mul2r m n1 n2 :
  Ï€ (istrue (n1 * m â‰¤ n2 * m) â‡” (m = _0) âˆ¨ (istrue (n1 â‰¤ n2))) â‰”
begin
  assume m n1 n2; rewrite mulnC n1 m; rewrite mulnC n2 m;
  refine leq_mul2l m n1 n2;
end;

opaque symbol leq_mul m1 m2 n1 n2 :
  Ï€ (istrue (m1 â‰¤ n1)) â†’ Ï€ (istrue (m2 â‰¤ n2)) â†’ Ï€ (istrue (m1 * m2 â‰¤ n1 * n2)) â‰”
begin
  assume m1 m2 n1 n2 h1 h2;
  have t1:Ï€ ((m2 = _0) âˆ¨ istrue (m1 â‰¤ n1)) { apply âˆ¨áµ¢â‚‚ h1 };
  have t2:Ï€ ((n1 = _0) âˆ¨ istrue (m2 â‰¤ n2)) { apply âˆ¨áµ¢â‚‚ h2 };
  have u1:Ï€ (istrue (m1 * m2 â‰¤ n1 * m2)) { apply âˆ§â‚‘â‚‚ (leq_mul2r m2 m1 n1) t1 };
  have u2:Ï€ (istrue (n1 * m2 â‰¤ n1 * n2)) { apply âˆ§â‚‘â‚‚ (leq_mul2l n1 m2 n2) t2 };
  apply @leq_trans (m1 * m2) (n1 * m2) (n1 * n2) u1 u2;
end;

opaque symbol eqn_mul2l m n1 n2 : Ï€ (m * n1 = m * n2 â‡” (m = _0) âˆ¨ (n1 = n2)) â‰”
begin
  assume m n1 n2;
  apply âˆ§áµ¢ {
    assume h;
    have t:Ï€ (istrue (m * n1 â‰¤ m * n2) âˆ§ istrue (m * n2 â‰¤ m * n1))
      { apply âˆ§â‚‘â‚‚ (eqn_leq (m * n1) (m * n2)) h };
    have t1:Ï€ (istrue (m * n1 â‰¤ m * n2)) { apply âˆ§â‚‘â‚ t };
    have t2:Ï€ (istrue (m * n2 â‰¤ m * n1)) { apply âˆ§â‚‘â‚‚  t };
    have u1: Ï€ ((m = _0) âˆ¨ istrue (n1 â‰¤ n2))
               { apply âˆ§â‚‘â‚(leq_mul2l m n1 n2) t1 };
    have u2: Ï€ ((m = _0) âˆ¨ istrue (n2 â‰¤ n1))
               { apply âˆ§â‚‘â‚(leq_mul2l m n2 n1) t2 };
    apply âˆ¨â‚‘ u1 {
      assume i; apply âˆ¨áµ¢â‚ i;
    } {
      assume i;
      apply âˆ¨â‚‘ u2 {
        assume j; apply âˆ¨áµ¢â‚ j;
      } {
        assume j; apply âˆ¨áµ¢â‚‚ _;
        apply âˆ§â‚‘â‚ (eqn_leq n1 n2) (âˆ§áµ¢ i j);
      };
    };
  } {
    assume h;
    apply âˆ¨â‚‘ h {
      assume i; rewrite i; reflexivity;
    } {
      assume i; rewrite i; reflexivity;
    };
  };
end;

opaque symbol eqn_mul2r m n1 n2 : Ï€ ((n1 * m = n2 * m) â‡” (m = _0) âˆ¨ (n1 = n2)) â‰”
begin
  assume m n1 n2; rewrite mulnC n1 m; rewrite mulnC n2 m;
  refine eqn_mul2l m n1 n2;
end;

opaque symbol leq_pmul2l m n1 n2 :
  Ï€ (istrue (_0 < m)) â†’ Ï€ (istrue (m * n1 â‰¤ m * n2) â‡” istrue (n1 â‰¤ n2)) â‰”
begin
  assume m n1 n2 h;
  apply âˆ§áµ¢ {
    assume i;
    have t: Ï€ ((m = _0) âˆ¨ istrue (n1 â‰¤ n2))
              { apply âˆ§â‚‘â‚ (leq_mul2l m n1 n2) i };
    apply âˆ¨â‚‘ t {
      assume j;
      have u: Ï€ (istrue (_0 < _0))
                { rewrite left .[m in (istrue (_ < m))] j; apply h };
      refine âŠ¥â‚‘ u;
    } {
      assume j; apply j;
    };
  } {
    assume i; refine âˆ§â‚‘â‚‚ (leq_mul2l m n1 n2) _; refine âˆ¨áµ¢â‚‚ i;
  };
end;

opaque symbol leq_pmul2r m n1 n2 :
  Ï€ (istrue (_0 < m)) â†’ Ï€ (istrue (n1 * m â‰¤ n2 * m) â‡” istrue (n1 â‰¤ n2)) â‰”
begin
  assume m n1 n2 h; rewrite mulnC n1 m; rewrite mulnC n2 m;
  refine leq_pmul2l m n1 n2 h;
end;

opaque symbol ltn0_neq0 m : Ï€ (istrue (_0 < m) â‡” m â‰  _0) â‰”
begin
  assume m; apply âˆ§áµ¢ {
    generalize m; induction
    { assume h i; apply h }
    { assume m h i j; apply sâ‰ 0 j;}
  } {
    generalize m; induction
    { assume h; apply h (eq_refl _0) }
    { assume m h i; apply âŠ¤áµ¢ }
  };
end;

opaque symbol disj0 m : Ï€ (m = _0 âˆ¨ m â‰  _0) â‰”
begin
  induction
  { apply âˆ¨áµ¢â‚ (eq_refl _0) }
  { assume m h; apply âˆ¨áµ¢â‚‚; assume i; apply sâ‰ 0 i }
end;

opaque symbol eqn_pmul2l m n1 n2 :
  Ï€ (istrue (_0 < m)) â†’ Ï€ (m * n1 = m * n2 â‡” n1 = n2) â‰”
begin
  assume m n1 n2 h;
  apply âˆ§áµ¢ {
    assume i1;
    have i2: Ï€ (m * n2 = m * n1) { symmetry; apply i1 };
    have v1: Ï€ (istrue (m * n1 â‰¤ m * n2)) { apply eq_leq _ _ i1 };
    have v2: Ï€ (istrue (m * n2 â‰¤ m * n1)) { apply eq_leq _ _ i2 };
    have w1: Ï€ (istrue (n1 â‰¤ n2)) { apply âˆ§â‚‘â‚ (leq_pmul2l m n1 n2 h) v1 };
    have w2: Ï€ (istrue (n2 â‰¤ n1)) { apply âˆ§â‚‘â‚ (leq_pmul2l m n2 n1 h) v2 };
    apply âˆ§â‚‘â‚ (eqn_leq n1 n2) (âˆ§áµ¢ w1 w2);
  } {
    assume i;
    have t:Ï€ (m = _0 âˆ¨ n1 = n2) { apply âˆ¨áµ¢â‚‚ i };
    apply âˆ§â‚‘â‚‚ (eqn_mul2l m n1 n2) t;
  };
end;

opaque symbol eqn_pmul2r m n1 n2 :
  Ï€ (istrue (_0 < m)) â†’ Ï€ (n1 * m = n2 * m â‡” n1 = n2) â‰”
begin
  assume m n1 n2 h; rewrite mulnC n1 m; rewrite mulnC n2 m;
  apply eqn_pmul2l m n1 n2 h;
end;

// min

symbol min : â„• â†’ â„• â†’ â„•;

rule min _0 _ â†ª _0
with min _ _0 â†ª _0
with min ($x +1) ($y +1) â†ª (min $x $y) +1;

opaque symbol minnC x y : Ï€ (min x y = min y x) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; simplify; rewrite h; reflexivity }
  }
end;

opaque symbol minnA x y z : Ï€ (min (min x y) z = min x (min y z)) â‰”
begin
  induction
  { reflexivity }
  { assume x h; induction
    { reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; simplify; rewrite h; reflexivity;}
    }
  }
end;

opaque symbol minnAC x y z : Ï€ (min (min x y) z = min (min x z) y) â‰”
begin
  assume x y z; rewrite minnA; rewrite minnC y z; rewrite left minnA;
  reflexivity;
end;

opaque symbol minnCA x y z : Ï€ (min x (min y z) = min y (min x z)) â‰”
begin
  assume x y z; rewrite left minnA; rewrite minnC x y; rewrite minnA;
  reflexivity;
end;

opaque symbol minnACA x y z t :
  Ï€ (min (min x y) (min z t) = min (min x z) (min y t)) â‰”
begin
  assume x y z t; rewrite minnA; rewrite minnC y (min z t); rewrite minnA;
  rewrite left minnA x z; rewrite minnC t y; reflexivity;
end;

opaque symbol addn_minl x y z: Ï€ ((min y z) + x = min (y + x) (z + x)) â‰”
begin
  induction
  { reflexivity }
  { assume x h y z; simplify; apply feq (+1); rewrite h; reflexivity;}
end;

opaque symbol addn_minr x y z: Ï€ (x + (min y z) = min (x + y) (x + z)) â‰”
begin
  induction
  { reflexivity }
  { assume x h y z; simplify; apply feq (+1); rewrite h; reflexivity;}
end;

opaque symbol subn_minl x y z: Ï€ ((min x y) - z = min (x - z) (y - z)) â‰”
begin
  induction
  { assume y z; reflexivity }
  { assume x h; induction
    { assume z; reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; simplify; apply h y z }
    }
  }
end;

opaque symbol minnn x : Ï€ (min x x = x) â‰”
begin
  induction
  { reflexivity;}
  { assume x h; simplify; rewrite h; reflexivity }
end;

rule min $x $x â†ª $x;

opaque symbol geq_minl m n : Ï€ (istrue (min m n â‰¤ m)) â‰”
begin
  induction
  { assume n; apply âŠ¤áµ¢ }
  { assume m h; induction
    { apply âŠ¤áµ¢ }
    { assume n i; simplify; apply h n }
  }
end;

opaque symbol geq_minr m n : Ï€ (istrue (min m n â‰¤ n)) â‰”
begin
  assume m n; rewrite minnC; apply geq_minl n m;
end;

// proofs on max and min

opaque symbol addn_min_max m n : Ï€ (min m n + max m n = m + n) â‰”
begin
  induction
  { assume m; reflexivity }
  { assume m h; induction
    { reflexivity }
    { assume n i; simplify; rewrite h n; reflexivity }
  }
end;

opaque symbol maxnK m n : Ï€ (min (max m n) m = m) â‰”
begin
  induction
  { assume n; reflexivity }
  { assume m h; induction
    { reflexivity }
    { assume n i; simplify; rewrite h n; reflexivity }
  }
end;

opaque symbol maxKn m n : Ï€ (min n (max m n) = n) â‰”
begin
  induction
  { assume n; reflexivity }
  { assume m h; induction
    { reflexivity }
    { assume n i; simplify; rewrite h n; reflexivity }
  }
end;

opaque symbol minnK m n : Ï€ (max (min m n) m = m) â‰”
begin
  induction
  { assume n; reflexivity }
  { assume m h; induction
    { reflexivity }
    { assume n i; simplify; rewrite h n; reflexivity }
  }
end;

opaque symbol minKn m n : Ï€ (max n (min m n) = n) â‰”
begin
  induction
  { assume n; reflexivity }
  { assume m h; induction
    { reflexivity }
    { assume n i; simplify; rewrite h n; reflexivity }
  }
end;

opaque symbol maxn_minl x y z : Ï€ (max x (min y z) = min (max x y) (max x z)) â‰”
begin
  induction
  { assume y z; reflexivity }
  { assume x h; induction
    { assume z; simplify; rewrite minnC; rewrite maxnK (x +1) z; reflexivity }
    { assume y i; induction
      { simplify; rewrite maxnK x y; reflexivity }
      { assume z j; simplify; rewrite h; reflexivity }
    }
  }
end;

opaque symbol maxn_minr x y z : Ï€ (max (min y z) x = min (max y x) (max z x)) â‰”
begin
  induction
  { assume y z; reflexivity }
  { assume x h; induction
    { assume z; simplify; rewrite maxKn z (x +1); reflexivity }
    { assume y i; induction
      { simplify; rewrite maxnC; rewrite maxnK x y; reflexivity }
      { assume z j; simplify; rewrite h; reflexivity }
    }
  }
end;

opaque symbol minn_maxl x y z : Ï€ (min x (max y z) = max (min x y) (min x z)) â‰”
begin
  induction
  { assume y z; reflexivity }
  { assume x h; induction
    { assume z; reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; simplify; rewrite h; reflexivity }
    }
  }
end;

opaque symbol minn_maxr x y z : Ï€ (min (max y z) x = max (min y x) (min z x)) â‰”
begin
  induction
  { assume y z; reflexivity }
  { assume x h; induction
    { assume z; reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; simplify; rewrite h; reflexivity }
    }
  }
end;

opaque symbol maxnMr x y z : Ï€ ((max y z) * x = max (y * x) (z * x)) â‰”
begin
  induction
  { assume y z; reflexivity }
  { assume x h; induction
    { assume z; reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; rewrite left addn1 y; rewrite left addn1 z;
        rewrite left addn_maxl (_0 +1) y z; symmetry;
        rewrite mulnDl y (_0 +1) (x +1); rewrite mulnDl z (_0 +1) (x +1);
        rewrite left addn_maxl ((_0 +1) * (x +1)) (y * (x +1)) (z * (x +1));
        rewrite left i; symmetry; rewrite mulnDl (max y z) (_0 +1) (x +1);
        reflexivity;
      }
    }
  }
end;

opaque symbol maxnMl x y z : Ï€ (x * (max y z) = max (x * y) (x * z)) â‰”
begin
  induction
  { assume y z; reflexivity }
  { assume x h; induction
    { assume z; reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; rewrite left addn1 y; rewrite left addn1 z;
        rewrite left addn_maxl (_0 +1) y z; symmetry;
        rewrite mulnDr y (_0 +1) (x +1); rewrite mulnDr z (_0 +1) (x +1);
        rewrite left addn_maxl ((x +1) * (_0 +1)) ((x +1) * y) ((x +1) * z);
        rewrite left i; symmetry; rewrite mulnDr (max y z) (_0 +1) (x +1);
        reflexivity;
      }
    }
  }
end;

opaque symbol minnMr x y z : Ï€ ((min y z) * x = min (y * x) (z * x)) â‰”
begin
  induction
  { assume y z; reflexivity }
  { assume x h; induction
    { assume z; reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; rewrite left addn1 y; rewrite left addn1 z;
        rewrite left addn_minl (_0 +1) y z; symmetry;
        rewrite mulnDl y (_0 +1) (x +1); rewrite mulnDl z (_0 +1) (x +1);
        rewrite left addn_minl ((_0 +1) * (x +1)) (y * (x +1)) (z * (x +1));
        rewrite left i; symmetry; rewrite mulnDl (min y z) (_0 +1) (x +1);
        reflexivity;
      }
    }
  }
end;

opaque symbol minnMl x y z : Ï€ (x * (min y z) = min (x * y) (x * z)) â‰”
begin
  induction
  { assume y z; reflexivity }
  { assume x h; induction
    { assume z; reflexivity }
    { assume y i; induction
      { reflexivity }
      { assume z j; rewrite left addn1 y; rewrite left addn1 z;
        rewrite left addn_minl (_0 +1) y z; symmetry;
        rewrite mulnDr y (_0 +1) (x +1); rewrite mulnDr z (_0 +1) (x +1);
        rewrite left addn_minl ((x +1) * (_0 +1)) ((x +1) * y) ((x +1) * z);
        rewrite left i; symmetry; rewrite mulnDr (min y z) (_0 +1) (x +1);
        reflexivity;
      }
    }
  }
end;

// exponentiation

symbol ^ : â„• â†’ â„• â†’ â„•; notation ^ infix left 40;

rule _ ^ _0 â†ª _0 +1
with $n ^ ($m +1) â†ª $n * $n ^ $m;

opaque symbol expn0 m : Ï€ (m ^ _0 = _0 +1) â‰”
begin
  assume m; reflexivity;
end;

opaque symbol expn m : Ï€ (m ^ (_0 +1) = m) â‰”
begin
  assume m; simplify; rewrite mulnS; reflexivity;
end;

opaque symbol expnS a n : Ï€ (a ^ (n +1) = a * a ^ n ) â‰”
begin
  assume a; induction
  { reflexivity }
  { assume n h; reflexivity;}
end;

opaque symbol expnSr a n : Ï€ (a ^ (n +1) = a ^ n * a) â‰”
begin
  assume a n; rewrite expnS a n; rewrite mulnC; reflexivity;
end;

opaque symbol exp0n n : Ï€ (istrue (_0 < n)) â†’ Ï€ (_0 ^ n = _0) â‰”
begin
  induction
  { assume h; refine âŠ¥â‚‘ h;}
  { assume n h i; reflexivity }
end;

opaque symbol exp1n n : Ï€ ((_0 +1) ^ n = (_0 +1)) â‰”
begin
  induction
  { reflexivity }
  { assume n h; simplify; rewrite h; reflexivity }
end;

opaque symbol expnD a m n: Ï€ (a ^ (m + n) = a ^ m * a ^ n) â‰”
begin
  assume a; induction
  { reflexivity }
  { assume m h n; simplify; rewrite h n; rewrite mulnA; reflexivity }
end;

opaque symbol expnMn m1 m2 n : Ï€ ((m1 * m2) ^ n = m1 ^ n * m2 ^ n) â‰”
begin
  assume m1 m2; induction
  { reflexivity }
  { assume n h;  simplify; rewrite h; rewrite mulnA; rewrite mulnA;
    rewrite left mulnA (m1 ^ n) m2; rewrite mulnC (m1 ^ n) m2;
    rewrite mulnA m2 (m1 ^ n); reflexivity;
  }
end;

opaque symbol expnM m n1 n2 : Ï€ (m ^ (n1 * n2) = (m ^ n1) ^ n2) â‰”
begin
  assume m; induction
  { assume n2; simplify; rewrite exp1n; reflexivity }
  { assume n1 h n2; simplify; rewrite expnD; rewrite h n2;
    rewrite left expnMn; reflexivity }
end;

opaque symbol expnAC m n1 n2 : Ï€ ((m ^ n1) ^ n2 = (m ^ n2) ^ n1) â‰”
begin
  assume m n1 n2; rewrite left expnM; rewrite mulnC; rewrite expnM;
  reflexivity;
end;

// factorial

symbol ! : â„• â†’ â„•; notation ! postfix 40;

rule _0 ! â†ª _0 +1
with ($n +1) ! â†ª ($n +1) * $n !;

opaque symbol fact0 : Ï€ (_0 ! = (_0 +1)) â‰”
begin
  reflexivity;
end;

opaque symbol factS n : Ï€ ((n +1) ! = n +1 * n !) â‰”
begin
  reflexivity;
end;

opaque symbol fact_gt0 n : Ï€ (istrue (n ! > _0)) â‰”
begin
  induction
  { apply âŠ¤áµ¢ }
  { assume n h; rewrite factS n; rewrite mulSnr n (n !);
    apply ltn_addl _0 (n !) (n * n !); apply h }
end;

opaque symbol fact_gt1 n : Ï€ (istrue (n ! â‰¥ _0 +1)) â‰”
begin
  refine fact_gt0;
end;

opaque symbol fact_geq n : Ï€ (istrue (n â‰¤ n !)) â‰”
begin
  induction
  { apply âŠ¤áµ¢ }
  { assume n h; rewrite factS n; apply leq_pmulr (n +1) (n !) (fact_gt0 n) }
end;

// enable printing of natural numbers in decimal notation

builtin "nat_zero" â‰” _0;
builtin "nat_succ" â‰” +1;

// shortcuts

symbol _1 â‰” _0 +1;
symbol _2 â‰” _1 +1;
symbol _3 â‰” _2 +1;
symbol _4 â‰” _3 +1;
symbol _5 â‰” _4 +1;
symbol _6 â‰” _5 +1;
symbol _7 â‰” _6 +1;
symbol _8 â‰” _7 +1;
symbol _9 â‰” _8 +1;
symbol _10 â‰” _9 +1;

// enable parsing of natural numbers in decimal notation

builtin "0"  â‰” _0;
builtin "1" â‰” _1;
builtin "2" â‰” _2;
builtin "3" â‰” _3;
builtin "4" â‰” _4;
builtin "5" â‰” _5;
builtin "6" â‰” _6;
builtin "7" â‰” _7;
builtin "8" â‰” _8;
builtin "9" â‰” _9;
builtin "10" â‰” _10;

builtin "+" â‰” +;
builtin "*" â‰” *;
