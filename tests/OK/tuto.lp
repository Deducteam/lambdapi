// Learn the basics of Lambdapi in 15 minutes (this is a one-line comment).

/* Install support for Lambdapi files in Emacs or VSCode to better
visualize this file and the generated subgoals in proofs
(this is a multi-lines comment). */

/* In Lambdapi, you can declare type and object symbols. Symbol names
can contain unicode characters (utf8). */

/* Convention: identifiers starting with an uppercase letter denote
types, while identifiers starting with a lowercase denote objects. */

symbol ℕ : TYPE; // is a type declaration

// Commands are separated by semi-colons.

symbol zero : ℕ; // is an object declaration

symbol succ : ℕ → ℕ; /* means that "succ" takes an argument of type ℕ
  and returns something of type ℕ. */

/* We can use the usual decimal notation for natural numbers by mapping
Lambdapi builtin symbols to user-defined symbols as follows: */
builtin "0" ≔ zero;
builtin "+1" ≔ succ;

// We can make definitions as follows:
symbol ten ≔ 10;

// We can ask Lambdapi the type of a term as follows:
type ten;

// We can check that a term has a given type:
assert ⊢ ten : ℕ;

// or that a term does not have a given type:
assertnot ⊢ succ : ℕ;

symbol + : ℕ → ℕ → ℕ;
notation + infix right 10;
/* means that + is declared as infix.
"right" means that "x + y + z" is the same as "x + (y + z)".
10 is the priority level of +.
It is useful to parse expressions with various infix operators. */

symbol × : ℕ → ℕ → ℕ;
notation × infix right 20;
/* The priority level of × is higher than the one of +.
So "x + y × z" is parsed as "x + (y × z)".
We can check it as follows: */

assert x y z ⊢ x + y × z ≡ x + (y × z);
assertnot x y z ⊢ x + y × z ≡ (x + y) × z;

/* We can now tell Lambdapi to identify any term of the form "t + 0" with "t"
by simply declaring the following rewrite rule: */
rule $x + zero ↪ $x; // rule variables must be prefixed by "$"

// We can also ask Lambdapi to evaluate a term using the declared rules:
compute zero + zero;
// and check the result:
assert ⊢ zero + zero ≡ zero;
  /* ≡ is the equational theory generated by the user-defined rules
     and β-reduction + η-reduction if the flag "eta_equality" is on. */

// The definition of + can be completed by adding a new rule later:
rule $x + succ $y ↪ succ ($x + $y);

// Several rules can also be given as once as follows:
rule zero × $y ↪ zero
with succ $x × $y ↪ $y + $x × $y;

/* We now would like to prove some theorem about +. To this end, since
Lambdapi does not come with a pre-defined logic, we first need to
define what is a proposition and what is a proof. You usually just
need to import a file already doing this like
"https://github.com/fblanqui/lib/blob/master/FOL.lp". */

require tests.OK.logic;
  /* Tells Lambdapi to load in the environment the symbols, rules, etc.
  declared in the file tests/OK/logic.lp, assuming that the root_path has
  been set by a command line option or, preferably, by a lambdapi.pkg file.
  A symbol f of tests/OK/logic.lp can then be refered to
  by tests.OK.logic.f. To avoid writing tests.OK.logic, you can do: */
open tests.OK.logic;

// But we are going to redefine it here to show that it is simple.

// We first declare a type for propositions:
symbol Prop : TYPE;

// and symbols for building propositions:
symbol = : ℕ → ℕ → Prop;
notation = infix 1;

/* We then use the "proposition-as-type" technique to reduce
proof-checking to type-checking. To this end, we define a type for the
proofs of a proposition: */
injective symbol Prf : Prop → TYPE;
  /* Note that this is a type-level function, that is, a function that
     takes as argument a term of type Prop and return a term of type
     TYPE. Moreover, we declare Prf as injective. This means that Prf
     should satisfy the following property:
       if Prf(p) ≡ Prf(a) then p ≡ q.
     The verification of this property is left to the user. */

/* We then say that a proof of a proposition "p" is any term of type
"Prf(p)". We therefore need to declare axioms saying which
propositions are true. For instance, a usual axiom for equality is
that it is reflexive: */
symbol =-refl x : Prf(x = x);
  /* For all x, "=-refl x" is a proof of the proposition "x = x".
     Note by the way that Lambdapi can infer the type of "x":
     the user does not need to write "symbol =-refl (x : ℕ) : Prf(x = x)". */

/* Another usual axiom is that function application preserves equality: */
symbol =-succ x y : Prf(x = y) → Prf(succ x = succ y);

/* We also need to declare that we can prove any proposition "p" on natural
numbers by induction: */
symbol ind_ℕ (p : ℕ → Prop)
  (case-zero : Prf(p zero))
  (case-succ : Π x : ℕ, Prf(p x) → Prf(p (succ x)))
     /* While "A → B" is the Lambdapi type of functions from "A" to "B",
        "Π x : A, B" is the Lambdapi type for so-called dependent functions
        which maps x:A to some element of type B where x may occur in B.
        It boils down to "A → B" if x does not occur in B.
        Hence, case-succ is a function that takes as arguments a natural
        number x and a proof that "p x" is true, and return a proof that
        "p (succ x)" is true. */
  (n : ℕ)
  : Prf(p n);

/* We will later see that this induction principle can in fact be
automatically generated by Lambdapi by using the "inductive" command
when declaring ℕ, zero and succ. */
 
/* We are now ready to prove that, for any natural number "x", "zero +
x" is equal to "x", that is, to show that there exists a term, that we
will call "zero_is_neutral_for_+", of type "Π x : ℕ, Prf (zero + x =
x)". To this end, Lambdapi provides an interactive mode to enable
users to define this term step by step using tactics, that is launched
by the keyword "begin". */

opaque /* We declare the symbol as opaque as we do not want Lambdapi
to unfold it later. */
symbol zero_is_neutral_for_+ x : Prf (zero + x = x) ≔

begin
/* Here, in Emacs or VSCode, the system prints the following goal to prove:
?zero_is_neutral_for_+: Π x: ℕ, Prf ((zero + x) = x) */

/* To proceed by induction on x, we simply need to say that
?zero_is_neutral_for_+ should be of the form "ind_ℕ _ _ _"
where "_" stands for a term to be built.
This can be done by using the "refine" tactic: */

/* However, if we simply write "refine ind_ℕ _ _ _",
Lambdapi will complain with the following error message:
"Missing subproofs (0 subproofs for 2 subgoals)."
This is because we gave no subproof for the case-zero and case-succ arguments.
Indeed, in Lambdapi, proofs must be well structured, that is, a tactic
must be followed by as many subproofs enclosed between curly brackets
as the tactic generates subgoals. So, here, we need to write
"refine nat _ _ _ {} {}" and then write the missing subproofs.
Note however that Lambdapi could infer the predicate to prove automatically. */

/* Remark: if we hadn't declared Prf as injective, we would have gotten
  4 subgoals. the first generated subgoal would not have been a typing goal
  but the following unification goal:
  "Prf (?4 n) ≡ Prf ((zero + n) = n)"
  where "?4" stands for the unknown predicate "p" that we try to prove,
  which would have been the second goal, the third goal being the case for
  zero, and the fourth goal being the case for succ.
  This is one of the interesting features of Lambdapi to have unification
  goals. However, currently, Lambdapi has only one tactic for unification
  goals, namely "solve", which is applied automatically and thus didn't work
  here. However, we can see that, to simplify this unification goal to
  "?4 n ≡ (zero + n) = n"
  we need Prf to be injective. */

refine ind_ℕ _ _ _
  { /* Here comes the proof of the first generated subgoal:
    "Prf ((zero + zero) = zero)".
    First, we can ask Lambdapi to simplify the goal by applying
    user-defined rewriting rules with the tactic "simplify": */
    simplify;

    /* We then get the following goal:
    "Prf (zero = zero)"
    which can be solved by using =-refl: */
    refine =-refl zero;
  }
  { /* Here comes the proof of the second generated subgoal:
    "Π x: ℕ, Prf ((zero + x) = x) → Prf ((zero + succ x) = succ x)"
    We start by assuming a given x : ℕ such that "zero + x = x"
    using the tactic "assume": */
    assume x hyp_on_x;
    /* Again, we can simplify the goal: */
    simplify;
    /* We can then conclude by using the axiom =-succ and the assumption
    hyp_on_x: */
    refine =-succ (zero + x) x hyp_on_x;
    /* Alternatively, we could use the "rewrite" tactic of Lambdapi,
    to replace "zero + x" by "x", but this requires to set up a number
    of "builtins". See https://github.com/fblanqui/lib/blob/master/Eq.lp
    for some example. */
  };
end;

/* We are going to see below how this first proof can be simplified
by using more advanced features of Lambdapi. */

/* Remark: now that we proved that "zero + x" is equal to "x", we can turn
this equality into a rewrite rule to reason modulo this rule automatically. */
rule zero + $y ↪ $y;

/* First, we are now going to see that the induction principle on natural
numbers can be automatically generated by Lambdapi by using the command
"inductive", as long as the builtin "Prop" is set: */
builtin "Prop" ≔ Prop;
builtin "P" ≔ Prf;
inductive Nat : TYPE ≔ z : Nat | s : Nat → Nat;

/* To see what has been generated, you can write: */
print Nat;
/*
constant symbol Nat: TYPE 

constructors:
  z: Nat
  s: Nat → Nat

induction principle:
  ind_Nat: Π p0: (Nat → Prop), P (p0 z) → (Π x0: Nat, P (p0 x0) → P (p0 (s x0))) → Π x0: Nat, P (p0 x0)
*/
print ind_Nat;
/*
symbol ind_Nat
: Π p0: (Nat → Prop), P (p0 z) → (Π x0: Nat, P (p0 x0) → P (p0 (s x0))) → Π x0: Nat, P (p0 x0)

rules:
  ind_Nat $v0_p0 $v1_z $v2_s z ↪ $v1_z
  ind_Nat $v0_p0 $v1_z $v2_s (s $v3_x0) ↪ $v2_s $v3_x0 (ind_Nat $v0_p0 $v1_z $v2_s $v3_x0)
*/
print ten; // to see the definition of ten
print +; // to see the type, notation and rules of +

/* It is also possible now to replace the tactic "refine ind_Nat _ _ _"
by a call to the tactic "induction" (see below). */

/* Similarly, we can define a type for lists of natural numbers: */
inductive List_Nat : TYPE ≔
| nil_Nat : List_Nat
| cons_Nat : Nat → List_Nat → List_Nat;

/* But what if we want to have list of booleans, or list of list of
natural numbers, etc.? Lambdapi does not allow to quantify over
types. On the other hand, it is possible to interpret objects as types
using type-level rewriting rules, in the same way the function Prf
maps terms of type Prop to types. We can define polymorphic objects by
defining a type for type codes, and quantify over type codes instead
of types: */

symbol Set : TYPE; // type for type codes
injective symbol τ : Set → TYPE; // function interpreting type codes as types

// For instance, we can define a code for ℕ:
symbol nat : Set;
rule τ nat ↪ Nat;

// We can now define polymorphic lists as follows:

(a:Set) inductive 𝕃:TYPE ≔
| □ : 𝕃 a // \Box
| ⸬ : τ a → 𝕃 a → 𝕃 a; // ::

/* We are now going to see how to use tactics related to equality like
"reflexivity", "symmetry" and "rewrite". To this end, we need to use a
polymorphic equality and define some builtins. */

constant // means that we cannot add rules later
symbol ≃ [a] /* arguments between square brackets are implicit
and must not be written later, unless they are enclosed between square brackets
or if the symbol is prefixed by "@". */ 
: τ a → τ a → Prop;

notation ≃ infix 1;

constant symbol ≃-refl [a] (x:τ a) : Prf(x ≃ x);
constant symbol ≃-ind [a] [x y:τ a] : Prf(x ≃ y) → Π p, Prf(p y) → Prf(p x);
  // Leibniz principle.

builtin "T" ≔ τ;
builtin "eq" ≔ ≃;
builtin "refl"  ≔ ≃-refl;
builtin "eqind" ≔ ≃-ind;

/* We now reprove our theorem on the inductive type Nat instead of on ℕ,
using the tactics "induction", "reflexivity" and "rewrite".
To this end, we first need to define addition on Nat: */

symbol ⊕ : Nat → Nat → Nat;
notation ⊕ infix right 10;
rule $x ⊕ z ↪ $x
with $x ⊕ s $y ↪ s ($x ⊕ $y);

opaque symbol zero_is_neutral_for_⊕ x : Prf(z ⊕ x ≃ x) ≔
begin
induction
  { simplify; reflexivity; }
  { assume x hyp_on_x; simplify; rewrite hyp_on_x; reflexivity; }
end;
