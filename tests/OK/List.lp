/* Library on polymorphic lists

by Quentin Buzet (July 2022)

following https://github.com/math-comp/math-comp/blob/master/mathcomp/ssreflect/seq.v

seq.v documentation
-------------------

The library provides many operations. The operations are geared towards
reflection: they generally expect and provide boolean predicates.
  As there is no true subtyping, we don't use a type for non-empty
sequences; rather, we pass explicitly the head and tail of the sequence.
  The empty sequence is especially bothersome for subscripting, since it
forces us to pass a default value. This default value can often be hidden
by a notation.
  Here is the list of seq operations:
 ** Constructors:
                       seq T == the type of sequences of items of type T.
                      bitseq == seq bool.
                           â–¡ == the empty sequence (of type T).
                       x â¸¬ s == the sequence x followed by s (of type T).
                   rcons s x == the sequence s, followed by x.
All of the above, except rcons, can be used in patterns.
 ** Factories:
            nseq n x == a sequence of n x's.
         ncons n x s == a sequence of n x's, followed by s.
seqn n x_0 ... x_n-1 == the sequence of the x_i; can be partially applied.
            iota m n == the sequence m, m + 1, ..., m + n - 1.
           mkseq f n == the sequence f 0, f 1, ..., f (n - 1).
 ** Sequential access:
     head x0 s == the head (zero'th item) of s if s is non-empty, else x0.
      behead s == s minus its head, i.e., s' if s = x :: s', else â–¡.
      last x s == the last element of x :: s (which is non-empty).
    belast x s == x :: s minus its last item.
 ** Dimensions:
        size s == the number of items (length) in s.
 ** Random access:
        nth x0 s i == the item i of s (numbered from 0), or x0 if s does
                      not have at least i+1 items (i.e., size x <= i)
              s`_i == standard notation for nth x0 s i for a default x0,
                      e.g., 0 for rings.
  set_nth x0 s i y == s where item i has been changed to y; if s does not
                      have an item i, it is first padded with copies of x0
                      to size i+1.
      incr_nth s i == the nat sequence s with item i incremented (s is
                      first padded with 0's to size i+1, if needed).
 ** Predicates:
         nilp s <=> s is â–¡.
                := (size s == 0).
          x âˆˆ s == x appears in s (this requires an eqType for T).
      index x s == the first index at which x appears in s, or size s if
                   x \notin s.
        has a s <=> a holds for some item in s, where a is an applicative
                    bool predicate.
        all a s <=> a holds for all items in s.
     all2 r s t <=> the (bool) relation r holds for all _respective_ items
                   in s and t, which must also have the same size, i.e.,
                   for s := x1 â¸¬ ... â¸¬ x_m â¸¬ â–¡ and t := y1 â¸¬ ... â¸¬ y_n â¸¬ â–¡,
                   the condition [&& r x_1 y_1, ..., r x_n y_n & m == n].
       find p s == the index of the first item in s for which p holds,
                   or size s if no such item is found.
      count p s == the number of items of s for which p holds.
  count_mem x s == the multiplicity of x in s, i.e., count (pred1 x) s.
     constant s <=> all items in s are identical (trivial if s = â–¡).
         uniq s <=> all the items in s are pairwise different.
   subseq s1 s2 <=> s1 is a subsequence of s2, i.e., s1 = mask m s2 for
                   some m : bitseq (see below).
    infix s1 s2 <=> s1 is a contiguous subsequence of s2, i.e.,
                      s ++ s1 ++ s' = s2 for some sequences s, s'.
   prefix s1 s2 <=> s1 is a subchain of s2 appearing at the beginning
                      of s2.
   suffix s1 s2 <=> s1 is a subchain of s2 appearing at the end of s2.
infix_index s1 s2 <=> the first index at which s1 appears in s2,
                      or (size s2).+1 if infix s1 s2 is false.
  perm_eq s1 s2 <=> s2 is a permutation of s1, i.e., s1 and s2 have the
                   items (with the same repetitions), but possibly in a
                   different order.
 ** Filtering:
          filter p s == the subsequence of s consisting of all the items
                        for which the (boolean) predicate p holds.
             rem x s == the subsequence of s, where the first occurrence
                        of x has been removed (compare filter (predC1 x) s
                        where ALL occurrences of x are removed).
             undup s == the subsequence of s containing only the first
                        occurrence of each item in s, i.e., s with all
                        duplicates removed.
            mask m s == the subsequence of s selected by m : bitseq, with
                        item i of s selected by bit i in m (extra items or
                        bits are ignored.
 ** Surgery:
           s1 ++ s2 == the concatenation of s1 and s2.
           take n s == the sequence containing only the first n items of s
                       (or all of s if size s <= n).
           drop n s == s minus its first n items (â–¡ if size s <= n)
            rot n s == s rotated left n times (or s if size s <= n).
                    := drop n s ++ take n s
           rotr n s == s rotated right n times (or s if size s <= n).
              rev s == the (linear time) reversal of s.
 ** Iterators: for s == x_1 â¸¬ ... â¸¬ x_n â¸¬ â–¡, t == y_1 â¸¬ ... â¸¬ y_m â¸¬ â–¡,
       map f s == the sequence f x_1 â¸¬ ... â¸¬ f x_n â¸¬ â–¡.
      zip s t == itemwise pairing of s and t (dropping any extra items).
              := x_1 & y_1 â¸¬ ... â¸¬ x_mn & y_mn â¸¬ â–¡ with mn = minn n m.
     unzip1 s == x_1 .1 â¸¬ ... â¸¬ x_n .1 â¸¬ â–¡ when s : seq (S * T).
     unzip2 s == x_1 .2 â¸¬ ... â¸¬ x_n .2 â¸¬ â–¡ when s : seq (S * T).

Not available
-------------

       ohead s == None if s is empty, else Some x when the head of s is x.
      shape ss == the sequence of sizes of the items of the sequence of
                  sequences ss.
        'has_aP <-> the view reflect (exists2 x, x \in s & A x) (has a s),
                    where aP x : reflect (A x) (a x).
        'all_aP <=> the view for reflect {in s, forall x, A x} (all a s).
        tally s == a tally of s, i.e., a sequence of (item, multiplicity)
                   pairs for all items in sequence s (without duplicates).
incr_tally bs x == increment the multiplicity of x in the tally bs, or add
                   x with multiplicity 1 at then end if x is not in bs.
bs \is a wf_tally <=> bs is well-formed tally, with no duplicate items or
                   null multiplicities.
   tally_seq bs == the expansion of a tally bs into a sequence where each
                   (x, n) pair expands into a sequence of n x's.
 perm_eql s1 s2 <-> s1 and s2 behave identically on the left of perm_eq.
 perm_eqr s1 s2 <-> s1 and s2 behave identically on the right of perm_eq.
--> These left/right transitive versions of perm_eq make it easier to
 chain a sequence of equivalences.
  permutations s == a duplicate-free list of all permutations of s.
       catrev s1 s2 == the reversal of s1 followed by s2 (this is the
                       recursive form of rev).

 ** Dependent iterator: for s : seq S and t : S -> seq T
[seq E | x <- s, y <- t] := flatten [seq [seq E | x <- t] | y <- s]
               == the sequence of all the f x y, with x and y drawn from
                  s and t, respectively, in row-major order,
                  and where t is possibly dependent in elements of s
allpairs_dep f s t := self expanding definition for
                      [seq f x y | x <- s, y <- t y]
 ** Iterators: for s == x_1 â¸¬ ... â¸¬ x_n â¸¬ â–¡, t == y_1 â¸¬ ... â¸¬ y_m â¸¬ â–¡,
allpairs f s t := same as allpairs_dep but where t is non dependent,
                   i.e. self expanding definition for
                     [seq f x y | x <- s, y <- t]
              := f x_1 y_1 â¸¬ ... â¸¬ f x_1 y_m â¸¬ f x_2 y_1 â¸¬ ... â¸¬ f x_n y_m â¸¬ â–¡
allrel r xs ys := all [pred x | all (r x) ys] xs
               <=> r x y holds whenever x is in xs and y is in ys
  all2rel r xs := allrel r xs xs
               <=> the proposition r x y holds for all possible x, y in xs.
 pairwise r xs <=> the relation r holds for any i-th and j-th element of
                   xs such that i < j.
     pmap pf s == the sequence y_i1 â¸¬ ... â¸¬ y_ik â¸¬ â–¡ where i1 < ... < ik,
                  pf x_i = Some y_i, and pf x_j = None iff j is not in
                  {i1, ..., ik}.
  foldr f a s == the right fold of s by f (i.e., the natural iterator).
              := f x_1 (f x_2 ... (f x_n a))
       sumn s == x_1 + (x_2 + ... + (x_n + 0)) (when s : seq nat).
  foldl f a s == the left fold of s by f.
              := f (f ... (f a x_1) ... x_n-1) x_n
  scanl f a s == the sequence of partial accumulators of foldl f a s.
              := f a x_1 â¸¬ ... â¸¬ foldl f a s
pairmap f a s == the sequence of f applied to consecutive items in a :: s.
              := f a x_1 â¸¬ f x_1 x_2 â¸¬ ... â¸¬ f x_n-1 x_n â¸¬ â–¡
    flatten s == x_1 ++ ... ++ x_n when s : seq (seq T).
  reshape r s == s reshaped into a sequence of sequences whose sizes are
                 given by r (truncating if s is too long or too short).
              :=   (x_1 â¸¬ ... â¸¬ x_r1 â¸¬ â–¡)
                 â¸¬ (x_(r1 + 1) â¸¬ ... â¸¬ x_(r0 + r1) â¸¬ â–¡)
                 â¸¬ ...
                 â¸¬ (x_(r1 + ... + r(k-1) + 1) â¸¬ ... â¸¬ x_(r0 + ... rk) â¸¬ â–¡)
flatten_index sh r c == the index, in flatten ss, of the item of indexes
                 (r, c) in any sequence of sequences ss of shape sh
              := sh_1 + sh_2 + ... + sh_r + c
reshape_index sh i == the index, in reshape sh s, of the sequence
                 containing the i-th item of s.
reshape_offset sh i == the offset, in the (reshape_index sh i)-th
                 sequence of reshape sh s of the i-th item of s
 ** Notation for manifest comprehensions:
        [seq x <- s | C] := filter (fun x => C) s.
        [seq E | x <- s] := map (fun x => E) s.
  [seq x <- s | C1 & C2] := [seq x <- s | C1 && C2].
    [seq E | x <- s & C] := [seq E | x <- [seq x | C]].
 --> The above allow optional type casts on the eigenvariables, as in
 [seq x : T <- s | C] or [seq E | x : T <- s, y : U <- t]. The cast may be
 needed as type inference considers E or C before s.
  We are quite systematic in providing lemmas to rewrite any composition
of two operations. "rev", whose simplifications are not natural, is
protected with nosimpl.
 ** The following are equivalent:
 [<-> P0; P1; ..; Pn] <-> P0, P1, ..., Pn are all equivalent.
                      := P0 -> P1 -> ... -> Pn -> P0
 if T : [<-> P0; P1; ..; Pn]  is such an equivalence, and i, j are in nat
 then T i j is a proof of the equivalence Pi <-> Pj between Pi and Pj;
 when i (resp. j) is out of bounds, Pi (resp. Pj) defaults to P0.
 The tactic tfae splits the goal into n+1 implications to prove.
 An example of use can be found in fingraph theorem orbitPcycle.
*/

require open tests.OK.Set tests.OK.Prop tests.OK.FOL tests.OK.Eq
  tests.OK.Nat tests.OK.Bool;

(a:Set) inductive ğ•ƒ:TYPE â‰”
| â–¡ : ğ•ƒ a // \Box
| â¸¬ : Ï„ a â†’ ğ•ƒ a â†’ ğ•ƒ a; // ::

notation â¸¬ infix right 20;

// set code for ğ•ƒ

constant symbol list : Set â†’ Set;

rule Ï„ (list $a) â†ª ğ•ƒ $a;

// isâ–¡

symbol isâ–¡ [a]: ğ•ƒ a â†’ ğ”¹;

rule isâ–¡ â–¡ â†ª true
with isâ–¡ (_ â¸¬ _) â†ª false;

// non confusion of constructors

opaque symbol â¸¬â‰ â–¡ [a] [x:Ï„ a] [l] : Ï€ (x â¸¬ l â‰  â–¡) â‰”
begin
  assume a x l h; refine ind_eq h (Î» l, istrue(isâ–¡ l)) âŠ¤áµ¢
end;

opaque symbol â–¡â‰ â¸¬ [a] [x:Ï„ a] [l] : Ï€ (â–¡ â‰  x â¸¬ l) â‰”
begin
  assume a x l h; apply @â¸¬â‰ â–¡ a x l; symmetry; apply h
end;

// head

symbol head [a] : Ï„ a â†’ ğ•ƒ a â†’ Ï„ a;

rule head $x â–¡ â†ª $x
with head _ ($x â¸¬ _) â†ª $x;

// tail

symbol behead [a] : ğ•ƒ a â†’ ğ•ƒ a;

rule behead â–¡ â†ª â–¡
with behead (_ â¸¬ $l) â†ª $l;

// injectivity of constructors

opaque symbol â¸¬_inj [a] [x:Ï„ a] [l y m] : Ï€(x â¸¬ l = y â¸¬ m) â†’ Ï€(x = y âˆ§ l = m) â‰”
begin
  assume a x l y m e; apply âˆ§áµ¢ { refine feq (head x) e } { refine feq behead e }
end;

// boolean equality on lists

symbol eql [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;

rule eql _ â–¡ â–¡ â†ª true
with eql _ (_ â¸¬ _) â–¡ â†ª false
with eql _ â–¡ (_ â¸¬ _) â†ª false
with eql $beq ($x â¸¬ $l) ($y â¸¬ $m) â†ª ($beq $x $y) and (eql $beq $l $m);

opaque symbol eql_correct a (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) :
  Ï€(`âˆ€ x, `âˆ€ y, beq x y â‡’ x = y) â†’ Ï€(`âˆ€ l, `âˆ€ m, eql beq l m â‡’ l = m) â‰”
begin
  assume a beq beq_correct; induction
  { induction
    { reflexivity }
    { simplify; assume y m i c; refine âŠ¥â‚‘ c }
  }
  { assume x l h; induction
    { simplify; assume c; refine âŠ¥â‚‘ c; }
    { simplify; assume y m i c;
      apply feq2 (â¸¬) _ _
      { apply beq_correct; apply @andâ‚‘â‚ _ (eql beq l m) c }
      { apply h; refine @andâ‚‘â‚‚ (beq x y) _ c
      } 
    }
  }
end;

opaque symbol eql_complete a (beq : Ï„ a â†’ Ï„ a â†’ ğ”¹) :
  Ï€(`âˆ€ x, `âˆ€ y, x = y â‡’ beq x y) â†’ Ï€(`âˆ€ l, `âˆ€ m, l = m â‡’ eql beq l m) â‰”
begin
  assume a beq beq_complete; induction
  { assume m i; rewrite left i; apply âŠ¤áµ¢; }
  { assume x l h; induction
    { assume j; apply â¸¬â‰ â–¡ j; }
    { assume y m i j; simplify;
      have j': Ï€(x = y âˆ§ l = m) { apply â¸¬_inj j };
      apply @istrue_and (beq x y) (eql beq l m); apply âˆ§áµ¢
      { apply beq_complete x y; apply âˆ§â‚‘â‚ j' }
      { apply h m; apply âˆ§â‚‘â‚‚ j' }
    }
  }
end;

// size

symbol size [a] : ğ•ƒ a â†’ â„•;

rule size â–¡ â†ª 0
with size (_ â¸¬ $l) â†ª size $l +1;

opaque symbol size0nil [a] (l:ğ•ƒ a) : Ï€ (size l = 0) â†’ Ï€ (l = â–¡) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h i; apply âŠ¥â‚‘; apply sâ‰ 0 i; }
end;

symbol nilp [a] l â‰” is0 (@size a l);

opaque symbol size_behead [a] (l:ğ•ƒ a) : Ï€ (size (behead l) = size l âˆ¸1) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h; reflexivity; }
end;

// concatenation

symbol ++ [a] : ğ•ƒ a â†’ ğ•ƒ a â†’ ğ•ƒ a; notation ++ infix right 30; // \cdot

assert x y z âŠ¢ x ++ y ++ z â‰¡ x ++ (y ++ z);
assert x l m âŠ¢ x â¸¬ l ++ m â‰¡ x â¸¬ (l ++ m);

rule â–¡ ++ $m â†ª $m
with ($x â¸¬ $l) ++ $m â†ª $x â¸¬ ($l ++ $m);

opaque symbol cat0s [a] (l:ğ•ƒ a) : Ï€ (â–¡ ++ l = l) â‰”
begin
  reflexivity;
end;

opaque symbol cat1s [a] (x:Ï„ a) l : Ï€ ((x â¸¬ â–¡) ++ l = (x â¸¬ l)) â‰”
begin
  reflexivity;
end;

opaque symbol cat_cons [a] (x:Ï„ a) l1 l2 : Ï€ ((x â¸¬ l1) ++ l2 = x â¸¬ (l1 ++ l2)) â‰”
begin
  reflexivity;
end;

// nseq

symbol nseq [a] : â„• â†’ Ï„ a â†’ ğ•ƒ a;

rule nseq 0 _ â†ª â–¡
with nseq ($n +1) $x â†ª $x â¸¬ (nseq $n $x);

// ncons

symbol ncons [a] : â„• â†’ Ï„ a â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule ncons 0 _ $l â†ª $l
with ncons ($n +1) $x $l â†ª $x â¸¬ ncons $n $x $l;

opaque symbol size_ncons [a] n (x:Ï„ a) l : Ï€ (size (ncons n x l) = n + size l) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n h x l; simplify; apply feq (+1) (h x l); }
end;

opaque symbol size_nseq [a] n (x:Ï„ a) : Ï€ (size (nseq n x) = n) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n h x; simplify; apply feq (+1) (h x); }
end;

opaque symbol cat_nseq [a] n (x:Ï„ a) l : Ï€ (nseq n x ++ l = ncons n x l) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n h x l; simplify; rewrite h x l; reflexivity; }
end;

opaque symbol nseqD [a] n1 n2 (x:Ï„ a) :
  Ï€ (nseq (n1 + n2) x = nseq n1 x ++ nseq n2 x) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n1 h n2 x; simplify; rewrite h n2; reflexivity; }
end;

opaque symbol cats0 [a] (l:ğ•ƒ a) : Ï€(l ++ â–¡ = l) â‰”
begin
  assume a;
  induction
    // case l = â–¡
    { reflexivity; }
    // case l = x â¸¬ l'
    { assume x l' h; simplify; rewrite h; reflexivity; }
end;

rule $m ++ â–¡ â†ª $m;

opaque symbol size_cat [a] (l m : ğ•ƒ a) : Ï€(size (l ++ m) = size l + size m) â‰”
begin
  assume a;
  induction
    // case l = â–¡
    { reflexivity; }
    // case l = xâ¸¬l'
    { assume x l' h m; simplify; rewrite h; reflexivity; }
end;

rule size ($l ++ $m) â†ª size $l + size $m;

opaque symbol catA  [a] (l m n : ğ•ƒ a) : Ï€((l ++ m) ++ n = l ++ (m ++ n)) â‰”
begin
  assume a;
  induction
    // case l = â–¡
    { reflexivity; }
    // case l = xâ¸¬l'
    { assume x l' h m n; simplify; rewrite h; reflexivity; }
end;

rule ($l ++ $m) ++ $n â†ª $l ++ ($m ++ $n);

opaque symbol cat_nilp [a] (l1 l2 : ğ•ƒ a) :
  Ï€ (nilp (l1 ++ l2) = (nilp l1 and nilp l2)) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h l2; simplify; reflexivity; }
end;

// list reversal

symbol rev [a] : ğ•ƒ a â†’ ğ•ƒ a;

rule rev â–¡ â†ª â–¡
with rev ($x â¸¬ $l) â†ª rev $l ++ ($x â¸¬ â–¡);

opaque symbol rev_concat [a] (l m : ğ•ƒ a) : Ï€(rev (l ++ m) = rev m ++ rev l) â‰”
begin
  assume a;
  induction
    // case l = â–¡
    { simplify; reflexivity; }
    // case l = â¸¬
    { assume x l h m; simplify; rewrite h; reflexivity; }
end;

rule rev ($l ++ $m) â†ª rev $m ++ rev $l;

opaque symbol rev_idem [a] (l :ğ•ƒ a) : Ï€(rev (rev l) = l) â‰”
begin
  assume a; induction
  { reflexivity }
  { assume x l h; simplify; rewrite h; reflexivity }
end;

opaque symbol size_rev [a] (l : ğ•ƒ a) : Ï€(size (rev l) = size l) â‰”
begin
  assume a;
  induction
    // case l = â–¡
    { simplify; reflexivity; }
    // case l = â¸¬
    { assume x l h; simplify; rewrite h; reflexivity; }
end;

// rcons

symbol rcons [a] : ğ•ƒ a â†’ Ï„ a â†’ ğ•ƒ a;

rule rcons â–¡ $x â†ª $x â¸¬ â–¡
with rcons ($e â¸¬ $l) $x â†ª $e â¸¬ (rcons $l $x);

opaque symbol cats1 [a] (l:ğ•ƒ a) (z:Ï„ a) : Ï€ (l ++ (z â¸¬ â–¡) = rcons l z) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h z; simplify; rewrite h z; reflexivity; }
end;

opaque symbol rcons_cons [a] (x:Ï„ a) (s:ğ•ƒ a) (z:Ï„ a) :
  Ï€ (rcons (x â¸¬ s) z = x â¸¬ rcons s z) â‰”
begin
  reflexivity;
end;

// Arr

symbol Arr : â„• â†’ Set â†’ Set â†’ TYPE;

rule Arr 0 _ $b â†ª Ï„ $b
with Arr ($n +1) $a $b â†ª Ï„ $a â†’ Arr $n $a $b;

// seqn

symbol seqn_acc [a] n : ğ•ƒ a â†’ Arr n a (list a);

rule seqn_acc 0 $l â†ª rev $l
with seqn_acc ($n +1) $l $x â†ª seqn_acc $n ($x â¸¬ $l);

symbol seqn [a] n â‰” @seqn_acc a n â–¡;

assert a (x y : Ï„ a) âŠ¢ seqn 2 x y â‰¡ x â¸¬ y â¸¬ â–¡;

// iota

symbol iota : â„• â†’ â„• â†’ ğ•ƒ nat;
rule iota _ 0 â†ª â–¡
with iota $n ($k +1) â†ª $n â¸¬ iota ($n +1) $k;

assert âŠ¢ iota 1 2 â‰¡ 1 â¸¬ 2 â¸¬ â–¡;

// indexes

symbol indexes [a] : ğ•ƒ a â†’ ğ•ƒ nat;

rule indexes $l â†ª iota 0 (size $l);

assert x âŠ¢ indexes (x â¸¬ x â¸¬ x  â¸¬ x â¸¬ â–¡) â‰¡ 0 â¸¬ 1 â¸¬ 2 â¸¬ 3 â¸¬ â–¡;

// last

symbol last [a] : Ï„ a â†’ ğ•ƒ a â†’ Ï„ a;

rule last $x â–¡ â†ª $x
with last _ ($e â¸¬ $l) â†ª last $e $l;

assert âŠ¢ last 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) â‰¡ 1;
assert âŠ¢ last 4 â–¡ â‰¡ 4;

// belast

symbol belast [a] : Ï„ a â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule belast _ â–¡ â†ª â–¡
with belast $x ($e â¸¬ $l) â†ª $x â¸¬ belast $e $l;

assert âŠ¢ belast 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) â‰¡ 4 â¸¬ 3 â¸¬ 2 â¸¬ â–¡;

// nth

symbol nth [a] : Ï„ a â†’ ğ•ƒ a â†’ â„• â†’ Ï„ a;

rule nth $x â–¡ _ â†ª $x
with nth _ ($e â¸¬ _) 0 â†ª $e
with nth $x (_ â¸¬ $l) ($n +1) â†ª nth $x $l $n;

assert âŠ¢ nth 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 0 â‰¡ 3;
assert âŠ¢ nth 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 2 â‰¡ 1;
assert âŠ¢ nth 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 3 â‰¡ 4;
assert âŠ¢ nth 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 42 â‰¡ 4;

// set_nth

symbol set_nth [a] : Ï„ a â†’ ğ•ƒ a â†’ â„• â†’ Ï„ a â†’ ğ•ƒ a;

rule set_nth _ â–¡ 0 $y â†ª $y â¸¬ â–¡
with set_nth _ (_ â¸¬ $l) 0 $y â†ª $y â¸¬ $l
with set_nth $x â–¡ ($i +1) $y â†ª $x â¸¬ set_nth $x â–¡ $i $y
with set_nth $x ($e â¸¬ $l) ($i +1) $y â†ª $e â¸¬ set_nth $x $l $i $y;

assert âŠ¢ set_nth 42 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 1 6 â‰¡ 3 â¸¬ 6 â¸¬ 1 â¸¬ â–¡;
assert âŠ¢ set_nth 42 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 2 6 â‰¡ 3 â¸¬ 2 â¸¬ 6 â¸¬ â–¡;
assert âŠ¢ set_nth 42 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 5 6 â‰¡ 3 â¸¬ 2 â¸¬ 1 â¸¬ 42 â¸¬ 42 â¸¬ 6 â¸¬ â–¡;

// incr_nth

symbol incr_nth : ğ•ƒ nat â†’ Ï„ nat â†’ ğ•ƒ nat;

rule incr_nth â–¡ 0 â†ª 1 â¸¬ â–¡
with incr_nth â–¡ ($i +1) â†ª 0 â¸¬ incr_nth â–¡ $i
with incr_nth ($n â¸¬ $l) 0 â†ª $n +1 â¸¬ $l
with incr_nth ($n â¸¬ $l) ($i +1) â†ª $n â¸¬ incr_nth $l $i;

assert âŠ¢ incr_nth (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 1 â‰¡ 3 â¸¬ 3 â¸¬ 1 â¸¬ â–¡;
assert âŠ¢ incr_nth (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 2 â‰¡ 3 â¸¬ 2 â¸¬ 2 â¸¬ â–¡;
assert âŠ¢ incr_nth (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 5 â‰¡ 3 â¸¬ 2 â¸¬ 1 â¸¬ 0 â¸¬ 0 â¸¬ 1 â¸¬ â–¡;

// zip 

symbol zip [a b] : ğ•ƒ a â†’ ğ•ƒ b â†’ ğ•ƒ (a Ã— b);

rule zip â–¡ â–¡ â†ª â–¡
with zip â–¡ _ â†ª â–¡
with zip _ â–¡ â†ª â–¡
with zip ($x â¸¬ $l) ($y â¸¬ $m) â†ª $x & $y â¸¬ zip $l $m;

symbol unzip1 [a b] : ğ•ƒ (a Ã— b) â†’ ğ•ƒ a;

rule unzip1 â–¡  â†ª â–¡
with unzip1 ($x & _ â¸¬ $l) â†ª $x â¸¬ unzip1 $l;

symbol unzip2 [a b] : ğ•ƒ (a Ã— b) â†’ ğ•ƒ b;

rule unzip2 â–¡ â†ª â–¡
with unzip2 (_ & $y â¸¬ $l) â†ª $y â¸¬ unzip2 $l;

assert âŠ¢ unzip1 ((3 & 5) â¸¬ (6 & 4) â¸¬ (7 & 2) â¸¬ (8 & 1) â¸¬ â–¡) â‰¡ 3 â¸¬ 6 â¸¬ 7 â¸¬ 8 â¸¬ â–¡;
assert âŠ¢ unzip2 ((3 & 5) â¸¬ (6 & 4) â¸¬ (7 & 2) â¸¬ (8 & 1) â¸¬ â–¡) â‰¡ 5 â¸¬ 4 â¸¬ 2 â¸¬ 1 â¸¬ â–¡;

symbol all2 [a b] : (Ï„ a â†’ Ï„ b â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ b â†’ ğ”¹;

rule all2 _ â–¡ â–¡ â†ª true
with all2 $p ($x â¸¬ $l) ($y â¸¬ $m) â†ª ($p $x $y) and (all2 $p $l $m);

opaque symbol unzip1_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) :
  Ï€ (size la â‰¤ size lb) â†’ Ï€ (unzip1 (zip la lb) = la) â‰”
begin
  assume a b; induction
  { reflexivity; }
  { assume ea la h; induction
    { assume i; apply âŠ¥â‚‘ i; }
    { assume eb lb i j; apply feq (Î» l, ea â¸¬ l) (h lb j); }
  }
end;

opaque symbol unzip2_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) :
  Ï€ (size lb â‰¤ size la) â†’ Ï€ (unzip2 (zip la lb) = lb) â‰”
begin
  assume a b; induction
  { assume lb h;
     have t:Ï€ (size lb = 0) { apply â‰¤0 (size lb) h; };
     symmetry; apply size0nil lb t; }
  { assume ea la h; induction
    { reflexivity; }
    { assume eb lb i j; apply feq (Î» l, eb â¸¬ l) (h lb j); }
  }
end;

opaque symbol size1_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) :
  Ï€ (size la â‰¤ size lb) â†’ Ï€ (size (zip la lb) = size la) â‰”
begin
  assume a b; induction
  { reflexivity; }
  { assume ea la h; induction
    { assume i; apply âŠ¥â‚‘ i; }
    { assume eb lb i j; apply feq (+1) (h lb j); }
  }
end;

opaque symbol size2_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) :
  Ï€ (size lb â‰¤ size la) â†’ Ï€ (size (zip la lb) = size lb) â‰”
begin
  assume a b; induction
  { assume lb h; symmetry; apply â‰¤0 (size lb) h; }
  { assume ea la h; induction
    { reflexivity; }
    { assume eb lb i j; apply feq (+1) (h lb j); }
  }
end;

opaque symbol size_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) :
  Ï€ (size (zip la lb) = min (size la) (size lb)) â‰”
begin
  assume a b; induction
  { reflexivity }
  { assume ea la h; induction
    { reflexivity; }
    { assume eb lb i; simplify; apply feq (+1) (h lb); }
  }
end;

// double induction

opaque symbol seq_ind2 [a b] (p:ğ•ƒ a â†’ ğ•ƒ b â†’ Prop) :
  Ï€ (p â–¡ â–¡) â†’
  (Î  la lb ea eb, Ï€(size la = size lb) â†’ Ï€(p la lb) â†’ Ï€(p (ea â¸¬ la) (eb â¸¬ lb)))
  â†’ Î  la lb, Ï€(size la = size lb) â†’ Ï€(p la lb) â‰”
begin
  assume a b p p0 pH; induction
  { induction
    { assume h; apply p0; }
    { assume eb lb h1 h2; apply âŠ¥â‚‘; apply sâ‰ 0 [size lb]; symmetry; apply h2 }
  }
  { assume ea la h; induction
    { assume i; apply âŠ¥â‚‘ (sâ‰ 0 i); }
    { assume eb lb i j;
      have t:Ï€ (size la = size lb) { apply +1_inj j; };
      apply pH la lb ea eb t (h lb t); }
  }
end;

opaque symbol zip_cat [a b] (la sa:ğ•ƒ a) (lb sb:ğ•ƒ b) :
  Ï€ (size la = size lb) â†’ Ï€ (zip (la ++ sa) (lb ++ sb) = zip la lb ++ zip sa sb) â‰”
begin
  assume a b la sa lb sb h;
  apply @seq_ind2 a b (Î» l1 l2, (zip (l1 ++ sa) (l2 ++ sb) = zip l1 l2 ++ zip sa sb)) _ _ la lb h {
    reflexivity;
  } {
    assume l1 l2 e1 e2 h1 h2; simplify; apply feq (Î» l, e1 & e2 â¸¬ l) h2; 
  };
end;

opaque symbol nth_zip [a b] (x:Ï„ a) (y:Ï„ b) la lb i: Ï€(size la = size lb) â†’
  Ï€(nth (x & y) (zip la lb) i = nth x la i & nth y lb i) â‰”
begin
  assume a b x y; induction
  { assume lb i h;
    have t: Ï€ (lb = â–¡) { apply size0nil lb; symmetry; apply h; };
    rewrite t; reflexivity; }
  { assume ea la h; induction
    { assume i j; apply âŠ¥â‚‘ (sâ‰ 0 j); }
    { assume eb lb k; induction
      { assume m; reflexivity; }
      { assume i m n; refine h lb i _; apply +1_inj n; }
    }
  }
end;

opaque symbol rev_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) :
  Ï€ (size la = size lb) â†’ Ï€ (rev (zip la lb) = zip (rev la) (rev lb)) â‰”
begin
  assume a b la lb h;
  apply seq_ind2 (Î» l1 l2, rev (zip l1 l2) = zip (rev l1) (rev l2)) _ _ la lb h {
    reflexivity;
  } {
    assume l1 l2 e1 e2 i j; simplify;
    have i': Ï€(size(rev l1) = size(rev l2))
      { rewrite @size_rev; rewrite @size_rev; apply i}; 
    rewrite zip_cat (rev l1) (e1 â¸¬ â–¡) (rev l2) (e2 â¸¬ â–¡) i';
    rewrite left j; reflexivity;
  };
end;

// drop

symbol drop [a] : â„• â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule drop 0 $l â†ª $l
with drop _ â–¡ â†ª â–¡
with drop ($n +1) (_ â¸¬ $l) â†ª drop $n $l;

assert âŠ¢ drop 3 (7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡) â‰¡ 1 â¸¬ 41 â¸¬ â–¡;
assert âŠ¢ drop 10 (7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡) â‰¡ â–¡;

opaque symbol drop0 [a] (l:ğ•ƒ a) : Ï€ (drop 0 l = l) â‰”
begin
  reflexivity;
end;

opaque symbol drop_oversize [a] n (l:ğ•ƒ a) : Ï€ (size l â‰¤ n) â†’ Ï€ (drop n l = â–¡) â‰”
begin
  assume a; induction
  { assume l h; 
    have t:Ï€ (size l = 0) { apply â‰¤0 (size l) h;};
    simplify; apply size0nil l t;
  }
  {
    assume n h; induction
    { reflexivity; }
    { assume e l i; refine h l; }
  }
end;

opaque symbol drop_size [a] (l:ğ•ƒ a) : Ï€ (drop (size l) l = â–¡) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h; simplify; apply h; }
end;

opaque symbol drop_cons [a] (e:Ï„ a) l n : Ï€ (drop (n +1) (e â¸¬ l) = drop n l) â‰”
begin
  assume a e l n; reflexivity;
end;

opaque symbol size_drop [a] (l:ğ•ƒ a) n : Ï€ (size (drop n l) = size l - n) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h; simplify; induction
    { reflexivity; }
    { assume n i; simplify; apply h n; } 
  }
end;

opaque symbol size_cons [a] (e:Ï„ a) n l : Ï€ (size l = n â‡” size (e â¸¬ l) = n +1) â‰”
begin
  assume a e n l; apply âˆ§áµ¢ {
    generalize n; induction
    { assume l h; simplify; rewrite h; reflexivity; }
    { assume n h l i; simplify; apply feq (+1) i;}
  } {
    generalize n; induction
    { assume l i; apply +1_inj i;}
    { assume n h l i; apply +1_inj i; }
  };
end;

opaque symbol drop_size_cat [a] n (l1 l2:ğ•ƒ a) :
  Ï€ (size l1 = n) â†’ Ï€ (drop n (l1 ++ l2) = l2) â‰”
begin
  assume a; induction
  { assume l1 l2 h; simplify;
    have t:Ï€ (l1 = â–¡) { apply size0nil l1 h }; rewrite t; reflexivity; }
  { assume n h; induction
    { assume l2 i; apply âŠ¥â‚‘; apply sâ‰ 0 [n]; symmetry; apply i; }
    { assume e l1 i l2 j; apply h l1 l2; apply +1_inj j; }
  }
end;

opaque symbol drop_drop [a] (l:ğ•ƒ a) n1 n2 :
  Ï€ (drop n1 (drop n2 l) = drop (n1 + n2) l) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h n1; induction
    { reflexivity; }
    { assume n2 i; simplify; apply h n1 n2; }
  }
end;

// take

symbol take [a] : â„• â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule take 0 _ â†ª â–¡
with take _ â–¡ â†ª â–¡
with take ($n +1) ($x â¸¬ $l) â†ª $x â¸¬ (take $n $l);

assert âŠ¢ take 3 (7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡) â‰¡ 7 â¸¬ 2 â¸¬ 3 â¸¬ â–¡;
assert âŠ¢ take 10 (7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡) â‰¡ 7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡;

opaque symbol take0 [a] (l: ğ•ƒ a) : Ï€ (take 0 l = â–¡) â‰”
begin
  reflexivity;
end;

opaque symbol take_cons [a] n (x:Ï„ a) l :
  Ï€ (take (n +1) (x â¸¬ l) = (x â¸¬ take n l)) â‰”
begin
  assume a l; reflexivity;
end;

opaque symbol take_size [a] (l: ğ•ƒ a) : Ï€ (take (size l) l = l) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h; simplify; rewrite h; reflexivity; }
end;

opaque symbol take_oversize [a] n (l:ğ•ƒ a) : Ï€ (size l â‰¤ n) â†’ Ï€ (take n l = l) â‰”
begin
  assume a; induction
  { assume l h; simplify; symmetry; apply size0nil l; apply â‰¤0 (size l) h; }
  { assume n h; induction
    { reflexivity; }
    { assume e l i; simplify; assume j; rewrite h l j; reflexivity; }
  }
end;

opaque symbol cat_take_drop [a] n (l:ğ•ƒ a) : Ï€ (take n l ++ drop n l = l) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n h; induction
    { reflexivity; }
    { assume e l i; simplify; rewrite h l; reflexivity; }
  }
end;

opaque symbol size_takel [a] n (l:ğ•ƒ a) :
  Ï€ (n â‰¤ size l) â†’ Ï€ (size (take n l) = n) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n h; induction
    { simplify; assume i; apply âŠ¥â‚‘ i; }
    { assume e l i; simplify; assume j; apply feq (+1); apply h l j; }
  }
end;

opaque symbol size_take [a] n (l:ğ•ƒ a) :
  Ï€ (size (take n l) = if (n < size l) n (size l)) â‰”
begin
abort;

opaque symbol size_take_min [a] n (l:ğ•ƒ a) :
  Ï€ (size (take n l) = min n (size l)) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n h; induction
    { reflexivity; }
    { assume e l i; simplify; apply feq (+1) (h l); }
  }
end;

opaque symbol take_size_cat [a] n (l1 l2:ğ•ƒ a) :
  Ï€ (size l1 = n) â†’ Ï€ (take n (l1 ++ l2) = l1) â‰”
begin
  assume a; induction
  { assume l1 l2 h; simplify; symmetry; apply size0nil l1 h; }
  { assume n h; induction
    { assume l2 i; apply âŠ¥â‚‘; apply sâ‰ 0 [n]; symmetry; apply i; }
    { assume e1 l1 i l2 j; simplify; apply feq (Î» l, e1 â¸¬ l);
      apply h l1 l2; apply âˆ§â‚‘â‚‚ (size_cons e1 n l1) j; 
    }
  }
end;

opaque symbol takel_cat [a] (l1 l2:ğ•ƒ a) n :
  Ï€ (n â‰¤ size l1) â†’ Ï€ (take n (l1 ++ l2) = take n l1) â‰”
begin
  assume a; induction
  { assume l2 n h; have t:Ï€ (n = 0) { apply â‰¤0 n h }; rewrite t; reflexivity; }
  { assume e1 l1 h l2; induction
    { reflexivity; }
    { assume n i j; apply feq (Î» l:ğ•ƒ a, e1 â¸¬ l); apply h l2 n j; }
  }
end;

opaque symbol take_drop [a] m n (l:ğ•ƒ a):
  Ï€ (take m (drop n l) = drop n (take (m + n) l)) â‰”
begin
  assume a; induction
  { induction
    { reflexivity; }
    { assume m h; induction
      { reflexivity; }
      { assume e l i; simplify; rewrite left .[m in take m l] add0n m;
        rewrite left h l; reflexivity; }
    }
  }
  { assume n h; induction
    { reflexivity; }
    { assume m i; induction
      { reflexivity; }
      { assume e l j; refine i l; }
    }
  }
end;

opaque symbol takeD [a] m n (l:ğ•ƒ a) :
  Ï€ (take (m + n) l = take m l ++ take n (drop m l)) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume m h; induction
    { reflexivity; }
    { assume n i; induction
      { reflexivity; }
      { assume e l j; simplify; apply feq (Î» l:ğ•ƒ a, e â¸¬ l);
        rewrite left addnS; apply h (n +1) l; }
    }
  }
end;

opaque symbol takeC [a] (l:ğ•ƒ a) i j:
  Ï€ (take i (take j l) = take j (take i l)) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h; induction
    { reflexivity; }
    { assume i h2; induction
      { reflexivity; }
      { assume j h3; simplify; rewrite h i j; reflexivity; }
    }
  }
end;

// rot

symbol rot [a] n (l:ğ•ƒ a) â‰” drop n l ++ take n l;

assert âŠ¢ rot 2 (7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡) â‰¡ 3 â¸¬ 1 â¸¬ 41 â¸¬ 7 â¸¬ 2 â¸¬ â–¡;

opaque symbol Ï€_rot [a] n (l:ğ•ƒ a) : Ï€ (drop n l ++ take n l = rot n l) â‰”
begin
  reflexivity;
end;

opaque symbol rot0 [a] (l:ğ•ƒ a) : Ï€ (rot 0 l = l) â‰”
begin
  reflexivity;
end;

opaque symbol size_rot [a] (l:ğ•ƒ a) n0 : Ï€ (size (rot n0 l) = size l) â‰”
begin
  assume a l n0; simplify; rewrite addnC;
  rewrite left @size_cat a (take n0 l) (drop n0 l);
  rewrite cat_take_drop n0 l; reflexivity; 
end;

opaque symbol rot_oversize [a] n (l:ğ•ƒ a) : Ï€ (size l â‰¤ n) â†’ Ï€ (rot n l = l) â‰”
begin
  assume a n l h; simplify; rewrite drop_oversize n l h;
  rewrite take_oversize n l h; reflexivity;
end;

opaque symbol rot_size [a] (l:ğ•ƒ a) : Ï€ (rot (size l) l = l) â‰”
begin
  assume a l; simplify; rewrite take_size l; rewrite @drop_size a; reflexivity;
end;

opaque symbol rot_size_cat [a] (l1 l2:ğ•ƒ a) :
  Ï€ (rot (size l1) (l1 ++ l2) = l2 ++ l1) â‰”
begin
  assume a l1 l2; simplify; 
  rewrite drop_size_cat (size l1) l1 l2 (eq_refl (size l1));
  rewrite take_size_cat (size l1) l1 l2 (eq_refl (size l1));
  reflexivity;
end;

opaque symbol take_take [a] n m :
  Ï€ (n â‰¤ m) â†’ Ï€ (`âˆ€ l:ğ•ƒ a, take n (take m l) = take n l) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n h; induction
    { assume i; apply âŠ¥â‚‘ i; }
    { assume m i j; induction
      { reflexivity; }
      { assume e l k; simplify; apply feq (Î» l:ğ•ƒ a, e â¸¬ l) (h m j l); }
    }
  }
end;

// rotr

symbol rotr [a] n (l:ğ•ƒ a) â‰” rot (size l - n) l;

assert âŠ¢ rotr 2 (7 â¸¬ 2 â¸¬ 3 â¸¬ 1 â¸¬ 41 â¸¬ â–¡) â‰¡ 1 â¸¬ 41 â¸¬ 7 â¸¬ 2 â¸¬ 3 â¸¬ â–¡;

opaque symbol Ï€_rotr [a] n (l:ğ•ƒ a) :
  Ï€ (drop (size l - n) l ++ take (size l - n) l = rotr n l) â‰”
begin
  reflexivity;
end;

opaque symbol rotr0 [a] (l:ğ•ƒ a) : Ï€ (rotr 0 l = l) â‰”
begin
  assume a l; simplify; rewrite take_size l; rewrite @drop_size a; reflexivity;
end;

opaque symbol rotK [a] n (l:ğ•ƒ a) : Ï€ (rot n (rotr n l) = l) â‰”
begin
abort;

opaque symbol rot_inj [a] n (l1 l2:ğ•ƒ a) :
  Ï€ (rot n l1 = rot n l2) â†’ Ï€ (l1 = l2) â‰”
begin
abort;

// membership

symbol âˆˆ [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ Ï„ a â†’ ğ•ƒ a â†’ ğ”¹;

rule âˆˆ _ _ â–¡ â†ª false
with âˆˆ $beq $x ($y â¸¬ $l) â†ª $beq $x $y or âˆˆ $beq $x $l;

opaque symbol in_cons [a] beq (x y:Ï„ a) l :
  Ï€ (âˆˆ beq x (y â¸¬ l) = beq x y or âˆˆ beq x l) â‰”
begin
  assume a beq x y; induction
  { reflexivity; }
  { assume e l h; reflexivity; }
end;

opaque symbol in_nil [a] beq (x:Ï„ a) : Ï€ (âˆˆ beq x â–¡ = false) â‰”
begin
  assume a beq x; reflexivity;
end;

opaque symbol mem_seq1 [a] beq (x y:Ï„ a) : Ï€ (âˆˆ beq x (y â¸¬ â–¡) = beq x y) â‰”
begin
  assume a beq x y; reflexivity;
end;

opaque symbol mem_cat [a] beq (x:Ï„ a) l1 l2 :
  Ï€ (âˆˆ beq x (l1 ++ l2) = âˆˆ beq x l1 or âˆˆ beq x l2) â‰”
begin
  assume a beq x; induction
  { reflexivity; }
  { assume e1 l1 h; simplify; assume l2; rewrite h l2; rewrite orA;
    reflexivity; }
end;

opaque symbol mem_head [a] beq (x:Ï„ a) l :
  Ï€ (beq x x = true) â†’ Ï€ (âˆˆ beq x (x â¸¬ l)) â‰”
begin
  assume a beq x l hrefl; rewrite hrefl; apply âŠ¤áµ¢;
end;

opaque symbol mem_take [a] beq n l (x:Ï„ a) :
  Ï€ (âˆˆ beq x (take n l)) â†’ Ï€ (âˆˆ beq x l) â‰”
begin
  assume a beq n l x h; rewrite left cat_take_drop n l;
  rewrite mem_cat beq x (take n l) (drop n l);
  refine @oráµ¢â‚ _ (âˆˆ beq x (drop n l)) h;
end;

opaque symbol mem_drop [a] beq n l (x:Ï„ a) :
  Ï€ (âˆˆ beq x (drop n l)) â†’ Ï€ (âˆˆ beq x l) â‰”
begin
  assume a beq n l x h; rewrite left cat_take_drop n l;
  rewrite mem_cat beq x (take n l) (drop n l);
  refine @oráµ¢â‚‚ (âˆˆ beq x (take n l)) _ h;
end;

opaque symbol mem_rcons_left [a] beq (n m : Ï„ a) (l : ğ•ƒ a) :
  Ï€ (âˆˆ beq n l) â†’ Ï€ (âˆˆ beq n (rcons l m)) â‰”
begin
  assume a beq n m;
  induction
    { assume h; apply âŠ¥â‚‘ h }
    { assume n0 l h1 h2;
      have H0: Ï€ (beq n n0) â†’ Ï€ (beq n n0 or âˆˆ beq n (rcons l m))
        { assume h3;
          refine (oráµ¢â‚ (âˆˆ beq n (rcons l m)) h3) };
          have H1: Ï€ (âˆˆ beq n l) â†’  Ï€ (beq n n0 or âˆˆ beq n (rcons l m))
            { assume h3;
              refine (oráµ¢â‚‚ (beq n n0) (h1 h3)) };
          refine orâ‚‘ (beq n n0 or âˆˆ beq n (rcons l m)) h2 H0 H1 }
end;

opaque symbol 0âˆˆindexesâ¸¬ [a] (x : Ï„ a) (l: ğ•ƒ a) :
  Ï€ (âˆˆ eqn 0 (indexes (x â¸¬ l))) â‰”
begin
    assume a x;
    induction
        {refine âŠ¤áµ¢}
        {assume y l h;
        refine mem_rcons_left eqn 0 (size l +1) (indexes (x â¸¬ l)) h }
end;

symbol +1âˆˆiota+1 n m k :
  Ï€ (âˆˆ eqn n (iota m k)) â†’ Ï€ (âˆˆ eqn (n +1) (iota (m +1) k)) â‰”
begin
  assume n;
  have h: Î  k m, Ï€ (âˆˆ eqn n (iota m k)) â†’ Ï€ (âˆˆ eqn (n +1) (iota (m +1) k))
    { induction
      { assume m; simplify; assume h; refine h }
      { assume k h1 m; simplify; assume h2;
        refine orâ‚‘ [eqn n m] [âˆˆ eqn n (iota (m +1) k)] (eqn n m or âˆˆ eqn (n +1) (iota ((m +1) +1) k)) h2 _ _
          { assume h3;
            refine oráµ¢â‚ (âˆˆ eqn (n +1) (iota ((m +1) +1) k)) h3 }
          { assume h3;
            refine oráµ¢â‚‚ (eqn n m) [âˆˆ eqn (n +1) (iota ((m +1) +1) k)] _;
            refine h1 (m +1) _; refine h3
          }
      }
    };
  assume m k; refine h k m
end;

opaque symbol +1âˆˆindexesâ¸¬ a (n: Ï„ nat) (l: ğ•ƒ a) (y: Ï„ a) :
  Ï€ (âˆˆ eqn n (indexes l)) â†’ Ï€ (âˆˆ eqn (n +1) (indexes (y â¸¬ l))) â‰”
begin
  assume a n; induction
  { simplify; assume x h; refine h }
  { assume x l h y; simplify; assume i;
    refine orâ‚‘ [eqn n 0] [âˆˆ eqn n (iota 1 (size l))] _ i _ _
      { assume j; refine oráµ¢â‚ (âˆˆ eqn (n +1) (iota 2 (size l))) j }
      { assume j; refine oráµ¢â‚‚ (eqn n 0) [âˆˆ eqn (n +1) (iota 2 (size l))] _;
        refine +1âˆˆiota+1 n 1 (size l) j;
      }
  }
end;

// index

symbol index [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ Ï„ a â†’ ğ•ƒ a â†’ â„•;

rule index _ _ â–¡ â†ª 0
with index $beq $x ($y â¸¬ $l) â†ª if ($beq $x $y) 0 (index $beq $x $l +1);

assert âŠ¢ index eqn 2 (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) â‰¡ 1;
assert âŠ¢ index eqn 26 (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) â‰¡ 4;

opaque symbol index_size [a] beq (x:Ï„ a) l : Ï€ (index beq x l â‰¤ size l) â‰”
begin
  assume a beq x; induction
  { apply âŠ¤áµ¢; }
  { assume e l h; simplify;
    refine ind_ğ”¹ (Î» b, istrue (if b 0 (index beq x l +1) â‰¤ size l +1)) _ _ (beq x e) {
      apply âŠ¤áµ¢;
    } {
      simplify; apply h;
    };
  }
end;

opaque symbol index_head [a] beq (x:Ï„ a) l :
  Ï€ (beq x x = true) â†’ Ï€ (index beq x (x â¸¬ l) = 0) â‰”
begin
  assume a beq x l hrefl; simplify; rewrite hrefl; reflexivity;
end;

// has

symbol has [a] : (Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ”¹;

rule has _ â–¡ â†ª false
with has $p ($x â¸¬ $l) â†ª if ($p $x) true (has $p $l);

assert âŠ¢ has (Î» x, eqn (x + 1) 3) (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) â‰¡ true;
assert âŠ¢ has (Î» x, eqn (x + 1) 3) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) â‰¡ false;

// all

symbol all [a] : (Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ”¹;

rule all _ â–¡ â†ª true
with all $p ($x â¸¬ $l) â†ª if ($p $x) (all $p $l) false;

assert âŠ¢ all (Î» x, eqn (x + 1) 3) (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) â‰¡ false;
assert âŠ¢ all (Î» x, eqn (x + 1) 3) (2 â¸¬ 2 â¸¬ 2 â¸¬ 2 â¸¬ â–¡) â‰¡ true;

// find

symbol find [a] : (Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ â„•;

rule find _ â–¡ â†ª 0
with find $p ($x â¸¬ $l) â†ª if ($p $x) 0 (find $p $l +1);

assert âŠ¢ find (Î» x, eqn (x + 1) 3) (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) â‰¡ 1;
assert âŠ¢ find (Î» x, eqn (x + 1) 3) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) â‰¡ 4;

opaque symbol find_size [a] (p:Ï„ a â†’ ğ”¹) l : Ï€ (find p l â‰¤ size l) â‰”
begin
  assume a p; induction
  { apply âŠ¤áµ¢; }
  { assume e l h;
    refine ind_ğ”¹ (Î» x, istrue (if x 0 (find p l +1) â‰¤ size l +1)) _ _ (p e) {
      apply âŠ¤áµ¢;
    } {
      simplify; apply h;
    };
  }
end;

// count

symbol count [a] : (Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ â„•;

rule count _ â–¡ â†ª 0
with count $p ($x â¸¬ $l) â†ª if ($p $x) (count $p $l +1) (count $p $l);

assert âŠ¢ count (Î» x, eqn (x + 1) 3) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) â‰¡ 0;
assert âŠ¢ count (Î» x, eqn (x + 1) 3) (2 â¸¬ 2 â¸¬ 2 â¸¬ 2 â¸¬ â–¡) â‰¡ 4;

opaque symbol count_size [a] (p:Ï„ a â†’ ğ”¹) l : Ï€(count p l â‰¤ size l) â‰”
begin
  assume a p; induction
  { apply âŠ¤áµ¢; }
  { assume e l h; simplify;
    refine ind_ğ”¹ (Î» x, istrue (if x (count p l +1) (count p l) â‰¤ size l +1)) _ _ (p e) {
      simplify; apply h;
    } {
      simplify;
      refine @leq_trans (count p l) (size l) (size l +1) h (leqnSn (size l)); 
    };
  }
end;

// count_mem

symbol count_mem [a] (beq : Ï„ a â†’ Ï„ a â†’ ğ”¹) e â‰” count (beq e);

assert âŠ¢ count_mem eqn 2 (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) â‰¡ 0;
assert âŠ¢ count_mem eqn 2 (2 â¸¬ 2 â¸¬ 2 â¸¬ 2 â¸¬ â–¡) â‰¡ 4;

// is_constant

symbol is_constant [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ”¹;

rule is_constant _ â–¡ â†ª true
with is_constant $beq ($x â¸¬ $l) â†ª if (all ($beq $x) $l) true false;

assert âŠ¢ is_constant eqn (2 â¸¬ 2 â¸¬ 2 â¸¬ 2 â¸¬ â–¡) â‰¡ true;
assert âŠ¢ is_constant eqn â–¡ â‰¡ true;
assert âŠ¢ is_constant eqn (2 â¸¬ 2 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) â‰¡ false;

// uniq

symbol uniq [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ”¹;

rule uniq _ â–¡ â†ª true
with uniq $beq ($x â¸¬ $l) â†ª if (not (âˆˆ $beq $x $l)) (uniq $beq $l) false;

assert âŠ¢ uniq eqn (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) â‰¡ true;
assert âŠ¢ uniq eqn (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡) â‰¡ false;

// subseq

symbol subseq [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;

rule subseq _ â–¡ â–¡ â†ª true
with subseq _ â–¡ (_ â¸¬ _) â†ª false
with subseq _ (_ â¸¬ _) â–¡ â†ª false
with subseq $beq ($x â¸¬ $l1) ($y â¸¬ $l2)
     â†ª if ($beq $x $y) (subseq $beq $l1 $l2) false;

assert âŠ¢ subseq eqn (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡) â‰¡ false;
assert âŠ¢ subseq eqn (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) â‰¡ true;

// is_prefix

symbol is_prefix [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;

rule is_prefix _ â–¡ _ â†ª true
with is_prefix _ (_ â¸¬ _) â–¡ â†ª false
with is_prefix $beq ($x â¸¬ $l1) ($y â¸¬ $l2)
     â†ª if ($beq $x $y) (is_prefix $beq $l1 $l2) false;

assert âŠ¢ is_prefix eqn (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡) â‰¡ true;

// is_suffix

symbol is_suffix [a] beq l1 l2 â‰” @is_prefix a beq (rev l1) (rev l2);

assert âŠ¢ is_suffix eqn (4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡) â‰¡ true;

// is_infix

symbol is_infix [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;

rule is_infix _ â–¡ _ â†ª true
with is_infix _ (_ â¸¬ _) â–¡ â†ª false
with is_infix $beq ($x â¸¬ $l1) ($y â¸¬ $l2)
     â†ª if ($beq $x $y) (is_prefix $beq $l1 $l2) (is_infix $beq ($x â¸¬ $l1) $l2);

assert âŠ¢ is_infix eqn (51 â¸¬ 3 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡) â‰¡ true;

// infix_index

symbol infix_index [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ â„•;

rule infix_index _ â–¡ _ â†ª 0
with infix_index _ (_ â¸¬ _) â–¡ â†ª 0
with infix_index $beq ($x â¸¬ $l1) ($y â¸¬ $l2) â†ª
  if ($beq $x $y)
    (if (is_prefix $beq $l1 $l2) 0 (size $l2 +1))
    (infix_index $beq ($x â¸¬ $l1) $l2 +1);

assert âŠ¢ infix_index eqn (51 â¸¬ 3 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡) â‰¡ 2;
assert âŠ¢ infix_index eqn (51 â¸¬ 4 â¸¬ â–¡) (42 â¸¬ 4 â¸¬ 51 â¸¬ 3 â¸¬ 4 â¸¬ â–¡) â‰¡ 5;

// perm_eq

symbol perm_eq [a] beq l1 l2
  â‰” @all a (Î» x, eqn (count_mem beq x l1) (count_mem beq x l2)) (l1 ++ l2);

assert âŠ¢ perm_eq eqn (59 â¸¬ 58 â¸¬ 4 â¸¬ 2 â¸¬ â–¡) (58 â¸¬ 4 â¸¬ 2 â¸¬ 59 â¸¬ â–¡) â‰¡ true;
assert âŠ¢ perm_eq eqn (59 â¸¬ 58 â¸¬ 4 â¸¬ 2 â¸¬ â–¡) (58 â¸¬ 4 â¸¬ 2 â¸¬ 69 â¸¬ â–¡) â‰¡ false;

// filter

symbol filter [a] : (Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule filter _ â–¡ â†ª â–¡
with filter $p ($x â¸¬ $l) â†ª if ($p $x) ($x â¸¬ (filter $p $l)) (filter $p $l);

assert âŠ¢ filter (Î» x, eqn (x + 1) 3) (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ 2 â¸¬ 68 â¸¬ â–¡) â‰¡ 2 â¸¬ 2 â¸¬ â–¡;

symbol rmfilter [a] : (Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule rmfilter _ â–¡ â†ª â–¡
with rmfilter $p ($x â¸¬ $l) â†ª if ($p $x) (filter $p $l) ($x â¸¬ (filter $p $l));

opaque symbol size_filter [a] (p:Ï„ a â†’ ğ”¹) l :
  Ï€ (size (filter p l) = count p l) â‰”
begin
  assume a p; induction
  { reflexivity; }
  { assume e l h; simplify;
    refine ind_ğ”¹ (Î» x, size (if x (e â¸¬ filter p l) (filter p l)) = (if x (count p l +1) (count p l))) _ _ (p e) {
      simplify; apply feq (+1) h;
    } {
      simplify; apply h;
    };
  }
end;

opaque symbol filter_cat [a] (p:Ï„ a â†’ ğ”¹) l1 l2 :
  Ï€ (filter p (l1 ++ l2) = filter p l1 ++ filter p l2) â‰”
begin
  assume a p; induction
  { reflexivity; }
  { assume e1 l1 h l2; simplify;
    refine ind_ğ”¹ (Î» x, if x (e1 â¸¬ filter p (l1 ++ l2)) (filter p (l1 ++ l2)) = if x (e1 â¸¬ filter p l1) (filter p l1) ++ filter p l2) _ _ (p e1) {
      simplify; rewrite h l2; reflexivity;
    } {
      simplify; rewrite h l2; reflexivity;
    }
  }
end;

opaque symbol filter_rev [a] (p:Ï„ a â†’ ğ”¹) l :
  Ï€ (filter p (rev l) = rev (filter p l)) â‰”
begin
  assume a p; induction
  { reflexivity; }
  { assume e l h; simplify; rewrite filter_cat p (rev l) (e â¸¬ â–¡); simplify;
    refine ind_ğ”¹ (Î» b:ğ”¹, (filter p (rev l) ++ (if b (e â¸¬ â–¡) â–¡) = rev (if b (e â¸¬ filter p l) (filter p l)))) _ _ (p e) {
      simplify; rewrite h; reflexivity;
    } {
      simplify; rewrite h; reflexivity;
    };
  }
end;

opaque symbol count_cat [a] (p:Ï„ a â†’ ğ”¹) l1 l2 :
  Ï€ (count p (l1 ++ l2) = count p l1 + count p l2) â‰”
begin
  assume a p l1 l2; rewrite left size_filter p l1;
  rewrite left size_filter p l2; rewrite left size_filter p (l1 ++ l2);
  rewrite filter_cat p l1 l2;
  rewrite left size_cat (filter p l1) (filter p l2); reflexivity;
end;

opaque symbol eq_find [a] beq p (l1 l2:ğ•ƒ a) :
  Ï€ (eql beq l1 l2) â†’ Ï€ (eqn (find p l1) (find p l2)) â‰”
begin
abort;

// undup

symbol undup [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule undup _ â–¡ â†ª â–¡
with undup $beq ($x â¸¬ $l)
  â†ª if (âˆˆ $beq $x (undup $beq $l)) (undup $beq $l) ($x â¸¬ (undup $beq $l));

assert âŠ¢ undup eqn (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ 2 â¸¬ 3 â¸¬ â–¡) â‰¡ 42 â¸¬ 51 â¸¬ 2 â¸¬ 3 â¸¬ â–¡;

opaque symbol size_undup [a] beq (l:ğ•ƒ a) : Ï€ (size (undup beq l) â‰¤ size l) â‰”
begin
  assume a beq; induction
  { apply âŠ¤áµ¢; }
  { assume e l h; simplify;
    refine ind_ğ”¹ (Î» x, istrue (size (if x (undup beq l) (e â¸¬ undup beq l)) â‰¤ size l +1)) _ _ (âˆˆ beq e (undup beq l)) {
      simplify;
      refine @leq_trans (size (undup beq l)) (size l) (size l +1) h (leqnSn (size l));
    } {
      simplify; apply h;
    };
  }
end;

opaque symbol undup_uniq [a] beq (l:ğ•ƒ a) : Ï€ (uniq beq (undup beq l)) â‰”
begin
  assume a beq; induction
  { apply âŠ¤áµ¢; }
  { assume e l h; simplify;
    refine ind_ğ”¹_eq (Î» b, (istrue(uniq beq (if b (undup beq l) (e â¸¬ (undup beq l)))))) (âˆˆ beq e (undup beq l)) _ _ {
      assume i; rewrite i; simplify; apply h;
    } {
      assume i; rewrite i; simplify; rewrite i; simplify; apply h; 
    }; 
  }
end;

opaque symbol filter_undup [a] beq p (l:ğ•ƒ a) :
  Ï€ (filter p (undup beq l) = undup beq (filter p l)) â‰”
begin
abort;

opaque symbol count_undup [a] beq p (l:ğ•ƒ a) :
  Ï€ (count p (undup beq l) â‰¤ count p l) â‰”
begin
abort;

// map

symbol map [a b] : (Ï„ a â†’ Ï„ b) â†’ ğ•ƒ a â†’ ğ•ƒ b;

rule map _ â–¡ â†ª â–¡
with map $f ($x â¸¬ $l) â†ª $f $x â¸¬ map $f $l;

assert âŠ¢ map (Î» x, 3 â‰¤ x) (42 â¸¬ 2 â¸¬ 51 â¸¬ 3 â¸¬ â–¡) â‰¡ true â¸¬ false â¸¬ true â¸¬ true â¸¬ â–¡;

opaque symbol map_cons [a b] (f:Ï„ a â†’ Ï„ b) l x :
  Ï€ (map f (x â¸¬ l) = f x â¸¬ map f l) â‰”
begin
  assume a b f l x; reflexivity;
end;

opaque symbol map_cat [a b] (f:Ï„ a â†’ Ï„ b) l1 l2 :
  Ï€ (map f (l1 ++ l2) = map f l1 ++ map f l2) â‰”
begin
  assume a b f; induction
  { reflexivity; }
  { assume e1 l1 h l2; simplify; rewrite h l2; reflexivity; }
end;

opaque symbol size_map [a b] (f:Ï„ a â†’ Ï„ b) l : Ï€ (size (map f l) = size l) â‰”
begin
  assume a b f; induction
  { reflexivity; }
  { assume e l h; simplify; apply feq (+1) h; }
end;

opaque symbol behead_map [a b] (f:Ï„ a â†’ Ï„ b) l :
  Ï€ (behead (map f l) = map f (behead l)) â‰”
begin
  assume a b f; induction
  { reflexivity; }
  { assume e l h; reflexivity; }
end;

opaque symbol map_rcons [a b] (f:Ï„ a â†’ Ï„ b) l e :
  Ï€ (map f (rcons l e) = rcons (map f l) (f e)) â‰”
begin
  assume a b f; induction
  { reflexivity; }
  { assume x l h e; simplify; rewrite h e; reflexivity; }
end;

opaque symbol last_map [a b] (f:Ï„ a â†’ Ï„ b) l x :
  Ï€ (last (f x) (map f l) = f (last x l)) â‰”
begin
  assume a b f; induction
  { reflexivity; }
  { assume e l h x; simplify; rewrite h e; reflexivity; }
end;

opaque symbol belast_map [a b] (f:Ï„ a â†’ Ï„ b) l x :
  Ï€ (belast (f x) (map f l) = map f (belast x l)) â‰”
begin
  assume a b f; induction
  { reflexivity; }
  { assume e l h x; simplify; rewrite h e; reflexivity; }
end;

opaque symbol map_take [a b] (f:Ï„ a â†’ Ï„ b) n l :
  Ï€ (map f (take n l) = take n (map f l)) â‰”
begin
  assume a b f; induction
  { reflexivity; }
  { assume n h; induction
    { reflexivity; }
    { assume e l i; simplify; rewrite h l; reflexivity; } 
  }
end;

opaque symbol map_drop [a b] (f:Ï„ a â†’ Ï„ b) n l :
  Ï€ (map f (drop n l) = drop n (map f l)) â‰”
begin
  assume a b f; induction
  { reflexivity; }
  { assume n h; induction
    { reflexivity; }
    { assume e l i; simplify; rewrite h l; reflexivity; } 
  }
end;

opaque symbol map_rot [a b] (f:Ï„ a â†’ Ï„ b) n l :
  Ï€ (map f (rot n l) = rot n (map f l)) â‰”
begin
  assume a b f n l; simplify; rewrite map_cat f (drop n l) (take n l);
  rewrite map_take f n l; rewrite map_drop f n l; reflexivity; 
end;

opaque symbol map_rotr [a b] (f:Ï„ a â†’ Ï„ b) n l :
  Ï€ (map f (rotr n l) = rotr n (map f l)) â‰”
begin
  assume a b f n l; simplify;
  rewrite map_cat f (drop (size l - n) l) (take (size l - n) l);
  rewrite map_drop f (size l - n) l; rewrite map_take f (size l - n) l;
  rewrite size_map f l; reflexivity;
end;

opaque symbol map_rev [a b] (f:Ï„ a â†’ Ï„ b) l :
  Ï€ (map f (rev l) = rev (map f l)) â‰”
begin
  assume a b f; induction
  { reflexivity; }
  { assume e l h; simplify; rewrite map_cat f (rev l) (e â¸¬ â–¡); rewrite h;
    reflexivity; }
end;

opaque symbol inj_map [a b] (f:Ï„ a â†’ Ï„ b) :
  (Î  x y, Ï€(f x = f y) â†’ Ï€(x = y)) â†’
  Î  l1 l2, Ï€ (map f l1 = map f l2) â†’ Ï€ (l1 = l2) â‰”
begin
  assume a b f h; induction
  { induction
    { reflexivity; }
    { simplify; assume e l i j; apply âŠ¥â‚‘ (â–¡â‰ â¸¬ j) }
  }
  { assume e1 l1 i; induction
    { assume j; apply âŠ¥â‚‘ (â¸¬â‰ â–¡ j) }
    {
      simplify; assume e2 l2 j k; apply feq2 (â¸¬) _ _
      { apply h; apply âˆ§â‚‘â‚ (â¸¬_inj k) }
      { apply i; apply âˆ§â‚‘â‚‚ (â¸¬_inj k) }
    }
  }
end;

// sumn

symbol sumn : ğ•ƒ nat â†’ â„•;

rule sumn â–¡ â†ª 0
with sumn ($x â¸¬ $l) â†ª $x + sumn $l;

assert âŠ¢ sumn (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) â‰¡ 6;

// prodn

symbol prodn : ğ•ƒ nat â†’ â„•;

rule prodn â–¡ â†ª 1
with prodn ($x â¸¬ $l) â†ª $x * prodn $l;

assert âŠ¢ prodn (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) â‰¡ 3 !;
