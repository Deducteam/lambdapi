// issue #700

// Define the CoC encoding
symbol Type : TYPE;
symbol Kind : TYPE;

injective symbol Ï€ : Type â†’ TYPE;
injective symbol Îµ : Kind â†’ TYPE;

symbol dotType : Kind;
rule Îµ dotType â†ª Type;

symbol âˆ€â‚œâ‚œ [x : Type] : (Ï€ x â†’ Type) â†’ Type;
symbol âˆ€â‚œâ‚– [x : Type] : (Ï€ x â†’ Kind) â†’ Kind;
symbol âˆ€â‚–â‚œ [x : Kind] : (Îµ x â†’ Type) â†’ Type;
symbol âˆ€â‚–â‚– [x : Kind] : (Îµ x â†’ Kind) â†’ Kind;

rule Ï€ (âˆ€â‚œâ‚œ $f) â†ª  Î  w, Ï€ ($f w)
with Îµ (âˆ€â‚œâ‚– $f) â†ª  Î  w, Îµ ($f w)
with Ï€ (âˆ€â‚–â‚œ $f) â†ª  Î  w, Ï€ ($f w)
with Îµ (âˆ€â‚–â‚– $f) â†ª  Î  w, Îµ ($f w);

symbol â‡’ A B â‰”  @âˆ€â‚œâ‚œ A (Î» _, B);
notation â‡’ infix right 14;

notation âˆ€â‚–â‚œ quantifier;

// Define the equality in this setting
symbol = [T] (x y : Ï€ T) : Type
// Works if next line is commented
â‰” `âˆ€â‚–â‚œ P, P y â‡’ P x
;
notation = infix 20;

// If equality is defined, then we can uncomment the following definition lines
symbol =_refl [T] (x : Ï€ T) : Ï€ (x = x)
// â‰” Î» P px, px
;
symbol =_ind [T] (x y : Ï€ T) : Ï€ (x = y) â†’ Î  P, Ï€ (P y) â†’ Ï€ (P x)
// â‰” Î» eqxy, eqxy (Î» t, t = y) (=_refl y)
;

builtin "P"     â‰” Ï€;
builtin "T"     â‰” Ï€;
builtin "eq"    â‰” =;
builtin "refl"  â‰” =_refl;
builtin "eqind" â‰” =_ind;

symbol rewrite_test1 T (x y : Ï€ T) (f : Ï€ T â†’ Type) : Ï€ (x = y â‡’ f x â‡’ f y)
â‰” begin
  assume T x y f eqxy;
  have e : Ï€ (x = y) {refine eqxy};
  rewrite e;
  assume fy; apply fy
end;

symbol ğ”¹ : TYPE;
symbol true : ğ”¹;
symbol false : ğ”¹;

symbol bool : Type;
rule Ï€ bool â†ª ğ”¹;

symbol not : ğ”¹ â†’ ğ”¹;
rule not false â†ª true
with not true â†ª false;

symbol reflexivity_test2 : Ï€ (not (not true) = true) â‰”
begin
  reflexivity
end;

symbol rewrite_test3 T (x : Ï€ T) (f g : Ï€ T â†’ Ï€ T) (p : Ï€ T â†’ Type):
  Ï€ ((`âˆ€â‚œâ‚œ y, f y = g y) â‡’ p (f x) â‡’ p (g x))
â‰” begin
  assume T x f g p e;
  rewrite e;
  refine (Î» u, u)
end;
