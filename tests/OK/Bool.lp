/* Library on booleans. */

require open tests.OK.Set tests.OK.Prop tests.OK.FOL tests.OK.Eq;

inductive ğ”¹ : TYPE â‰” // `dB or \BbbB
| true : ğ”¹
| false : ğ”¹;

constant symbol bool : Set;

rule Ï„ bool â†ª ğ”¹;

// induction principle with equalities

opaque symbol case_ğ”¹ b : Ï€ (b = true âˆ¨ b = false) â‰”
begin
  induction
  { apply âˆ¨áµ¢â‚; reflexivity; }
  { apply âˆ¨áµ¢â‚‚; reflexivity; }
end;

opaque symbol ind_ğ”¹_eq p b:
 (Ï€(b = true) â†’ Ï€(p b)) â†’ (Ï€(b = false) â†’ Ï€(p b)) â†’ Ï€(p b) â‰”
begin
  assume p b t f; refine âˆ¨â‚‘ (case_ğ”¹ b) t f;
end;

// istrue predicate

injective symbol istrue : ğ”¹ â†’ Prop;

rule istrue true â†ª âŠ¤
with istrue false â†ª âŠ¥;

coerce_rule coerce ğ”¹ Prop $x â†ª istrue $x;

// non confusion of constructors

opaque symbol falseâ‰ true : Ï€ (false â‰  true) â‰”
begin
  assume h; refine ind_eq h istrue âŠ¤áµ¢
end;

opaque symbol trueâ‰ false : Ï€ (true â‰  false) â‰”
begin
  assume h; apply falseâ‰ true; symmetry; apply h
end;

// not

symbol not : ğ”¹ â†’ ğ”¹;

rule not true  â†ª false
with not false â†ª true;

// or

symbol or : ğ”¹ â†’ ğ”¹ â†’ ğ”¹;

notation or infix left 20;

rule true  or _     â†ª true
with _     or true  â†ª true
with false or $b    â†ª $b
with $b    or false â†ª $b;

opaque symbol âˆ¨_istrue [p q : ğ”¹] : Ï€(p or q) â†’ Ï€(p âˆ¨ q) â‰”
begin
  induction
  { assume q h; apply âˆ¨áµ¢â‚; apply âŠ¤áµ¢; }
  { assume q h; apply âˆ¨áµ¢â‚‚; apply h; }
end;

opaque symbol istrue_or [p q : ğ”¹] : Ï€(p âˆ¨ q) â†’ Ï€(p or q) â‰”
begin
  induction
  { assume q h; apply âŠ¤áµ¢; }
  { assume q h; apply âˆ¨â‚‘ h { assume i; apply âŠ¥â‚‘ i; } { assume i; apply i; } }
end;

opaque symbol oráµ¢â‚ [p : ğ”¹] q : Ï€ p â†’ Ï€ (p or q) â‰”
begin
  induction
  { simplify; assume b h; apply âŠ¤áµ¢ }
  { simplify; assume b h; apply âŠ¥â‚‘ h }
end;

opaque symbol oráµ¢â‚‚ p [q : ğ”¹] : Ï€ q â†’ Ï€ (p or q) â‰”
begin
  induction
  { simplify; assume b h; apply âŠ¤áµ¢ }
  { simplify; assume b h; apply h }
end;

opaque symbol orâ‚‘ [p q : ğ”¹] (r : ğ”¹) :
  Ï€ (p or q) â†’ (Ï€ p â†’ Ï€ r) â†’ (Ï€ q â†’ Ï€ r) â†’ Ï€ r â‰”
begin
  assume p q r pq pr qr;
  have h: Ï€(p âˆ¨ q) { apply âˆ¨_istrue pq };
  apply âˆ¨â‚‘ h pr qr;
end;

opaque symbol orC p q : Ï€ (p or q = q or p) â‰”
begin
    induction
    { reflexivity; }
    { reflexivity; }
end;

opaque symbol orA p q r : Ï€ ((p or q) or r = p or (q or r)) â‰”
begin
    induction
    { reflexivity; }
    { reflexivity; }
end;

// and

symbol and : ğ”¹ â†’ ğ”¹ â†’ ğ”¹;

notation and infix left 7;

rule true  and $b    â†ª $b
with $b    and true  â†ª $b
with false and _     â†ª false
with _     and false â†ª false;

opaque symbol âˆ§_istrue [p q : ğ”¹] : Ï€(p and q) â†’ Ï€(p âˆ§ q) â‰”
begin
  induction
  { induction
    { assume h; apply âˆ§áµ¢ { apply âŠ¤áµ¢ } { apply âŠ¤áµ¢ } }
    { assume h; apply âŠ¥â‚‘ h; }
  }
  { assume q h; apply âŠ¥â‚‘ h; }
end;

opaque symbol istrue_and [p q : ğ”¹] : Ï€(p âˆ§ q) â†’ Ï€(p and q) â‰”
begin
  induction
  { assume q h; apply âˆ§â‚‘â‚‚ h; }
  { assume q h; apply âˆ§â‚‘â‚ h; }
end;

opaque symbol andáµ¢ [p q : ğ”¹] : Ï€ p â†’ Ï€ q â†’ Ï€(p and q) â‰”
begin
  assume p q h i; apply @istrue_and p q; apply âˆ§áµ¢ h i;
end;

opaque symbol andâ‚‘â‚ [p q : ğ”¹] : Ï€ (p and q) â†’ Ï€ p â‰”
begin
  induction
  { assume q i; apply âŠ¤áµ¢; }
  { assume q i; apply i; }
end;

opaque symbol andâ‚‘â‚‚ [p q : ğ”¹] : Ï€ (p and q) â†’ Ï€ q â‰”
begin
  induction
  { assume q i; apply i; }
  { assume q i; apply âŠ¥â‚‘ i; }
end;

// if-then-else

symbol if : ğ”¹ â†’ Î  [a], Ï„ a â†’ Ï„ a â†’ Ï„ a;

rule if true  $x _ â†ª $x
with if false _ $y â†ª $y;
