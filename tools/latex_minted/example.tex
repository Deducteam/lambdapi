\documentclass{article}

\usepackage{dedukti}

\begin{document}

\begin{dedukti}
#NAME dot.

Prop : Type.
prf  : Prop -> Type.

True       : Prop.
True_intro : prf True.

False      : Prop.
False_elim : A:Prop -> prf False -> prf A.

and       : Prop -> Prop -> Prop.
and_intro : A:Prop -> B:Prop -> prf A -> prf B -> prf (and A B).
and_elim1 : A:Prop -> B:Prop -> prf (and A B) -> prf A.
and_elim2 : A:Prop -> B:Prop -> prf (and A B) -> prf B.

imp       : Prop -> Prop -> Prop.
imp_elim  : A:Prop -> B:Prop -> prf (imp A B) -> prf A -> prf B.
imp_intro : A:Prop -> B:Prop -> (prf A -> prf B) -> prf (imp A B).

or        : Prop -> Prop -> Prop.
or_elim   : A:Prop -> B:Prop -> C:Prop -> prf (or A B) -> prf (imp A C) -> prf (imp B C) -> prf C.
or_intro1 : A:Prop -> B:Prop -> prf A -> prf (or A B).
or_intro2 : A:Prop -> B:Prop -> prf B -> prf (or A B).

def not       : Prop -> Prop := p:Prop => imp p False.

def equiv : Prop -> Prop -> Prop := A:Prop => B:Prop => and (imp A B) (imp B A).

(; De Morgan Laws ;)

def DeMorgan1 : A:Prop -> B:Prop -> prf (imp (and A B) (not (or (not A) (not B)))) :=
	A:Prop => B:Prop =>
	imp_intro (and A B) (not (or (not A) (not B)))
		  ( A_and_B :(prf (and A B)) => imp_intro (or (not A) (not B)) False (
		  ( not_A_or_not_B:(prf (or (not A) (not B))) =>
			or_elim (not A) (not B) False not_A_or_not_B
				(imp_intro (not A) False (not_A:(prf (not A)) => imp_elim A False not_A (and_elim1 A B A_and_B) ) )
				(imp_intro (not B) False (not_B:(prf (not B)) => imp_elim B False not_B (and_elim2 A B A_and_B) ) )
	) ) ).

DeMorgan2 : A:Prop -> B:Prop -> prf (imp (or A B) (not (and (not A) (not B)))). (; TODO ;)

(; Quantifiers ;)

U:Type.

forall       : (U->Prop) -> Prop.
forall_intro : P:(U->Prop) -> (x:U -> prf (P x)) -> prf (forall P).
forall_elim  : P:(U->Prop) -> prf (forall P) -> x:U -> prf (P x).


N: Type.
Z: N.
S: N->N.

def plus: N->N->N.
[y] plus Z     y --> y
[x,y] plus (S x) y --> S (plus x y).


V:   N->Type.
Nil: V Z.
Con: n:N -> V n -> N -> V (S n).

def hd: n:N -> V (S n) -> N.

[m] hd _ (Con _ _ m) --> m.


def app: n:N -> m:N -> V n -> V m -> V (plus n m).
[y] app _  _ Nil y --> y
[n,m,x,y,k] app _ m (Con n x k) y --> Con (plus n m) (app n m x y) k.

def not (a : prop) := imp a false.
def not(a : prop) := imp a false.
default_value : A : type -> term A.
def 1 := S 0.
def a := b'.
def C2' : factor 0 1 C0.

private def 1' := 1.
\end{dedukti}

\end{document}
