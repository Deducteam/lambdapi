<qid> ::= [<uid>.]+<uid>

<switch> ::= on
           | off

<assoc> ::= left
          | right



<id> ::= <qid>
       | <uid>

<path> ::= <qid>

<term_id> ::= <id>
            | @<id>

<patt_id> ::= $<uid>

<param_id> ::= <uid>
             | _

<params> ::= <param_id>
           | ( <param_id>+ : <term> )
           | { <param_id>+ [: <term>] }

<rw_patt> ::= <term>
            | in <term>
            | in <uid> in <term>
            | <term> in <term> [in <term>]
            | <term> as <uid> in <term>

<tactic> ::= <query>
           | admit
           | apply <term>
           | assume <param_id>+
           | fail
           | focus <int>
           | induction
           | refine <term>
           | reflexivity
           | rewrite [<assoc>] [[ <rw_patt> ]] <term>
           | simpl
           | solve
           | symmetry
           | why3 ["<string>"]

<modifier> ::= constant
             | injective
             | opaque
             | private
             | protected
             | sequential

<float_or_int> ::= <float>
                 | <int>

<notation> ::= infix [<assoc>] <float_or_int>
             | prefix <float_or_int>
             | quantifier

<assert_kw> ::= assert
              | assertnot

<query> ::= <assert_kw> <params>* ⊢ <term> : <term>
          | <assert_kw> <params>* ⊢ <term> ≡ <term>
          | compute <term>
          | print [<id>]
          | proofterm
          | debug (+ | -)<string>
          | flag "<string>" <switch>
          | prover "<string>"
          | prover_timeout <int>
          | verbose <int>
          | type <term>

<proof_end> ::= abort
              | admitted
              | end

<proof> ::= begin (<tactic> ;)* <proof_end>

<constructor> ::= <uid> <params>* : <term>

<inductive> ::= <uid> <params>* : <term> ≔ [|] [<constructor>
                (| <constructor>)*]

<term_proof> ::= <term>
               | <proof>
               | <term> <proof>

<command> ::= require open <path>* ;
            | require <path>* ;
            | require <path> as <uid> ;
            | open <path>* ;
            | <modifier>* symbol <uid> <params>* : <term> [<proof>]
              ;
            | <modifier>* symbol <uid> <params>* [: <term>] ≔
              <term_proof> ;
            | <modifier>* <params>* inductive <inductive> (with <inductive>)*
              ;
            | rule <rule> (with <rule>)* ;
            | builtin "<string>" ≔ <id> ;
            | unif_rule <unif_rule> ;
            | notation <id> <notation> ;
            | <query> ;
            

<env> ::= [ [<term> (; <term>)*] ]

<aterm> ::= <term_id>
          | _
          | TYPE
          | ?<uid> [<env>]
          | <patt_id> [<env>]
          | ( <term> )
          | { <term> }
          | <int>

<sterm> ::= <aterm>+

<term> ::= <sterm>
         | <term> → <term>
         | ` <term_id> <binder>
         | Π <binder>
         | λ <binder>
         | let <uid> <params>* [: <term>] ≔ <term> in <term>

<binder> ::= <params>+ , <term>
           | <param_id> : <term> , <term>

<rule> ::= <term> ↪ <term>

<equation> ::= <term> ≡ <term>

<unif_rule> ::= <equation> ↪ [ <equation> (;
                <equation>)* ]


