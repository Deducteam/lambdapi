<qid> ::= [<id>'.']+<id>

<switch> ::= 'on'
           | 'off'

<assoc> ::= 'left'
          | 'right'

<ident> ::= <id>

<qident> ::= <qid>
           | <id>

<term_ident> ::= '@'<qid>
               | <qident>

<patt> ::= '$'<id>

<argid> ::= <ident>
          | '_'

<arg_list> ::= <argid>
             | '(' <argid>+ ':' <term> ')'
             | '{' <argid>+ [':' <term>] '}'

<rw_patt> ::= <term>
            | 'in' <term>
            | 'in' <ident> 'in' <term>
            | <term> 'in' <term> ['in' <term>]
            | <term> 'as' <ident> 'in' <term>

<tactic> ::= <query>
           | 'apply' <term>
           | 'assume' <argid>+
           | 'fail'
           | 'focus' <int>
           | 'refine' <term>
           | 'reflexivity'
           | 'rewrite' [<assoc>] ['[' <rw_patt> ']'] <term>
           | 'simpl'
           | 'solve'
           | 'symmetry'
           | 'why3' ["<string>"]

<modifier> ::= 'constant'
             | 'injective'
             | 'opaque'
             | 'private'
             | 'protected'
             | 'sequential'

<float_or_int> ::= <float>
                 | <int>

<config> ::= 'builtin' "<string>" '≔' <qident>
           | 'infix' [<assoc>] <float_or_int> "<string>" '≔' <qident>
           | 'prefix' <float_or_int> "<string>" '≔' <qident>
           | 'quantifier' <qident>
           | 'unif_rule' <unif_rule>

<assert_kw> ::= 'assert'
              | 'assertnot'

<query> ::= <assert_kw> <arg_list>* '⊢' <term> ':' <term>
          | <assert_kw> <arg_list>* '⊢' <term> '≡' <term>
          | 'compute' <term>
          | 'print' [<qident>]
          | 'proofterm'
          | 'set' 'debug' ('+' | '-')<string>
          | 'set' 'flag' "<string>" <switch>
          | 'set' 'prover' "<string>"
          | 'set' 'prover_timeout' <int>
          | 'set' 'verbose' <int>
          | 'type' <term>

<proof_end> ::= 'abort'
              | 'admit'
              | 'end'

<proof> ::= 'begin' (<tactic> ';')* <proof_end>

<inductive> ::= <ident> ':' <term> '≔' ['|'] [<ident> ':' <term>
                ('|' <ident> ':' <term>)*]

<term_proof> ::= <term>
               | <proof>
               | <term> <proof>

<command> ::= 'require' 'open' <qid>+ ';'
            | 'require' <qid>+ ';'
            | 'require' <qid> 'as' <ident> ';'
            | 'open' <qid> ';'
            | <modifier>* 'symbol' <ident> <arg_list>* ':' <term> [<proof>]
              ';'
            | <modifier>* 'symbol' <ident> <arg_list>* [':' <term>] '≔'
              <term_proof> ';'
            | <modifier>* <arg_list>* 'inductive' <inductive> ('with'
              <inductive>)* ';'
            | 'rule' <rule> ('with' <rule>)* ';'
            | 'set' <config> ';'
            | <query> ';'
            

<env> ::= '[' [<term> (';' <term>)*] ']'

<aterm> ::= <term_ident>
          | '_'
          | 'TYPE'
          | '?'<id> [<env>]
          | <patt> [<env>]
          | '(' <term> ')'
          | '{' <term> '}'
          | <int>

<sterm> ::= <aterm>+

<term> ::= <sterm>
         | <term> → <term>
         | '`' <term_ident> <binder>
         | 'Π' <binder>
         | 'λ' <binder>
         | 'let' <ident> <arg_list>* [':' <term>] '≔' <term> 'in' <term>

<binder> ::= <arg_list>+ ',' <term>
           | <argid> ':' <term> ',' <term>

<rule> ::= <term> '↪' <term>

<equation> ::= <term> '≡' <term>

<unif_rule> ::= <equation> '↪' '[' <equation> (';'
                <equation>)* ']'


