reserved "_"
reserved "abort"
reserved "admit"
reserved "apply"
reserved "as"
reserved "assert"
reserved "assertnot"
reserved "assume"
reserved "begin"
reserved "compute"
reserved "constant"
reserved "end"
reserved "fail"
reserved "focus"
reserved "in"
reserved "injective"
reserved "let"
reserved "opaque"
reserved "open"
reserved "print"
reserved "private"
reserved "proofterm"
reserved "protected"
reserved "refine"
reserved "reflexivity"
reserved "require"
reserved "rewrite"
reserved "rule"
reserved "set"
reserved "simpl"
reserved "symmetry"
reserved "symbol"
reserved "type"
reserved "TYPE"
reserved "with"
reserved "why3"

<declared_id> ::= "ℕ" | "α" | ... // whatever has been defined in the scope

// Identifier
<ident> ::=
  | RE("[a-zA-Z_][a-zA-Z0-9_]*")     // Regular identifier
  | RE("{|\([^|]\|\(|[^}]\)\)*|*|}") // Escaped identifier
  | <declared_id>                    // Declared identifier

// Natural number literal
<nat_lit> ::= RE("[0-9]+")

// Float literal
<float_lit> ::= RE("[0-9]+\([.][0-9]+\)?")

// String literal
<string_lit> ::= RE("\"[^\"\n]*\"")

<path> ::= {<ident> "."}* <ident>

<qident> ::= {<ident> "."}* <ident>

<property> ::= "constant" | "injective"

<exposition> ::= "protected" | "private"

<opacity> ::= "opaque"

<infix_op> ::= "+" | "×" | ... // whatever has been defined in the scope

// Term (including patterns and everything)
<term> ::=
  | "TYPE"
  | "@"? <qident>
  | "_"
  | "?" - <ident> {"[" <term> {";" <term>}* "]"}?
  | "$" - {<ident> | "_"} {"[" <term> {";" <term>}* "]"}?
  | "(" <term> ")"
  | "{" <term> "}"
  | <term> <term>
  | <type> "→" <type>
  | "Π" <arg>+ "," <type>
  | "λ" <arg>+ "," <term>
  | "let" <ident> <arg>* {":" <term>}? "≔" <term> "in" <term>
  | <nat_lit>
  | <term> <infix_op> <term>

// Types
<type> ::= <term>

// Patterns
<patt> ::=
  | "$" - {<ident> | "_"} {"[" <ident> {";" <ident>}* "]"}?
  | "λ" <arg>+ "," <patt>
  | <qident> {<patt>}*

// Argument (of abstraction, product, ...), may be marked implicit
<arg> ::=
  | <ident>
  | "{" <ident>+ {":" <type>}? "}"
  | "(" <ident>+ ":" <type> ")"

// Rewriting rule
<rule> ::= <qident> {<patt>}* "↪" <term>

// Assertion predicate
<assertion> ::=
  | <arg>* "⊢" <term> ":" <term>
  | <arg>* "⊢" <term> "≡" <term>

// Flag names
<flag_name> ::=
  | "eta_equality"
  | "print_domains"
  | "print_implicits"
  | "print_meta_type"
  | "print_contexts"
  | "print_domains"

// Flag values
<flag_value> ::=
  | "on"
  | "off"

// Queries
<query> ::=
  | "print" <ident>?
  | "proofterm"
  | "type" <term>
  | "compute" <term>
  | "set" "verbose" RE("[1-9][0-9]*")
  | "set" "debug" RE("[-+][a-zA-Z]+")
  | "set" "flag" \"<flag_name>\" <flag_value>
  | "set" "prover" <ident>
  | "set" "prover_timeout" <nat_lit>
  | "assert" <assertion>
  | "assertnot" <assertion>

// Rewrite pattern
<rw_patt> ::=
  | <term>
  | "in" <term>
  | "in" <ident> "in" <term>
  | <ident> "in" <term>
  | <term> "in" <ident> "in" <term>
  | <term> "as" <ident> "in" <term>
  
// Proof tactics
<tactic> ::=
  | <query>
  | "refine" <term>
  | "assume" <ident>+
  | "apply" <term>
  | "simpl"
  | "rewrite" "-"? {"[" <rw_patt> "]"}? <term>
  | "reflexivity"
  | "symmetry"
  | "focus" <nat_lit>
  | "why3" <string_lit>?
  | "fail"

// Builtins
<builtin> ::=
  | "0"
  | "+1"
  | "T"
  | "P"
  | "eq"
  | "refl"
  | "eq_ind"
  | "top"
  | "bot"
  | "not"
  | "or"
  | "and"
  | "imp"

// Inductive type
<inductive> ::= <ident> ":" <term> "≔" {"|" <ident> ":" <term>}*

// Proof
<proof> ::= "begin" <tactic>* {"end"|"admit"|"abort"}

// Unification rule
<unif_rule> ::= <patt> "≡" <patt> "↪" <term> "≡" <term> {";" <term> "≡" <term>}*

// Commands
<command> ::=
  | <query>
  | "require" <path> "as" <ident>
  | "require" "open"? <path>
  | "open" <path>
  | <opacity>? <exposition>? <property>? "symbol" <ident> <arg>* {":" <type>}? {"≔" <term>}? proof?
  | <exposition>? "inductive" <inductive> {"with" <inductive>}*
  | "rule" <rule> {"with" <rule>}*
  | "set" "declared" <string_lit>
  | "set" "prefix" <float_lit> <string_lit> "≔" <qident>
  | "set" "infix" {"left" | "right"}? <float_lit> <string_lit> "≔" <qident>
  | "set" "quantifier" <qident>
  | "set" "builtin" \"<builtin>\" "≔" <qident>
  | "set" "unif_rule" <unif_rule>

// Entry point: list of commands.
<main> ::= <command>*
