; DO NOT EDIT THIS FILE MANUALLY
; It is generated automatically with 'make syntax.bnf'.

<qid> ::= [<uid>.]+<uid>

<switch> ::= on
           | off

<assoc> ::= left
          | right



<qid> ::= <uid>
        | <qid>

<path> ::= <qid>

<qid_expl> ::= <uid>_EXPL
             | <qid>_EXPL

<term_id> ::= <qid>
            | <qid_expl>

<param> ::= <uid>
          | UNDERSCORE

<param_list> ::= <param>
               | ( <param>+ : <term> )
               | { <param>+ [: <term>] }

<rw_patt> ::= <term>
            | in <term>
            | in <uid> in <term>
            | <term> in <term> [in <term>]
            | <term> as <uid> in <term>

<tactic> ::= <query>
           | admit
           | apply <term>
           | assume <param>*
           | fail
           | focus <int>
           | generalize <uid>
           | have <uid> : <term>
           | induction
           | refine <term>
           | reflexivity
           | rewrite [<assoc>] [[ <rw_patt> ]] <term>
           | simplify [<qid>]
           | solve
           | symmetry
           | why3 ["<string>"]

<modifier> ::= [<assoc>] associative
             | commutative
             | constant
             | injective
             | opaque
             | private
             | protected
             | sequential

<float_or_int> ::= <float>
                 | <int>

<notation> ::= infix [<assoc>] <float_or_int>
             | prefix <float_or_int>
             | quantifier

<assert_kw> ::= assert
              | assertnot

<query> ::= <assert_kw> <param_list>* ⊢ <term> : <term>
          | <assert_kw> <param_list>* ⊢ <term> ≡ <term>
          | compute <term>
          | print [<qid>]
          | proofterm
          | debug (+ | -)<string>
          | flag "<string>" <switch>
          | prover "<string>"
          | prover_timeout <int>
          | verbose <int>
          | type <term>

<proof_end> ::= abort
              | admitted
              | end

<proof> ::= begin (<tactic> ;)* <proof_end>

<constructor> ::= <uid> <param_list>* : <term>

<inductive> ::= <uid> <param_list>* : <term> ≔ [|] [<constructor>
                (| <constructor>)*]

<term_proof> ::= <term>
               | <proof>
               | <term> <proof>

<command> ::= require open <path>* ;
            | require <path>* ;
            | require <path> as <uid> ;
            | open <path>* ;
            | <modifier>* symbol <uid> <param_list>* : <term> [<proof>]
              ;
            | <modifier>* symbol <uid> <param_list>* [: <term>] ≔
              <term_proof> ;
            | <modifier>* <param_list>* inductive <inductive> (with
              <inductive>)* ;
            | rule <rule> (with <rule>)* ;
            | builtin "<string>" ≔ <qid> ;
            | unif_rule <unif_rule> ;
            | notation <qid> <notation> ;
            | <query> ;
            

<env> ::= [ [<term> (; <term>)*] ]

<aterm> ::= <term_id>
          | UNDERSCORE
          | TYPE
          | ?<uid> [<env>]
          | $<uid>T [<env>]
          | ( <term> )
          | { <term> }
          | <int>

<saterm> ::= <aterm>+

<bterm> ::= ` <term_id> <binder>
          | Π <binder>
          | λ <binder>
          | let <uid> <param_list>* [: <term>] ≔ <term> in <term>

<term> ::= <bterm>
         | <saterm>
         | <saterm> <bterm>
         | <saterm> → <term>

<binder> ::= <param_list>+ , <term>
           | <param> : <term> , <term>

<rule> ::= <term> ↪ <term>

<equation> ::= <term> ≡ <term>

<unif_rule> ::= <equation> ↪ [ <equation> (;
                <equation>)* ]


