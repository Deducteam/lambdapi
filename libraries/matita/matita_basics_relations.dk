(; This file was automatically generated from Matita. ;)

#REQUIRE cic.
#REQUIRE univs.
#REQUIRE matita_basics_logic.

#NAME matita_basics_relations.

def predicate : __ : cic.Univ univs.Type0 -> cic.Univ univs.Type0 :=
      A : cic.Univ univs.Type0 =>
      cic.prod univs.Type0 (cic.type cic.z) A
        (__ : cic.Term univs.Type0 A => cic.univ cic.prop).

def relation : __ : cic.Univ univs.Type0 -> cic.Univ univs.Type0 :=
      A : cic.Univ univs.Type0 =>
      cic.prod univs.Type0 univs.Type0 A
        (__ : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 (cic.type cic.z) A
           (__1 : cic.Term univs.Type0 A => cic.univ cic.prop)).

def relation2 :
      __ : cic.Univ univs.Type0 ->
      __1 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      cic.prod univs.Type0 univs.Type0 A
        (__ : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 (cic.type cic.z) B
           (__1 : cic.Term univs.Type0 B => cic.univ cic.prop)).

def relation3 :
      __ : cic.Univ univs.Type0 ->
      __1 : cic.Univ univs.Type0 ->
      __2 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      C : cic.Univ univs.Type0 =>
      cic.prod univs.Type0 univs.Type0 A
        (__ : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 univs.Type0 B
           (__1 : cic.Term univs.Type0 B =>
            cic.prod univs.Type0 (cic.type cic.z) C
              (__2 : cic.Term univs.Type0 C => cic.univ cic.prop))).

def relation4 :
      __ : cic.Univ univs.Type0 ->
      __1 : cic.Univ univs.Type0 ->
      __2 : cic.Univ univs.Type0 ->
      __3 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      C : cic.Univ univs.Type0 =>
      D : cic.Univ univs.Type0 =>
      cic.prod univs.Type0 univs.Type0 A
        (__ : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 univs.Type0 B
           (__1 : cic.Term univs.Type0 B =>
            cic.prod univs.Type0 univs.Type0 C
              (__2 : cic.Term univs.Type0 C =>
               cic.prod univs.Type0 (cic.type cic.z) D
                 (__3 : cic.Term univs.Type0 D => cic.univ cic.prop)))).

def reflexive :
      A : cic.Univ univs.Type0 ->
      _R : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      cic.prod univs.Type0 cic.prop A (x : cic.Term univs.Type0 A => R x x).

def symmetric :
      A : cic.Univ univs.Type0 ->
      _R : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (y : cic.Term univs.Type0 A =>
            cic.prod cic.prop cic.prop (R x y)
              (__ : cic.Term cic.prop (R x y) => R y x))).

def transitive :
      A : cic.Univ univs.Type0 ->
      _R : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (y : cic.Term univs.Type0 A =>
            cic.prod univs.Type0 cic.prop A
              (z : cic.Term univs.Type0 A =>
               cic.prod cic.prop cic.prop (R x y)
                 (__ : cic.Term cic.prop (R x y) =>
                  cic.prod cic.prop cic.prop (R y z)
                    (__1 : cic.Term cic.prop (R y z) => R x z))))).

def irreflexive :
      A : cic.Univ univs.Type0 ->
      _R : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A => matita_basics_logic.Not (R x x)).

def cotransitive :
      A : cic.Univ univs.Type0 ->
      _R : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (y : cic.Term univs.Type0 A =>
            cic.prod cic.prop cic.prop (R x y)
              (__ : cic.Term cic.prop (R x y) =>
               cic.prod univs.Type0 cic.prop A
                 (z : cic.Term univs.Type0 A =>
                  matita_basics_logic.Or (R x z) (R z y))))).

def tight_apart :
      A : cic.Univ univs.Type0 ->
      _eq : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      _ap : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      eq : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      ap : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (y : cic.Term univs.Type0 A =>
            matita_basics_logic.And
              (cic.prod cic.prop cic.prop (matita_basics_logic.Not (ap x y))
                 (__ :
                    cic.Term cic.prop (matita_basics_logic.Not (ap x y)) =>
                  eq x y))
              (cic.prod cic.prop cic.prop (eq x y)
                 (__ : cic.Term cic.prop (eq x y) =>
                  matita_basics_logic.Not (ap x y))))).

def antisymmetric :
      A : cic.Univ univs.Type0 ->
      _R : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (y : cic.Term univs.Type0 A =>
            cic.prod cic.prop cic.prop (R x y)
              (__ : cic.Term cic.prop (R x y) =>
               matita_basics_logic.Not (R y x)))).

def singlevalued :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      cic.Term univs.Type0
        (matita_basics_relations.predicate
           (matita_basics_relations.relation2 A B))
      :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation2 A B) =>
      cic.prod univs.Type0 cic.prop A
        (a : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop B
           (b1 : cic.Term univs.Type0 B =>
            cic.prod cic.prop cic.prop (R a b1)
              (__ : cic.Term cic.prop (R a b1) =>
               cic.prod univs.Type0 cic.prop B
                 (b2 : cic.Term univs.Type0 B =>
                  cic.prod cic.prop cic.prop (R a b2)
                    (__1 : cic.Term cic.prop (R a b2) =>
                     matita_basics_logic.eq
                       (cic.lift univs.Type0 univs.Type2 B) b1 b2))))).

def confluent1 :
      A : cic.Univ univs.Type0 ->
      __ : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Term univs.Type0 (matita_basics_relations.predicate A) :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      a0 : cic.Term univs.Type0 A =>
      cic.prod univs.Type0 cic.prop A
        (a1 : cic.Term univs.Type0 A =>
         cic.prod cic.prop cic.prop (R a0 a1)
           (__ : cic.Term cic.prop (R a0 a1) =>
            cic.prod univs.Type0 cic.prop A
              (a2 : cic.Term univs.Type0 A =>
               cic.prod cic.prop cic.prop (R a0 a2)
                 (__1 : cic.Term cic.prop (R a0 a2) =>
                  matita_basics_logic.ex2 A
                    (a : cic.Term univs.Type0 A => R a1 a)
                    (a : cic.Term univs.Type0 A => R a2 a))))).

def confluent :
      A : cic.Univ univs.Type0 ->
      cic.Term univs.Type0
        (matita_basics_relations.predicate
           (matita_basics_relations.relation A))
      :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      cic.prod univs.Type0 cic.prop A
        (a0 : cic.Term univs.Type0 A =>
         matita_basics_relations.confluent1 A R a0).

def Conf3 :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      __ : cic.Term univs.Type0 (matita_basics_relations.relation2 A B) ->
      __1 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      S : cic.Term univs.Type0 (matita_basics_relations.relation2 A B) =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      cic.prod univs.Type0 cic.prop B
        (b : cic.Term univs.Type0 B =>
         cic.prod univs.Type0 cic.prop A
           (a1 : cic.Term univs.Type0 A =>
            cic.prod cic.prop cic.prop (S a1 b)
              (__ : cic.Term cic.prop (S a1 b) =>
               cic.prod univs.Type0 cic.prop A
                 (a2 : cic.Term univs.Type0 A =>
                  cic.prod cic.prop cic.prop (R a1 a2)
                    (__1 : cic.Term cic.prop (R a1 a2) => S a2 b))))).

def RC :
      A : cic.Univ univs.Type0 ->
      __ : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Term univs.Type0 (matita_basics_relations.relation A) :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      x : cic.Term univs.Type0 A =>
      y : cic.Term univs.Type0 A =>
      matita_basics_logic.Or (R x y)
        (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) x y).

def RC_reflexive :
      A : cic.Univ univs.Type0 ->
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Term cic.prop
        (matita_basics_relations.reflexive A (matita_basics_relations.RC A R))
      :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      x : cic.Term univs.Type0 A =>
      matita_basics_logic.or_intror (R x x)
        (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) x x)
        (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 A) x).

def Rcomp :
      A : cic.Univ univs.Type0 ->
      _R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      _R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      _a1 : cic.Term univs.Type0 A ->
      _a2 : cic.Term univs.Type0 A -> cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      a1 : cic.Term univs.Type0 A =>
      a2 : cic.Term univs.Type0 A =>
      matita_basics_logic.ex A
        (am : cic.Term univs.Type0 A =>
         matita_basics_logic.And (R1 a1 am) (R2 am a2)).

def Runion :
      A : cic.Univ univs.Type0 ->
      _R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      _R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      _a : cic.Term univs.Type0 A ->
      _b : cic.Term univs.Type0 A -> cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      a : cic.Term univs.Type0 A =>
      b : cic.Term univs.Type0 A => matita_basics_logic.Or (R1 a b) (R2 a b).

def Rintersection :
      A : cic.Univ univs.Type0 ->
      _R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      _R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      _a : cic.Term univs.Type0 A ->
      _b : cic.Term univs.Type0 A -> cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      a : cic.Term univs.Type0 A =>
      b : cic.Term univs.Type0 A => matita_basics_logic.And (R1 a b) (R2 a b).

def inv :
      A : cic.Univ univs.Type0 ->
      _R : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      _a : cic.Term univs.Type0 A ->
      _b : cic.Term univs.Type0 A -> cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      a : cic.Term univs.Type0 A => b : cic.Term univs.Type0 A => R b a.

def subR :
      A : cic.Univ univs.Type0 ->
      _R : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      _S : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      S : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      cic.prod univs.Type0 cic.prop A
        (a : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (b : cic.Term univs.Type0 A =>
            cic.prod cic.prop cic.prop (R a b)
              (__ : cic.Term cic.prop (R a b) => S a b))).

def sub_reflexive :
      T : cic.Univ univs.Type0 ->
      R : cic.Term univs.Type0 (matita_basics_relations.relation T) ->
      cic.Term cic.prop (matita_basics_relations.subR T R R) :=
      T : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation T) =>
      x : cic.Term univs.Type0 T =>
      b : cic.Term univs.Type0 T => auto : cic.Term cic.prop (R x b) => auto.

def sub_comp_l :
      A : cic.Univ univs.Type0 ->
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      __ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2) ->
      cic.Term cic.prop
        (matita_basics_relations.subR A
           (matita_basics_relations.Rcomp A R1 R)
           (matita_basics_relations.Rcomp A R2 R))
      :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      Hsub : cic.Term cic.prop (matita_basics_relations.subR A R1 R2) =>
      a : cic.Term univs.Type0 A =>
      b : cic.Term univs.Type0 A =>
      _clearme :
        cic.Term cic.prop (matita_basics_relations.Rcomp A R1 R a b) =>
      matita_basics_logic.match_ex A
        (am : cic.Term univs.Type0 A =>
         matita_basics_logic.And (R1 a am) (R am b))
        cic.prop
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.ex A
                (am : cic.Term univs.Type0 A =>
                 matita_basics_logic.And (R1 a am) (R am b))) =>
         matita_basics_relations.Rcomp A R2 R a b)
        (c : cic.Term univs.Type0 A =>
         _clearme0 :
           cic.Term cic.prop (matita_basics_logic.And (R1 a c) (R c b)) =>
         matita_basics_logic.match_And (R1 a c) (R c b) cic.prop
           (__ :
              cic.Term cic.prop (matita_basics_logic.And (R1 a c) (R c b)) =>
            matita_basics_relations.Rcomp A R2 R a b)
           (auto : cic.Term cic.prop (R1 a c) =>
            auto' : cic.Term cic.prop (R c b) =>
            matita_basics_logic.ex_intro A
              (am : cic.Term univs.Type0 A =>
               matita_basics_logic.And (R2 a am) (R am b))
              c
              (matita_basics_logic.conj (R2 a c) (R c b) (Hsub a c auto)
                 auto'))
           _clearme0)
        _clearme.

def sub_comp_r :
      A : cic.Univ univs.Type0 ->
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      __ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2) ->
      cic.Term cic.prop
        (matita_basics_relations.subR A
           (matita_basics_relations.Rcomp A R R1)
           (matita_basics_relations.Rcomp A R R2))
      :=
      A : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      Hsub : cic.Term cic.prop (matita_basics_relations.subR A R1 R2) =>
      a : cic.Term univs.Type0 A =>
      b : cic.Term univs.Type0 A =>
      _clearme :
        cic.Term cic.prop (matita_basics_relations.Rcomp A R R1 a b) =>
      matita_basics_logic.match_ex A
        (am : cic.Term univs.Type0 A =>
         matita_basics_logic.And (R a am) (R1 am b))
        cic.prop
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.ex A
                (am : cic.Term univs.Type0 A =>
                 matita_basics_logic.And (R a am) (R1 am b))) =>
         matita_basics_relations.Rcomp A R R2 a b)
        (c : cic.Term univs.Type0 A =>
         _clearme0 :
           cic.Term cic.prop (matita_basics_logic.And (R a c) (R1 c b)) =>
         matita_basics_logic.match_And (R a c) (R1 c b) cic.prop
           (__ :
              cic.Term cic.prop (matita_basics_logic.And (R a c) (R1 c b)) =>
            matita_basics_relations.Rcomp A R R2 a b)
           (auto : cic.Term cic.prop (R a c) =>
            auto' : cic.Term cic.prop (R1 c b) =>
            matita_basics_logic.ex_intro A
              (am : cic.Term univs.Type0 A =>
               matita_basics_logic.And (R a am) (R2 am b))
              c
              (matita_basics_logic.conj (R a c) (R2 c b) auto
                 (Hsub c b auto')))
           _clearme0)
        _clearme.

def sub_assoc_l :
      A : cic.Univ univs.Type0 ->
      R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      R3 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Term cic.prop
        (matita_basics_relations.subR A
           (matita_basics_relations.Rcomp A R1
              (matita_basics_relations.Rcomp A R2 R3))
           (matita_basics_relations.Rcomp A
              (matita_basics_relations.Rcomp A R1 R2) R3))
      :=
      A : cic.Univ univs.Type0 =>
      R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      R3 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      a : cic.Term univs.Type0 A =>
      b : cic.Term univs.Type0 A =>
      _clearme :
        cic.Term cic.prop
          (matita_basics_relations.Rcomp A R1
             (matita_basics_relations.Rcomp A R2 R3) a b) =>
      matita_basics_logic.match_ex A
        (am : cic.Term univs.Type0 A =>
         matita_basics_logic.And (R1 a am)
           (matita_basics_relations.Rcomp A R2 R3 am b))
        cic.prop
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.ex A
                (am : cic.Term univs.Type0 A =>
                 matita_basics_logic.And (R1 a am)
                   (matita_basics_relations.Rcomp A R2 R3 am b))) =>
         matita_basics_relations.Rcomp A
           (matita_basics_relations.Rcomp A R1 R2) R3 a b)
        (c : cic.Term univs.Type0 A =>
         _clearme0 :
           cic.Term cic.prop
             (matita_basics_logic.And (R1 a c)
                (matita_basics_relations.Rcomp A R2 R3 c b)) =>
         matita_basics_logic.match_And (R1 a c)
           (matita_basics_relations.Rcomp A R2 R3 c b) cic.prop
           (__ :
              cic.Term cic.prop
                (matita_basics_logic.And (R1 a c)
                   (matita_basics_relations.Rcomp A R2 R3 c b)) =>
            matita_basics_relations.Rcomp A
              (matita_basics_relations.Rcomp A R1 R2) R3 a b)
           (Hac : cic.Term cic.prop (R1 a c) =>
            _clearme1 :
              cic.Term cic.prop (matita_basics_relations.Rcomp A R2 R3 c b) =>
            matita_basics_logic.match_ex A
              (am : cic.Term univs.Type0 A =>
               matita_basics_logic.And (R2 c am) (R3 am b))
              cic.prop
              (__ :
                 cic.Term cic.prop
                   (matita_basics_logic.ex A
                      (am : cic.Term univs.Type0 A =>
                       matita_basics_logic.And (R2 c am) (R3 am b))) =>
               matita_basics_relations.Rcomp A
                 (matita_basics_relations.Rcomp A R1 R2) R3 a b)
              (d : cic.Term univs.Type0 A =>
               _clearme2 :
                 cic.Term cic.prop
                   (matita_basics_logic.And (R2 c d) (R3 d b)) =>
               matita_basics_logic.match_And (R2 c d) (R3 d b) cic.prop
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.And (R2 c d) (R3 d b)) =>
                  matita_basics_relations.Rcomp A
                    (matita_basics_relations.Rcomp A R1 R2) R3 a b)
                 (auto : cic.Term cic.prop (R2 c d) =>
                  auto' : cic.Term cic.prop (R3 d b) =>
                  matita_basics_logic.ex_intro A
                    (am : cic.Term univs.Type0 A =>
                     matita_basics_logic.And
                       (matita_basics_relations.Rcomp A R1 R2 a am) (
                     R3 am b))
                    d
                    (matita_basics_logic.conj
                       (matita_basics_relations.Rcomp A R1 R2 a d) (R3 d b)
                       (matita_basics_logic.ex_intro A
                          (am : cic.Term univs.Type0 A =>
                           matita_basics_logic.And (R1 a am) (R2 am d))
                          c
                          (matita_basics_logic.conj (R1 a c) (R2 c d) Hac
                             auto))
                       auto'))
                 _clearme2)
              _clearme1)
           _clearme0)
        _clearme.

def sub_assoc_r :
      A : cic.Univ univs.Type0 ->
      R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      R3 : cic.Term univs.Type0 (matita_basics_relations.relation A) ->
      cic.Term cic.prop
        (matita_basics_relations.subR A
           (matita_basics_relations.Rcomp A
              (matita_basics_relations.Rcomp A R1 R2) R3)
           (matita_basics_relations.Rcomp A R1
              (matita_basics_relations.Rcomp A R2 R3)))
      :=
      A : cic.Univ univs.Type0 =>
      R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      R3 : cic.Term univs.Type0 (matita_basics_relations.relation A) =>
      a : cic.Term univs.Type0 A =>
      b : cic.Term univs.Type0 A =>
      _clearme :
        cic.Term cic.prop
          (matita_basics_relations.Rcomp A
             (matita_basics_relations.Rcomp A R1 R2) R3 a b) =>
      matita_basics_logic.match_ex A
        (am : cic.Term univs.Type0 A =>
         matita_basics_logic.And (matita_basics_relations.Rcomp A R1 R2 a am)
           (R3 am b))
        cic.prop
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.ex A
                (am : cic.Term univs.Type0 A =>
                 matita_basics_logic.And
                   (matita_basics_relations.Rcomp A R1 R2 a am) (R3 am b))) =>
         matita_basics_relations.Rcomp A R1
           (matita_basics_relations.Rcomp A R2 R3) a b)
        (c : cic.Term univs.Type0 A =>
         _clearme0 :
           cic.Term cic.prop
             (matita_basics_logic.And
                (matita_basics_relations.Rcomp A R1 R2 a c) (R3 c b)) =>
         matita_basics_logic.match_And
           (matita_basics_relations.Rcomp A R1 R2 a c) (R3 c b) cic.prop
           (__ :
              cic.Term cic.prop
                (matita_basics_logic.And
                   (matita_basics_relations.Rcomp A R1 R2 a c) (R3 c b)) =>
            matita_basics_relations.Rcomp A R1
              (matita_basics_relations.Rcomp A R2 R3) a b)
           (_clearme1 :
              cic.Term cic.prop (matita_basics_relations.Rcomp A R1 R2 a c) =>
            matita_basics_logic.match_ex A
              (am : cic.Term univs.Type0 A =>
               matita_basics_logic.And (R1 a am) (R2 am c))
              cic.prop
              (__ :
                 cic.Term cic.prop
                   (matita_basics_logic.ex A
                      (am : cic.Term univs.Type0 A =>
                       matita_basics_logic.And (R1 a am) (R2 am c))) =>
               cic.prod cic.prop cic.prop (R3 c b)
                 (__1 : cic.Term cic.prop (R3 c b) =>
                  matita_basics_relations.Rcomp A R1
                    (matita_basics_relations.Rcomp A R2 R3) a b))
              (d : cic.Term univs.Type0 A =>
               _clearme2 :
                 cic.Term cic.prop
                   (matita_basics_logic.And (R1 a d) (R2 d c)) =>
               matita_basics_logic.match_And (R1 a d) (R2 d c) cic.prop
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.And (R1 a d) (R2 d c)) =>
                  cic.prod cic.prop cic.prop (R3 c b)
                    (__1 : cic.Term cic.prop (R3 c b) =>
                     matita_basics_relations.Rcomp A R1
                       (matita_basics_relations.Rcomp A R2 R3) a b))
                 (auto : cic.Term cic.prop (R1 a d) =>
                  auto' : cic.Term cic.prop (R2 d c) =>
                  auto'' : cic.Term cic.prop (R3 c b) =>
                  matita_basics_logic.ex_intro A
                    (am : cic.Term univs.Type0 A =>
                     matita_basics_logic.And (R1 a am)
                       (matita_basics_relations.Rcomp A R2 R3 am b))
                    d
                    (matita_basics_logic.conj (R1 a d)
                       (matita_basics_relations.Rcomp A R2 R3 d b) auto
                       (matita_basics_logic.ex_intro A
                          (am : cic.Term univs.Type0 A =>
                           matita_basics_logic.And (R2 d am) (R3 am b))
                          c
                          (matita_basics_logic.conj (R2 d c) (R3 c b) auto'
                             auto''))))
                 _clearme2)
              _clearme1)
           _clearme0)
        _clearme.

def compose :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      C : cic.Univ univs.Type0 ->
      _f : (__ : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) ->
      _g : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) ->
      _x : cic.Term univs.Type0 A -> cic.Term univs.Type0 C :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      C : cic.Univ univs.Type0 =>
      f : (__ : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) =>
      g : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) =>
      x : cic.Term univs.Type0 A => f (g x).

def injective :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (y : cic.Term univs.Type0 A =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B)
                 (f x) (f y))
              (__ :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift univs.Type0 univs.Type2 B) (f x) (f y)) =>
               matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) x
                 y))).

def surjective :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) =>
      cic.prod univs.Type0 cic.prop B
        (z : cic.Term univs.Type0 B =>
         matita_basics_logic.ex A
           (x : cic.Term univs.Type0 A =>
            matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) z
              (f x))).

def commutative :
      A : cic.Univ univs.Type0 ->
      _f :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      f :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (y : cic.Term univs.Type0 A =>
            matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A)
              (f x y) (f y x))).

def commutative2 :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      _f :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      f :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (y : cic.Term univs.Type0 A =>
            matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B)
              (f x y) (f y x))).

def associative :
      A : cic.Univ univs.Type0 ->
      _f :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      f :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (y : cic.Term univs.Type0 A =>
            cic.prod univs.Type0 cic.prop A
              (z : cic.Term univs.Type0 A =>
               matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A)
                 (f (f x y) z) (f x (f y z))))).

def monotonic :
      A : cic.Univ univs.Type0 ->
      _R :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      R :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 A -> cic.Univ cic.prop) =>
      f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (y : cic.Term univs.Type0 A =>
            cic.prod cic.prop cic.prop (R x y)
              (__ : cic.Term cic.prop (R x y) => R (f x) (f y)))).

def distributive :
      A : cic.Univ univs.Type0 ->
      _f :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) ->
      _g :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      f :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) =>
      g :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (y : cic.Term univs.Type0 A =>
            cic.prod univs.Type0 cic.prop A
              (z : cic.Term univs.Type0 A =>
               matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A)
                 (f x (g y z)) (g (f x y) (f x z))))).

def distributive2 :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      _f :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) ->
      _g :
        (__ : cic.Term univs.Type0 B ->
         __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      f :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) =>
      g :
        (__ : cic.Term univs.Type0 B ->
         __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) =>
      cic.prod univs.Type0 cic.prop A
        (x : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop B
           (y : cic.Term univs.Type0 B =>
            cic.prod univs.Type0 cic.prop B
              (z : cic.Term univs.Type0 B =>
               matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B)
                 (f x (g y z)) (g (f x y) (f x z))))).

def injective_compose :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      C : cic.Univ univs.Type0 ->
      f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) ->
      g : (__ : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) ->
      __ : cic.Term cic.prop (matita_basics_relations.injective A B f) ->
      __1 : cic.Term cic.prop (matita_basics_relations.injective B C g) ->
      cic.Term cic.prop
        (matita_basics_relations.injective A C
           (x : cic.Term univs.Type0 A => g (f x)))
      :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      C : cic.Univ univs.Type0 =>
      f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) =>
      g : (__ : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) =>
      auto : cic.Term cic.prop (matita_basics_relations.injective A B f) =>
      auto' : cic.Term cic.prop (matita_basics_relations.injective B C g) =>
      x : cic.Term univs.Type0 A =>
      y : cic.Term univs.Type0 A =>
      auto'' :
        cic.Term cic.prop
          (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 C)
             (g (f x)) (g (f y))) =>
      auto x y
        (auto' (f x) (f y)
           (matita_basics_logic.rewrite_l
              (cic.lift univs.Type0 univs.Type2 C) (g (f x))
              (__ : cic.Term univs.Type0 C =>
               cic.lift cic.prop univs.Type2
                 ((x0 : cic.Term univs.Type0 C =>
                   matita_basics_logic.eq
                     (cic.lift univs.Type0 univs.Type2 C) (g (f x)) x0)
                    __))
              (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 C)
                 (g (f x)))
              (g (f y)) auto'')).

def exteqR :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      _R :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) ->
      _S :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      R :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) =>
      S :
        (__ : cic.Term univs.Type0 A ->
         __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) =>
      cic.prod univs.Type0 cic.prop A
        (a : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop B
           (b : cic.Term univs.Type0 B =>
            matita_basics_logic.iff (R a b) (S a b))).

def exteqF :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) ->
      _g : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) =>
      g : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) =>
      cic.prod univs.Type0 cic.prop A
        (a : cic.Term univs.Type0 A =>
         matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f a)
           (g a)).

def bi_relation :
      __ : cic.Univ univs.Type0 ->
      __1 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      cic.prod univs.Type0 univs.Type0 A
        (__ : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 univs.Type0 B
           (__1 : cic.Term univs.Type0 B =>
            cic.prod univs.Type0 univs.Type0 A
              (__2 : cic.Term univs.Type0 A =>
               cic.prod univs.Type0 (cic.type cic.z) B
                 (__3 : cic.Term univs.Type0 B => cic.univ cic.prop)))).

def bi_reflexive :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      _R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) =>
      cic.prod univs.Type0 cic.prop A
        (a : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop B
           (b : cic.Term univs.Type0 B => R a b a b)).

def bi_symmetric :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      _R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) =>
      cic.prod univs.Type0 cic.prop A
        (a1 : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (a2 : cic.Term univs.Type0 A =>
            cic.prod univs.Type0 cic.prop B
              (b1 : cic.Term univs.Type0 B =>
               cic.prod univs.Type0 cic.prop B
                 (b2 : cic.Term univs.Type0 B =>
                  cic.prod cic.prop cic.prop (R a2 b2 a1 b1)
                    (__ : cic.Term cic.prop (R a2 b2 a1 b1) => R a1 b1 a2 b2))))).

def bi_transitive :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      _R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) =>
      cic.prod univs.Type0 cic.prop A
        (a1 : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (a : cic.Term univs.Type0 A =>
            cic.prod univs.Type0 cic.prop B
              (b1 : cic.Term univs.Type0 B =>
               cic.prod univs.Type0 cic.prop B
                 (b : cic.Term univs.Type0 B =>
                  cic.prod cic.prop cic.prop (R a1 b1 a b)
                    (__ : cic.Term cic.prop (R a1 b1 a b) =>
                     cic.prod univs.Type0 cic.prop A
                       (a2 : cic.Term univs.Type0 A =>
                        cic.prod univs.Type0 cic.prop B
                          (b2 : cic.Term univs.Type0 B =>
                           cic.prod cic.prop cic.prop (R a b a2 b2)
                             (__1 : cic.Term cic.prop (R a b a2 b2) =>
                              R a1 b1 a2 b2)))))))).

def bi_RC :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      __ : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) ->
      cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) =>
      a1 : cic.Term univs.Type0 A =>
      b1 : cic.Term univs.Type0 B =>
      a2 : cic.Term univs.Type0 A =>
      b2 : cic.Term univs.Type0 B =>
      matita_basics_logic.Or (R a1 b1 a2 b2)
        (matita_basics_logic.And
           (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a1 a2)
           (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b1 b2)).

def bi_RC_reflexive :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) ->
      cic.Term cic.prop
        (matita_basics_relations.bi_reflexive A B
           (matita_basics_relations.bi_RC A B R))
      :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) =>
      a : cic.Term univs.Type0 A =>
      b : cic.Term univs.Type0 B =>
      matita_basics_logic.or_intror (R a b a b)
        (matita_basics_logic.And
           (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a a)
           (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b))
        (matita_basics_logic.conj
           (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a a)
           (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b)
           (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 A) a)
           (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 B) b)).

def tri_relation :
      __ : cic.Univ univs.Type0 ->
      __1 : cic.Univ univs.Type0 ->
      __2 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      C : cic.Univ univs.Type0 =>
      cic.prod univs.Type0 univs.Type0 A
        (__ : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 univs.Type0 B
           (__1 : cic.Term univs.Type0 B =>
            cic.prod univs.Type0 univs.Type0 C
              (__2 : cic.Term univs.Type0 C =>
               cic.prod univs.Type0 univs.Type0 A
                 (__3 : cic.Term univs.Type0 A =>
                  cic.prod univs.Type0 univs.Type0 B
                    (__4 : cic.Term univs.Type0 B =>
                     cic.prod univs.Type0 (cic.type cic.z) C
                       (__5 : cic.Term univs.Type0 C => cic.univ cic.prop)))))).

def tri_reflexive :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      C : cic.Univ univs.Type0 ->
      _R :
        cic.Term univs.Type0 (matita_basics_relations.tri_relation A B C) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      C : cic.Univ univs.Type0 =>
      R :
        cic.Term univs.Type0 (matita_basics_relations.tri_relation A B C) =>
      cic.prod univs.Type0 cic.prop A
        (a : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop B
           (b : cic.Term univs.Type0 B =>
            cic.prod univs.Type0 cic.prop C
              (c : cic.Term univs.Type0 C => R a b c a b c))).

def tri_symmetric :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      C : cic.Univ univs.Type0 ->
      _R :
        cic.Term univs.Type0 (matita_basics_relations.tri_relation A B C) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      C : cic.Univ univs.Type0 =>
      R :
        cic.Term univs.Type0 (matita_basics_relations.tri_relation A B C) =>
      cic.prod univs.Type0 cic.prop A
        (a1 : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (a2 : cic.Term univs.Type0 A =>
            cic.prod univs.Type0 cic.prop B
              (b1 : cic.Term univs.Type0 B =>
               cic.prod univs.Type0 cic.prop B
                 (b2 : cic.Term univs.Type0 B =>
                  cic.prod univs.Type0 cic.prop C
                    (c1 : cic.Term univs.Type0 C =>
                     cic.prod univs.Type0 cic.prop C
                       (c2 : cic.Term univs.Type0 C =>
                        cic.prod cic.prop cic.prop (R a2 b2 c2 a1 b1 c1)
                          (__ : cic.Term cic.prop (R a2 b2 c2 a1 b1 c1) =>
                           R a1 b1 c1 a2 b2 c2))))))).

def tri_transitive :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      C : cic.Univ univs.Type0 ->
      _R :
        cic.Term univs.Type0 (matita_basics_relations.tri_relation A B C) ->
      cic.Univ cic.prop :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      C : cic.Univ univs.Type0 =>
      R :
        cic.Term univs.Type0 (matita_basics_relations.tri_relation A B C) =>
      cic.prod univs.Type0 cic.prop A
        (a1 : cic.Term univs.Type0 A =>
         cic.prod univs.Type0 cic.prop A
           (a : cic.Term univs.Type0 A =>
            cic.prod univs.Type0 cic.prop B
              (b1 : cic.Term univs.Type0 B =>
               cic.prod univs.Type0 cic.prop B
                 (b : cic.Term univs.Type0 B =>
                  cic.prod univs.Type0 cic.prop C
                    (c1 : cic.Term univs.Type0 C =>
                     cic.prod univs.Type0 cic.prop C
                       (c : cic.Term univs.Type0 C =>
                        cic.prod cic.prop cic.prop (R a1 b1 c1 a b c)
                          (__ : cic.Term cic.prop (R a1 b1 c1 a b c) =>
                           cic.prod univs.Type0 cic.prop A
                             (a2 : cic.Term univs.Type0 A =>
                              cic.prod univs.Type0 cic.prop B
                                (b2 : cic.Term univs.Type0 B =>
                                 cic.prod univs.Type0 cic.prop C
                                   (c2 : cic.Term univs.Type0 C =>
                                    cic.prod cic.prop cic.prop
                                      (R a b c a2 b2 c2)
                                      (__1 :
                                         cic.Term cic.prop (R a b c a2 b2 c2) =>
                                       R a1 b1 c1 a2 b2 c2))))))))))).


