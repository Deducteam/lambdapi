reserved "_"
reserved "abort"
reserved "admit"
reserved "and"
reserved "apply"
reserved "as"
reserved "assert"
reserved "assertnot"
reserved "assume"
reserved "compute"
reserved "constant"
reserved "definition"
reserved "focus"
reserved "in"
reserved "injective"
reserved "hint"
reserved "let"
reserved "open"
reserved "print"
reserved "private"
reserved "proof"
reserved "proofterm"
reserved "protected"
reserved "qed"
reserved "refine"
reserved "reflexivity"
reserved "require"
reserved "rewrite"
reserved "rule"
reserved "set"
reserved "simpl"
reserved "symmetry"
reserved "symbol"
reserved "theorem"
reserved "type"
reserved "TYPE"
reserved "why3"

<declared_id> ::=
  | "ℕ"
  | "α"
  | ... // whatever has ben defined in the scope.

// Identifier
<ident> ::=
  | RE("[a-zA-Z_][a-zA-Z0-9_]*")     // Regular identifier
  | RE("{|\([^|]\|\(|[^}]\)\)*|*|}") // Escaped identifier
  | <declared_id>                    // Declared identifier

// Natural number literal
<nat_lit> ::=
  | RE("[0-9]+")

// Float literal
<float_lit> ::=
  | RE("[0-9]+\([.][0-9]+\)?")

// String literal
<string_lit> ::=
  | RE("\"[^\"\n]*\"")

<path> ::=
  | {<ident> "."}* <ident>

<qident> ::=
  | {<ident> "."}* <ident>

// Variable of a pattern
<pvar> ::=
  | "&" - {<ident> | "_"}

<property> ::=
  | "constant"
  | "injective"

<exposition> ::=
  | "protected"
  | "private"

<infix_op> ::=
  | "+"
  | "×"
  | ... // whatever has been defined in the scope.

// Term (including patterns and everything)
<term> ::=
  | "TYPE"
  | "@"? <qident>
  | "_"
  | "?" - <ident> {"[" <term> {"," <term>}* "]"}?
  | <pvar> {"[" <term> {"," <term>}* "]"}?
  | "(" <term> ")"
  | "{" <term> "}"
  | <term> <term>
  | <type> "⇒" <type>
  | "∀" <arg>+ "," <type>
  | "λ" <arg>+ "," <term>
  | "let" <ident> <arg>* "≔" <term> "in" <term>
  | <nat_lit>
  | <term> <infix_op> <term>

// Synonym for types
<type> ::= <term>

// Synonym for patterns
<patt> ::= <term>

// Argument (of abstraction, product, ...), may be marked implicit
<arg> ::=
  | <ident>
  | "{" <ident>+ {":" <type>}? "}"
  | "(" <ident>+ ":" <type> ")"

// Rewriting rule
<rule> ::=
  | <patt> "→" <term>

// TODO rule naming, positive / negative

// Unification hint
<hint> ::=
  | <patt> "≡" <patt> "→" <pvar> "≡" <term> {"," <term> "≡" <term>}*

// Rewrite pattern
<rw_patt> ::=
  | <term>
  | "in" <term>
  | "in" <ident> "in" <term>
  | <ident> "in" <term>
  | <term> "in" <ident> "in" <term>
  | <term> "as" <ident> "in" <term>

// Proof tactics
<tactic> ::=
  | "refine" <term>
  | "assume" <ident>+
  | "apply" <term>
  | "simpl"
  | "rewrite" {"[" <rw_patt> "]"}? <term>
  | "reflexivity"
  | "symmetry"
  | "focus" <nat_lit>
  | "print"
  | "proofterm"
  | "why3" <string_lit>?

// Assertion predicate
<assertion> ::=
  // Typing assertion
  | <term> ":" <term>
  // Convertibility assertion
  | <term> "≡" <term>

// Single command.
<command> ::=
  // Require and/or open a module
  | "require" <path> "as" <ident>
  | "require" "open"? <path>
  | "open" <path>
  // Define a new symbol
  | <exposition>? <property>? "symbol" <ident> <arg>* ":" <type>
  // Define a new rewriting rule
  | "rule" <rule> {"and" <rule>}*
  // Definition of a symbol or theorem
  | <exposition>? "definition" <ident> <arg>* {":" <type>}? "≔" <term>
  | <exposition>? "theorem" <ident> <arg>* ":" <type> "proof" <tactic>*
    {"qed"|"admit"|"abort"}
  // Assertion
  | "assert" <assertion>
  | "assertnot" <assertion>
  // Set option
  | "set" "verbose" RE("[1-9][0-9]*")
  | "set" "debug" RE("[-+][a-zA-Z]+")
  | "set" "builtin" <string_lit> "≔" <qident>
  | "set" "prefix" <float_lit> <string_lit> "≔" <qident>
  | "set" "infix" {"left" | "right"}? <float_lit> <string_lit> "≔" <qident>
  | "set" "prover" <ident>
  | "set" "prover_timeout" <nat_lit>
  | "set" "declared" <string_lit>
  // Get the type of a term
  | "type" <term>
  // Get the normal form of a term
  | "compute" <term>

// Entry point: list of commands.
<main> ::= <command>*
