; DO NOT EDIT THIS FILE MANUALLY
; It is generated automatically with 'make bnf'.

QID ::= [UID "."]+ UID

<switch> ::= "on"
           | "off"

<side> ::= "left"
         | "right"

<assert> ::= "assert"
           | "assertnot"

<command> ::= "require" "open" <path>* ";"
            | "require" <path>* ";"
            | "require" <path> "as" <uid> ";"
            | "open" <path>* ";"
            | <modifier>* "symbol" <uid_or_nat> <param_list>* ":" <term>
              [<proof>] ";"
            | <modifier>* "symbol" <uid_or_nat> <param_list>* [":" <term>]
              "≔" <term_proof> ";"
            | <modifier>* <param_list>* "inductive" <inductive> ("with"
              <inductive>)* ";"
            | "rule" <rule> ("with" <rule>)* ";"
            | "builtin" <stringlit> "≔" <qid_or_nat> ";"
            | "coerce_rule" <rule> ";"
            | "unif_rule" <unif_rule> ";"
            | "notation" <qid_or_nat> <notation> ";"
            | <query> ";"
            

<query> ::= <assert> <param_list>* "⊢" <term> ":" <term>
          | <assert> <param_list>* "⊢" <term> "≡" <term>
          | "compute" <term>
          | "print" [<qid>]
          | "proofterm"
          | "debug" ("+"|"-") <string>
          | "flag" <stringlit> <switch>
          | "prover" <stringlit>
          | "prover_timeout" <nat>
          | "verbose" <nat>
          | "type" <term>

<path> ::= UID
         | QID

<modifier> ::= [<side>] "associative"
             | "commutative"
             | "constant"
             | "injective"
             | "opaque"
             | "private"
             | "protected"
             | "sequential"

<uid> ::= UID

<uid_or_nat> ::= <uid>
               | <nat>

<qid_or_nat> ::= <qid>
               | <nat>

<param_list> ::= <param>
               | "(" <param>+ ":" <term> ")"
               | "[" <param>+ [":" <term>] "]"

<param> ::= <uid>
          | <nat>
          | "_"

<term> ::= <bterm>
         | <saterm>
         | <saterm> <bterm>
         | <saterm> "→" <term>

<bterm> ::= "`" <term_id> <binder>
          | "Π" <binder>
          | "λ" <binder>
          | "let" <uid> <param_list>* [":" <term>] "≔" <term> "in" <term>

<saterm> ::= <aterm>+

<aterm> ::= <term_id>
          | "_"
          | "TYPE"
          | "?" UID [<env>]
          | "$" UID [<env>]
          | "(" <term> ")"
          | "[" <term> "]"
          | <nat>

<env> ::= "." "[" [<term> (";" <term>)*] "]"

<term_id> ::= <qid>
            | <qid_expl>

<qid> ::= UID
        | QID

<qid_expl> ::= "@" UID
             | "@" QID

<binder> ::= <param_list>+ "," <term>
           | <param> ":" <term> "," <term>

<term_proof> ::= <term>
               | <proof>
               | <term> <proof>

<proof> ::= "begin" <subproof>+ <proof_end>
          | "begin" [<proof_steps>] <proof_end>

<subproof> ::= "{" [<proof_steps>] "}"

<proof_steps> ::= <proof_step>
                | <proof_step> ";"
                | <proof_step> ";" <proof_steps>

<proof_step> ::= <tactic> <subproof>*

<proof_end> ::= "abort"
              | "admitted"
              | "end"

<tactic> ::= <query>
           | "admit"
           | "apply" <term>
           | "assume" <param>+
           | "fail"
           | "generalize" <uid>
           | "have" <uid> ":" <term>
           | "induction"
           | "refine" <term>
           | "reflexivity"
           | "rewrite" [<side>] [<rw_patt_spec>] <term>
           | "simplify" [<qid_or_nat>]
           | "solve"
           | "symmetry"
           | "why3" [<stringlit>]

<rw_patt> ::= <term>
            | "in" <term>
            | "in" <uid> "in" <term>
            | <term> "in" <term> ["in" <term>]
            | <term> "as" <uid> "in" <term>

<rw_patt_spec> ::= "." "[" <rw_patt> "]"

<inductive> ::= <uid> <param_list>* ":" <term> "≔" ["|"] [<constructor>
                ("|" <constructor>)*]

<constructor> ::= <uid_or_nat> <param_list>* ":" <term>

<rule> ::= <term> "↪" <term>

<unif_rule> ::= <equation> "↪" "[" <equation> (";"
                <equation>)* "]"

<equation> ::= <term> "≡" <term>

<notation> ::= "infix" [<side>] <nat_or_float>
             | "postfix" <nat_or_float>
             | "prefix" <nat_or_float>
             | "quantifier"

<nat_or_float> ::= <nat>
                 | <float>


