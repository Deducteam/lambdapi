QID ::= [UID "."]+ UID

<switch> ::= "on"
           | "off"

<side> ::= "left"
         | "right"

<assert> ::= "assert"
           | "assertnot"

<command> ::= "opaque" <qid> ";"
            | "require" <path>* ";"
            | "require" <open_cmd> <path>* ";"
            | "require" <path> "as" UID ";"
            | <open_cmd> <path>* ";"
            | <modifier>* "symbol" UID <param_list>* ":" <term> [<proof>] ";"
            | <modifier>* "symbol" UID <param_list>* [":" <term>] "≔" <term_proof> ";"
            | [<exposition>] <param_list>* "inductive" <inductive> ("with" <inductive>)* ";"
            | "rule" <rule> ("with" <rule>)* ";"
            | "builtin" <string> "≔" <qid> ";"
            | "coerce_rule" <rule> ";"
            | "unif_rule" <unif_rule> ";"
            | "notation" <qid> <notation> ";"
            | <query> ";"

<open_cmd> ::= "open"
             | "private" "open"

<query> ::= <assert> <param_list>* "⊢" <term> ":" <term>
          | <assert> <param_list>* "⊢" <term> "≡" <term>
          | "compute" <term>
          | "print" [<qid_or_rule>]
          | "proofterm"
          | "debug"
          | "debug" ("+"|"-") <char>+
          | "flag"
          | "flag" <string> <switch>
          | "prover" <string>
          | "prover_timeout" <integer>
          | "verbose" <integer>
          | "type" <term>
          | "search" <string>

<qid_or_rule> ::= <qid>
                | "unif_rule"
                | "coerce_rule"

<path> ::= UID
         | QID

<modifier> ::= [<side>] "associative"
             | "commutative"
             | "constant"
             | "injective"
             | "opaque"
             | "sequential"
             | <exposition>

<exposition> ::= "private"
               | "protected"

<param_list> ::= <param>
               | "(" <param>+ ":" <term> ")"
               | "[" <param>+ [":" <term>] "]"

<param> ::= UID
          | "_"

<term> ::= <bterm>
         | <saterm>
         | <saterm> <bterm>
         | <saterm> "→" <term>

<bterm> ::= "`" <term_id> <binder>
          | "Π" <binder>
          | "λ" <binder>
          | "let" UID <param_list>* [":" <term>] "≔" <term> "in" <term>

<saterm> ::= <aterm>+

<aterm> ::= <term_id>
          | "_"
          | "TYPE"
          | "?" UID [<env>]
          | "$" UID [<env>]
          | "(" <term> ")"
          | "[" <term> "]"
          | <integer>
          | <string>

<env> ::= "." "[" [<term> (";" <term>)*] "]"

<term_id> ::= <qid>
            | <qid_expl>

<qid> ::= UID
        | QID

<qid_expl> ::= "@" UID
             | "@" QID

<binder> ::= <param_list>+ "," <term>
           | <param> ":" <term> "," <term>

<term_proof> ::= <term>
               | <proof>
               | <term> <proof>

<proof> ::= "begin" <subproof>+ <proof_end>
          | "begin" [<proof_steps>] <proof_end>

<subproof> ::= "{" [<proof_steps>] "}"

<proof_steps> ::= <proof_step>
                | <proof_step> ";"
                | <proof_step> ";" <proof_steps>

<proof_step> ::= <tactic> <subproof>*

<proof_end> ::= "abort"
              | "admitted"
              | "end"

<tactic> ::= <query>
           | "admit"
           | "apply" <term>
           | "assume" <param>+
           | "change" <term>
           | "eval" <term>
           | "fail"
           | "generalize" UID
           | "have" UID ":" <term>
           | "induction"
           | "orelse" <tactic> <tactic>
           | "refine" <term>
           | "reflexivity"
           | "remove" UID+
           | "repeat" <tactic>
           | "rewrite" [<side>] [<rwpatt_spec>] <term>
           | "set" UID "≔" <term>
           | "simplify"
           | "simplify" <qid>
           | "simplify" "rule" "off"
           | "solve"
           | "symmetry"
           | "try" <tactic>
           | "why3" [<string>]

<rwpatt> ::= <term>
            | "in" <term>
            | "in" UID "in" <term>
            | <term> "in" <term> ["in" <term>]
            | <term> "as" UID "in" <term>

<rwpatt_spec> ::= "." "[" <rwpatt> "]"

<inductive> ::= UID <param_list>* ":" <term> "≔" ["|"] [<constructor> ("|" <constructor>)*]

<constructor> ::= UID <param_list>* ":" <term>

<rule> ::= <term> "↪" <term>

<unif_rule> ::= <equation> "↪" "[" <equation> (";" <equation>)* "]"

<equation> ::= <term> "≡" <term>

<notation> ::= "infix" [<side>] <float_or_int>
             | "postfix" <float_or_int>
             | "prefix" <float_or_int>
             | "quantifier"

<float_or_int> ::= <float>
                 | <integer>

<where> ::= UID ["generalize"]

<asearch_query> ::= "type" <where> <aterm>
                  | "rule" <where> <aterm>
                  | UID <where> <aterm>
                  | "(" <search_query> ")"

<csearch_query> ::= <asearch_query> ("," <asearch_query>)*

<ssearch_query> ::= <csearch_query> (";" <csearch_query>)*

<search_query> ::= <ssearch_query>
                 | <search_query> "|" <qid>
