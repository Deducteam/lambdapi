<qid> ::= [<uid> "."]+ <uid>

<id> ::= <uid> | <qid>

<switch> ::= "on" | "off"

<side> ::= "left" | "right"

<assert> ::= "assert" | "assertnot"

<command> ::= "opaque" <qid> ";"
            | "require" <qid>+ ";"
            | "require" [["private"] "open"] <qid>+ ";"
            | "require" <qid> "as" <uid> ";"
            | ["private"] "open" <qid>+ ";"
            | [<exposition>] <modifier>* "symbol" <uid> <param_list>* ":" <term> [<proof>] ";"
            | [<exposition>] <modifier>* "symbol" <uid> <param_list>* [":" <term>] "≔" <term_proof> ";"
            | [<exposition>] <param_list>* "inductive" <inductive> ("with" <inductive>)* ";"
            | "rule" <rule> ("with" <rule>)* ";"
            | "builtin" <string> "≔" <id> ";"
            | "coerce_rule" <rule> ";"
            | "unif_rule" <unif_rule> ";"
            | "notation" <id> <notation> ";"
            | <query> ";"

<query> ::= <assert> <param_list>* "⊢" <term> (":"|"≡") <term>
          | "compute" <term>
          | "print" [<id> | "unif_rule" | "coerce_rule"]
          | "proofterm"
          | "debug"
          | "debug" ("+"|"-") <char>+
          | "flag"
          | "flag" <string> <switch>
          | "prover" <string>
          | "prover_timeout" <integer>
          | "verbose" <integer>
          | "type" <term>
          | "search" <string>

<modifier> ::= [<side>] "associative"
             | "commutative"
             | "constant"
             | "injective"
             | "opaque"
             | "sequential"

<exposition> ::= "private" | "protected"

<param_list> ::= <param>
               | "(" <param>+ ":" <term> ")"
               | "[" <param>+ [":" <term>] "]"

<param> ::= <uid> | "_"

<term> ::= <application> ["→" <term>]
         | [<application>] <bterm>

<application> ::= <hterm> <aterm>*

<bterm> ::= <binder> <abstraction>
          | "let" <uid> <param_list>* [":" <term>] "≔" <term> "in" <term>

<binder> ::= "λ" | "Π" | "`" ["@"] <id>

<hterm> ::= ["@"] <id>
          | "_"
          | "TYPE"
          | "?" <uid> [<env>]
          | "$" <uid> [<env>]
          | "(" <term> ")"
          | <integer>
          | <string>

<aterm> ::= <hterm> | "[" <term> "]"

<env> ::= "." "[" [<term> (";" <term>)*] "]"

<abstraction> ::= <param_list>+ "," <term>
                | <param> ":" <term> "," <term>

<term_proof> ::= <term>
               | <proof>
               | <term> <proof>

<proof> ::= "begin" <subproof>+ <proof_end>
          | "begin" [<proof_steps>] <proof_end>

<subproof> ::= "{" [<proof_steps>] "}"

<proof_steps> ::= <proof_step>
                | <proof_step> ";"
                | <proof_step> ";" <proof_steps>

<proof_step> ::= <tactic> <subproof>*

<proof_end> ::= "end" | "abort" | "admitted"

<tactic> ::= <query>
           | "admit"
           | "apply" <term>
           | "assume" <param>+
           | "change" <term>
           | "eval" <term>
           | "fail"
           | "generalize" <uid>
           | "have" <uid> ":" <term>
           | "induction"
           | "orelse" <tactic> <tactic>
           | "refine" <term>
           | "reflexivity"
           | "remove" <uid>+
           | "repeat" <tactic>
           | "rewrite" [<side>] ["." "[" <rwpatt> "]"] <term>
           | "set" <uid> "≔" <term>
           | "simplify"
           | "simplify" <id>
           | "simplify" "rule" "off"
           | "solve"
           | "symmetry"
           | "try" <tactic>
           | "why3" [<string>]

<rwpatt> ::= <term>
            | "in" <term>
            | "in" <uid> "in" <term>
            | <term> "in" <term> ["in" <term>]
            | <term> "as" <uid> "in" <term>

<inductive> ::= <uid> <param_list>* ":" <term> "≔" ["|"] [<constructor> ("|" <constructor>)*]

<constructor> ::= <uid> <param_list>* ":" <term>

<rule> ::= <term> "↪" <term>

<unif_rule> ::= <equation> "↪" "[" <equation> (";" <equation>)* "]"

<equation> ::= <term> "≡" <term>

<notation> ::= "infix" [<side>] <float_or_int>
             | "postfix" <float_or_int>
             | "prefix" <float_or_int>
             | "quantifier"

<float_or_int> ::= <float> | <integer>

<relation> ::= "=" | ">" | ">=" | "≥"

<where> ::= "concl" | "hyp" | "spine" | "rule" | "lhs" | "rhs"

<asearch_query> ::= "name" "=" <uid>
                  | ("type"|"anywhere") ("≥"|">=") ["generalize"] <term>
                  | <where> <relation> ["generalize"] <term>
                  | "(" <search_query> ")"

<csearch_query> ::= <asearch_query> ("," <asearch_query>)*

<ssearch_query> ::= <csearch_query> (";" <csearch_query>)*

<search_query> ::= <ssearch_query>
                 | <search_query> "|" <id>
